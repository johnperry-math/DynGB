#ifndef __MONOMIAL_IDEAL_HPP_
#define __MONOMIAL_IDEAL_HPP_

/*****************************************************************************\
* This file is part of DynGB.                                                 *
*                                                                             *
* DynGB is free software: you can redistribute it and/or modify               *
* it under the terms of the GNU General Public License as published by        *
* the Free Software Foundation, either version 2 of the License, or           *
* (at your option) any later version.                                         *
*                                                                             *
* DynGB is distributed in the hope that it will be useful,                    *
* but WITHOUT ANY WARRANTY; without even the implied warranty of              *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
* GNU General Public License for more details.                                *
*                                                                             *
* You should have received a copy of the GNU General Public License           *
* along with DynGB. If not, see <http://www.gnu.org/licenses/>.               *
\*****************************************************************************/

#include <cstddef>
#include <iostream>
using std::cout; using std::endl;
#include <map>
using std::map;
#include <list>
using std::list;
#include <vector>
using std::vector;

#include "system_constants.hpp"

#include "betti.hpp"
#include "monomial.hpp"
#include "hilbert_functions.hpp"
#include "polynomial.hpp"

/**
  @ingroup polygroup
  @class Monomial_Ideal_Variables_Exception
  @author John Perry
  @date 2016
  @brief exceptions for Monomial Ideals
*/
class Monomial_Ideal_Variables_Exception : public std::exception {
  virtual const char * what() const throw() {
    return "Monomials in list for monomial ideal need same number of variables";
  }
};

/**
  @ingroup polygroup
  @author John Perry
  @date 2016
  @brief Computes the generators of an ideal and a new generator,
    given the ideal's generators. No monomial ideal machinery required.
  @param U generators of ideal we want to &ldquo;colonize&rdquo;
  @param t Monomial that is &ldquo;colonizing&rdquo; the ideal generated by @p U
  @return a list of generators of the colon ideal of @p U by @p t
    (@f$ U:(t) @f$)
*/
list<Monomial> colon_ideal_without_ideals(
    const list<Monomial> & U, const Monomial & t
);

/**
  @ingroup polygroup
  @class Monomial_Ideal
  @author John Perry
  @date 2016
  @brief A class for monomial ideals.

  @details Mostly a convenience class to encapsulate basic operations.
  I am in the process of moving some functions outside this class into it.
*/

class Monomial_Ideal {
public:
  /** @name Construction */
  ///@{
  /**
    @brief Creates a zero ideal
  */
  explicit Monomial_Ideal(NVAR_TYPE nvars) {
    n = nvars; hPol = nullptr;
    hNum = hRedNum = hGradNum = hGradRedNum = nullptr;
    current_grading = nullptr;
  }
  /**
    @brief Copies @c basis. If you supply a Hilbert function that is not computed
      according to the standard grading, please supply the grading as
      @p h_grading .
  */
  Monomial_Ideal(
      NVAR_TYPE nvars, const list<Monomial> & G,
      const Dense_Univariate_Integer_Polynomial * h_old = nullptr,
      const WT_TYPE * h_grading = nullptr
  ) : gens(G) {
    n = nvars;
    for (const Monomial & g : G) {
      if (g.num_vars() != n)
        throw new Monomial_Ideal_Variables_Exception();
      gens_vector.push_back(g);
    }
    hPol = nullptr;
    if (h_grading == nullptr) {
      hNum = (h_old == nullptr) ? nullptr
          : new Dense_Univariate_Integer_Polynomial(*h_old);
      hRedNum = hGradNum = hGradRedNum = nullptr;
    } else {
      hGradNum = (h_old == nullptr) ? nullptr
          : new Dense_Univariate_Integer_Polynomial(*h_old);
      hNum = hRedNum = hGradRedNum = nullptr;
    }
    current_grading = h_grading;
  }
  /**
    @brief Copies @c basis. If you supply a Hilbert function that is not computed
      according to the standard grading, please supply the grading as
      @p h_grading .
  */
  Monomial_Ideal(
        NVAR_TYPE nvars, const vector<Monomial> & G,
        const Dense_Univariate_Integer_Polynomial * h_old = nullptr,
        const WT_TYPE * h_grading = nullptr
  ) : gens_vector(G) {
    n = nvars;
    for (auto & g : G)
      gens.push_back(g);
    hPol = nullptr;
    if (h_grading == nullptr) {
      hNum = (h_old == nullptr) ? nullptr
          : new Dense_Univariate_Integer_Polynomial(*h_old);
      hRedNum = hGradNum = hGradRedNum = nullptr;
    } else {
      hGradNum = (h_old == nullptr) ? nullptr
          : new Dense_Univariate_Integer_Polynomial(*h_old);
      hNum = hRedNum = hGradRedNum = nullptr;
    }
    current_grading = h_grading;
  }
  /** @brief copy constructor */
  explicit Monomial_Ideal(const Monomial_Ideal & I) 
  : n(I.n), gens(I.gens), gens_vector(I.gens_vector)
  {
    hNum = (I.hNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hNum));
    hRedNum = (I.hRedNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hRedNum));
    hGradNum = (I.hGradNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hGradNum));
    hGradRedNum = (I.hGradRedNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hGradRedNum));
    hPol = (I.hPol == nullptr) ? nullptr
        : new Dense_Univariate_Rational_Polynomial(*(I.hPol));
    current_grading = I.current_grading;
  }
  ///@}
  /** @name Destruction */
  ///@{
  /**
    @brief destroys the Hilbert data, but not the grading.
  */
  ~Monomial_Ideal() {
    if (hPol != nullptr) delete hPol;
    if (hNum != nullptr) delete hNum;
    if (hRedNum != nullptr) delete hRedNum;
    if (hGradNum != nullptr) delete hGradNum;
    if (hGradRedNum != nullptr) delete hGradRedNum;
  }
  ///@}
  /** \name Basic properties
    The following functions give information about the ideal,
    but do not modify it.
  */
  ///@{
  /** @brief number of variables in each @c Monomial */
  NVAR_TYPE number_of_variables() const { return n; }
  /** @brief number of generators */
  unsigned size() const { return gens.size(); }
  /** @brief returns the list of generators */
  const list<Monomial> & generators() const { return gens; }
  /** @brief returns the vector of generators */
  const vector<Monomial> & generators_vector() const { return gens_vector; }
  /**
    @brief returns the dimension of the ideal
  */
  unsigned dimension() {
    return ideal_dimension(
        number_of_variables(), hilbert_numerator(), reduced_hilbert_numerator()
    );
  }
  /**
    @brief incremental Betti numbers when adding the last Monomial in this ideal
  */
  const map<DEG_TYPE, unsigned long> & inc_betti(
      const WT_TYPE * grading = nullptr
  ) {
    if (grading == nullptr) {
      if (current_grading == nullptr and ibmap.size() > 0) {
        // nothing to do
      }
      else {
        ibmap = full_betti(gens, grading);
        current_grading = nullptr;
      }
    } else {
      if (current_grading == grading and ibmap.size() > 0) {
        // nothing to do
      } else{
        ibmap = full_betti(gens, grading);
        current_grading = grading;
      }
    }
    return ibmap;
  }
  /**
    @return the (un-reduced) Hilbert numerator
    @param grading grading to use for computing this;
        use @c nullptr for standard, which is the default
    @warning Destroys the old Hilbert numerator
      if it was assigned a different grading.
      The comparison is by pointer only, not by values.
  */
  Dense_Univariate_Integer_Polynomial * hilbert_numerator(
    const WT_TYPE * grading = nullptr
  ) {
    Dense_Univariate_Integer_Polynomial * result;
    if (grading == nullptr) {
      if (hNum == nullptr)
        hNum = hilbert_numerator_bigatti(gens);
      else if (grading != current_grading) {
        delete hNum;
        hNum = hilbert_numerator_bigatti(gens);
      }
      result = hNum;
    } else {
      if (hGradNum == nullptr or grading != current_grading) {
        if (grading != current_grading)
          delete hGradNum;
        hGradNum = hilbert_numerator_bigatti(gens, grading);
        current_grading = grading;
      }
      result = hGradNum;
    }
    //cout << "Hilbert numerator requested: " << *result << endl;
    return result;
  }
  /**
    @brief the reduced Hilbert Numerator
    @param grading grading to use for computing this;
        use @c nullptr for standard, which is the default
    @return the reduced Hilbert numberator of this ideal, which is computed by
        canceling common factors with the denominator
    @see hilbert_second_numerator()
  */
  Dense_Univariate_Integer_Polynomial * reduced_hilbert_numerator(
    const WT_TYPE * grading = nullptr
  ) {
    Dense_Univariate_Integer_Polynomial * result;
    if (grading == nullptr) {
      if (hRedNum == nullptr)
        hRedNum = hilbert_second_numerator(
            number_of_variables(), hilbert_numerator()
        );
      result = hRedNum;
    } else {
      if (hGradRedNum == nullptr or grading != current_grading) {
        if (grading != current_grading)
          delete hGradRedNum;
        hGradRedNum = hilbert_second_numerator(
            number_of_variables(), hilbert_numerator(grading)
        );
        current_grading = grading;
      }
      result = hGradRedNum; 
    }
    //cout << "Hilbert reduced numerator requested: " << *result << endl;
    return result;
  }
  /**
    @return the Hilbert Polynomial for this ideal
    @details A &ldquo;Hilbert Polynomial&rdquo; does not exist in the
      non-standard graded case, so there is no option to supply a grading here,
      and if the Hilbert numerators have been computed for a different grading,
      this function re-computes them for the standard grading, without however
      losing the ones computed for the non-standard grading.
  */
  Dense_Univariate_Rational_Polynomial * hilbert_poly() {
    if (hPol == nullptr) {
      hPol = hilbert_polynomial(
               number_of_variables(),
               ideal_dimension(
                  number_of_variables(),
                  hilbert_numerator(), reduced_hilbert_numerator()
               ),
               gens,
               hilbert_numerator(),
               reduced_hilbert_numerator()
             );
    }
    /*cout << "Ideal of ";
    for (auto t : gens) cout << t << ", ";
    cout << endl;
    cout << "Hilbert polynomial: " << *hPol << endl;*/
    return hPol;
  }
  ///@}
  /** @name Computation */
  ///@{
  /**
    @brief returns the ideal @f$J=\{u:t \forall u\in I\}@f$,
      where @f$I@f$ is @c this
    @param t Monomial used to form the colon ideal
    @return the colon ideal
    @details This does not recompute Hilbert data even if already known.
      It is probably better to do that explicitly, anyhow.
  */
  Monomial_Ideal * colon(const Monomial & t) const {
    return new Monomial_Ideal(n, colon_ideal_without_ideals(gens, t));
  }
  /**
    @brief replaces the generators of @c this with those of the ideal
      @f$J=\{u:t \forall u\in I\}@f$, where @f$I@f$ is @c this
    @param t Monomial used to form the colon ideal
    @warning does not delete the old Hilbert numerator (as this could be a
      copy) so delete manually if you need that done
  */
  void colon_with(const Monomial & t) {
    if (t.num_vars() != n)
      throw new Monomial_Ideal_Variables_Exception();
    gens = colon_ideal_without_ideals(gens, t);
    hNum = hRedNum = nullptr;
    hPol = nullptr;
  }
  ///@}
  /** @name Modification */
  ///@{
  /** @brief assignment operator */
  Monomial_Ideal & operator = (const Monomial_Ideal &I) {
    n = I.n;
    gens = I.gens;
    hNum = (I.hNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hNum));
    hRedNum = (I.hRedNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hRedNum));
    hGradNum = (I.hGradNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hGradNum));
    hGradRedNum = (I.hGradRedNum == nullptr) ? nullptr
        : new Dense_Univariate_Integer_Polynomial(*(I.hGradRedNum));
    hPol = (I.hPol == nullptr) ? nullptr
        : new Dense_Univariate_Rational_Polynomial(*(I.hPol));
    current_grading = I.current_grading;
    return *this;
  }
  /** @brief adds @c t to the basis */
  void add_generator(const Monomial & t) {
    if (not (any_of(gens.begin(), gens.end(), [&t](auto & u){ return t.divisible_by(u); }))) {
      if (hNum != nullptr) {
        Monomial_Ideal J(t.num_vars(), colon_ideal_without_ideals(gens, t));
        Dense_Univariate_Integer_Polynomial * hn_new = J.hilbert_numerator();
        J.forget_hilbert_numerator();
        hn_new->multiply_by_monomial_of_degree(t.total_degree());
        hn_new->negate();
        hn_new->add(*hNum);
        delete hNum;
        hNum = hn_new;
        if (hRedNum != nullptr) delete hRedNum;
        if (hPol != nullptr) delete hPol;
      }
      gens.push_back(t);
      gens_vector.push_back(t);
    }
  }
  /** @brief removes the newest monomial from the basis */
  void remove_newest() { gens.pop_back(); gens_vector.pop_back(); }
  /** @brief sets numerator to @c nullptr */
  void forget_hilbert_numerator() { hNum = nullptr; }
  /** @brief sets numerator to given value; only use when you know this is true! */
  void set_hilbert_numerator(Dense_Univariate_Integer_Polynomial * h) {
    hNum = h;
  }
  ///@}
  /** @name I/O */
  ///@{
  friend ostream & operator << (ostream &, const Monomial_Ideal &);
  ///@}
protected:
  /** @brief number of variables the monomials of this ideal have */
  NVAR_TYPE n;
  /** @brief the ideal's generators */
  list<Monomial> gens;
  /** @brief the ideal's generators, as a vector */
  vector<Monomial> gens_vector;
  /** @brief the ideal's incremental Betti numbers */
  map<DEG_TYPE, unsigned long> ibmap;
  /** @brief the ideal's Hilbert numerator, standard grading */
  Dense_Univariate_Integer_Polynomial * hNum;
  /** @brief the ideal's Hilbert numerator, according to current_grading */
  Dense_Univariate_Integer_Polynomial * hGradNum;
  /** @brief the ideal's reduced Hilbert numerator, standard grading */
  Dense_Univariate_Integer_Polynomial * hRedNum;
  /**
    @brief the ideal's reduced Hilbert numerator, according to current_grading
  */
  Dense_Univariate_Integer_Polynomial * hGradRedNum;
  /** @brief the ideal's Hilbert polynomial -- standard grading only */
  Dense_Univariate_Rational_Polynomial * hPol;
  /**
    @brief the most recent grading for the Hilbert functions; @c nullptr implies
      standard grading
  */
  const WT_TYPE * current_grading;
};

#endif

\begin{DoxyRefList}
\item[\label{todo__todo000001}%
\Hypertarget{todo__todo000001}%
page \hyperlink{index}{Dyn\+GB\+: Dynamic Gr\"{o}bner basis project files} ]These are the highest priority items\+: things I think are needed before I'd call it ``ready.''
\begin{DoxyItemize}
\item Organize files into directories.
\item General improvements to efficiency based on profiling. (ongoing)
\item Implement simplex solver as oracle for D\+DM, compare with D\+DM (idea due to D. Lichtblau).
\item Optimize length() in \hyperlink{group__polygroup_class_polynomial___linked___list}{Polynomial\+\_\+\+Linked\+\_\+\+List}.
\item Add Fukuda and Prodon's cdd as an \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver}. \cite{Fukuda_DoubleDescriptionRevisited}
\item Bring polynomial iterators in line with C++ convention.
\item Implement other C++11 modernizations ({\ttfamily auto}, {\ttfamily noexcept}, {\ttfamily override}, {$\dots$}).
\item Generalize/improve the memory manager.
\item Add P\+PL as an \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver}. \cite{BagnaraHZ08SCP}
\item Implement Caboara's examples.
\item Implement graded Hilbert numerators.
\item Implement or link to a simplex solver, compare with D\+DM.
\item Determine what\textquotesingle{}s wrong with the $4\times4$ system. (Turns out nothing was wrong\+: the system is simply not amenable to polyhedra.)
\item Implement a global analysis at the beginning of the algorithm.
\item Implement Hilbert polynomials using multiple-\/precision arithmetic. (Denominators get too large for {\ttfamily long long}!!!)
\end{DoxyItemize}

These items would be nice, but aren't a big deal for me at present.
\begin{DoxyItemize}
\item Improve rings and fields\+:
\begin{DoxyItemize}
\item Create a general {\ttfamily Ring} class.
\begin{DoxyItemize}
\item Build polynomial rings off rings, not off fields. This could be difficult, since we typically want polynomials to have invertible coefficients. It doesn't seem strictly necessary, though\+: S-\/polynomials and top-\/reductions, for instance, can be computed by multiplying by the leading coefficient of the other polynomial, rather than by dividing by one's own coefficient.
\item Implement \hyperlink{group__polygroup_class_dense___univariate___integer___polynomial}{Dense\+\_\+\+Univariate\+\_\+\+Integer\+\_\+\+Polynomial} as a proper {\ttfamily Polynomial} representation.
\item Create a general {\ttfamily Euclidean\+\_\+\+Ring} class. Add to it the \hyperlink{group__utils_gaefe33f79de88accbc6f455e91dab9288}{divide\+\_\+by\+\_\+common\+\_\+term()} function.
\end{DoxyItemize}
\item Create a general {\ttfamily Field} class.
\begin{DoxyItemize}
\item Subclass \hyperlink{group___fields_group_class_prime___field}{Prime\+\_\+\+Field} to be {\ttfamily Field}.
\item Implement \hyperlink{group__polygroup_class_dense___univariate___rational___polynomial}{Dense\+\_\+\+Univariate\+\_\+\+Rational\+\_\+\+Polynomial} as a proper {\ttfamily Polynomial} representation.
\item Implement $\mathbb Q$ as a field.
\end{DoxyItemize}
\end{DoxyItemize}
\item Reimplement \hyperlink{group__polygroup_class_double___buffered___polynomial}{Double\+\_\+\+Buffered\+\_\+\+Polynomial} so its arrays contain pointers to \hyperlink{group__polygroup_class_monomial}{Monomial}, rather than an expanded \hyperlink{group__polygroup_class_monomial}{Monomial}. See if that changes things.
\item Re-\/examine what's going on with masks, since the plus to efficiency doesn't seem worth the effort.
\item Implement marked polynomials with a dynamic algorithm that works practically in the grevlex order, with the marked term being the true leading monomial. This may be very inefficient to reduce.
\item Implement a {\ttfamily Dictionary\+\_\+\+Linked\+\_\+\+Polynomial} class, where any term points to one unique instance of a monomial, rather than having many copies of monomials in different polynomials. Upside is that equality test during canonicalization is instantaneous (compare pointers). Downsides may include finding/sorting the monomials, indirection.
\item Detach monomial ordering from monomials, since caching ordering data doesn't seem to help much?
\item Implement a {\ttfamily Polynomial\+\_\+\+Builder} class to help build polynomials more easily by reading from an input file. That way we don't have to write a fresh control program for each example system. (see \hyperlink{group__utils_ga72d205e8226d578b892515edc527cc83}{user\+\_\+interface()})
\item Implement an \hyperlink{group__polygroup_class_indeterminate}{Indeterminate} class and a {\ttfamily Polynomial\+\_\+\+Builder} class to help build polynomials more easily.
\end{DoxyItemize}

I'm not sure these are worth doing.
\begin{DoxyItemize}
\item Most skeleton code seems to have little overhead, so most ``improvements'' related to that falls here\+:
\begin{DoxyItemize}
\item Implement D\+DM with the Fukuda-\/\+Prodon criterion, compare to Zolotykh's.
\item Implement Roune's algorithms for Hilbert functions.
\item Compare each potential PP with all other potential PP's, reducing the number of false positives. \mbox{[}This does not seem to be necessary at the moment, as the overhead is quite small, but it is still a thought.\mbox{]}
\item Add a hash mechanism to the {\ttfamily constraint} class to help avoid redundnacy.
\end{DoxyItemize}
\item Create a Matrix\+\_\+\+Ordering\+\_\+\+Data class as a subset of \hyperlink{group__orderinggroup_class_monomial___order___data}{Monomial\+\_\+\+Order\+\_\+\+Data}.
\item Add an {\ttfamily insert()} function to \hyperlink{group__polygroup_class_monomial___node}{Monomial\+\_\+\+Node} to insert another \hyperlink{group__polygroup_class_polynomial___linked___list}{Polynomial\+\_\+\+Linked\+\_\+\+List}, subsequently to be destroyed.
\item Think about computing all inverses of a small prime field immediately at startup.
\item Test matrix orderings more thoroughly.
\end{DoxyItemize}
\end{DoxyRefList}
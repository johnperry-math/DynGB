\hypertarget{group___c_l_s_solvers}{}\section{Constrained Linear System Solvers}
\label{group___c_l_s_solvers}\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}}


classes that solve constrained linear systems  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{group___c_l_s_solvers_classconstraint}{constraint}
\begin{DoxyCompactList}\small\item\em a constraint $ c_1 x_1 + \ldots + c_n x_n \geq 0 $  \hyperlink{group___c_l_s_solvers_classconstraint}{More...}\end{DoxyCompactList}\item 
class \hyperlink{group___c_l_s_solvers_classedge}{edge}
\begin{DoxyCompactList}\small\item\em an edge $(r_1,r_2)$ connecting the two rays $ r_1 $ and $ r_2 $  \hyperlink{group___c_l_s_solvers_classedge}{More...}\end{DoxyCompactList}\item 
class \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}
\begin{DoxyCompactList}\small\item\em approximate skeleton of a polyhedral cone, using G\+L\+PK linear solver  \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{More...}\end{DoxyCompactList}\item 
class \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver}
\begin{DoxyCompactList}\small\item\em exact or approximate polyhedral cone solution, with methods allowing definition and refinement  \hyperlink{group___c_l_s_solvers_class_l_p___solver}{More...}\end{DoxyCompactList}\item 
class \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver}
\begin{DoxyCompactList}\small\item\em approximate skeleton of a polyhedral cone, using P\+PL linear solver  \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{More...}\end{DoxyCompactList}\item 
class \hyperlink{group___c_l_s_solvers_classray}{ray}
\begin{DoxyCompactList}\small\item\em a ray defined by nonnegative coordinates $(a_1,\ldots,a_n)$  \hyperlink{group___c_l_s_solvers_classray}{More...}\end{DoxyCompactList}\item 
class \hyperlink{group___c_l_s_solvers_classskeleton}{skeleton}
\begin{DoxyCompactList}\small\item\em skeleton of a polyhedral cone, with methods allowing definition and refinement  \hyperlink{group___c_l_s_solvers_classskeleton}{More...}\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
vector$<$ bool $>$ \hyperlink{group___c_l_s_solvers_gacb5ce7e22db91b33c26ea0be6a6026de}{intersections\+\_\+of\+\_\+active\+\_\+constraints} (bool $\ast$, bool $\ast$, unsigned)
\item 
bool \hyperlink{group___c_l_s_solvers_ga06bebd50facdc36f850371e545f82174}{is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second} (bool $\ast$, bool $\ast$, unsigned)
\item 
int \hyperlink{group___c_l_s_solvers_ga33829eddeaa7be000404e4d281d90973}{number\+\_\+of\+\_\+common\+\_\+constraints} (bool $\ast$, bool $\ast$, unsigned)
\item 
\hyperlink{group___c_l_s_solvers_classray}{ray} \hyperlink{group___c_l_s_solvers_gae039f9fb46b8c57063342f6203add523}{operator$\ast$} (R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE, \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Multiply every coordinate in the given ray by the given scalar. \end{DoxyCompactList}\item 
R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_ga30af4b27086e461f862e7d16e9d209df}{operator$\ast$} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Compute the dot product on the rays. \end{DoxyCompactList}\item 
D\+O\+T\+P\+R\+O\+D\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_gac22c25c0110c6684317aaf0e50c2e9a0}{operator$\ast$} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&r, const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&c)
\begin{DoxyCompactList}\small\item\em Compute the dot product between the ray and the constraint. \end{DoxyCompactList}\item 
D\+O\+T\+P\+R\+O\+D\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_ga240d91c518c3bfe3817504de43039022}{operator$\ast$} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&c, \hyperlink{group___c_l_s_solvers_classray}{ray} \&r)
\begin{DoxyCompactList}\small\item\em Compute the dot product between the ray and the constraint. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_classray}{ray} \hyperlink{group___c_l_s_solvers_gaaa48bb668551858c8d53e230546042ba}{operator+} (\hyperlink{group___c_l_s_solvers_classray}{ray} \&, \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Add the two rays. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_classray}{ray} \hyperlink{group___c_l_s_solvers_gafcb092cfc55771c4303f540cb7697a40}{operator-\/} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Subtract the two rays. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_classray}{ray} \hyperlink{group___c_l_s_solvers_gafb95c2b09dc0a5ea693a99cb8340ff28}{ray\+\_\+sum} (const set$<$ \hyperlink{group___c_l_s_solvers_classray}{ray} $>$ \&)
\begin{DoxyCompactList}\small\item\em Add all the rays in a set. \end{DoxyCompactList}\item 
set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \hyperlink{group___c_l_s_solvers_ga2b6dbec1643b53f8e613b0a3de07f3ce}{union\+\_\+of\+\_\+edge\+\_\+sets} (const set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \&, const set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \&)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
classes that solve constrained linear systems 

Classes in this group solve constrained linear systems; that is, they solve systems of the form $\left\{\sum_{j=1}^na_{ij}x_j\leq b_i\right\}_{i=1}^m$ (where the inequality may or may not be strict). 

\subsection{Class Documentation}
\index{constraint@{constraint}}\label{classconstraint}
\Hypertarget{group___c_l_s_solvers_classconstraint}
\subsubsection{class constraint}
a constraint $ c_1 x_1 + \ldots + c_n x_n \geq 0 $ 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
October 2014 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class encapsulates a simple constraint for a skeleton; that is, an inequality of the form $ c_1 x_1 + \ldots + c_n x_n \geq 0 $. Constraints can be ordered lexicographically using the less-\/than operator, allowing for their inclusion in ordered collections, such as sets. 

Definition at line 53 of file lp\+\_\+solver.\+hpp.

\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{group___c_l_s_solvers_aac499533508fc7e6fcdfad614dbecc48}{constraint} (N\+V\+A\+R\+\_\+\+T\+Y\+PE, C\+O\+N\+S\+T\+R\+\_\+\+T\+Y\+PE \mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Initialize constraint to the given coefficients. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_abcf2ec568e0dcfd37c2dc150b738ad2d}{constraint} (vector$<$ C\+O\+N\+S\+T\+R\+\_\+\+T\+Y\+PE $>$ \&)
\begin{DoxyCompactList}\small\item\em Initialize constraint to the given coefficients. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a796ee0ed5407fb1e4a4774156f0faac9}\label{group___c_l_s_solvers_a796ee0ed5407fb1e4a4774156f0faac9}} 
\hyperlink{group___c_l_s_solvers_a796ee0ed5407fb1e4a4774156f0faac9}{constraint} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&)
\begin{DoxyCompactList}\small\item\em Copies the coefficients of the other constraint, including the allocation of new memory. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{group___c_l_s_solvers_a02e58b1ce0b271e3daac2da841152582}{$\sim$constraint} ()
\begin{DoxyCompactList}\small\item\em Deletes memory allocated by the constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Friends}
\begin{Indent}\textbf{ I/O}\par
\begin{DoxyCompactItemize}
\item 
ostream \& \hyperlink{group___c_l_s_solvers_a829b1dbba361c34d021ebe82ccf5cb7f}{operator$<$$<$} (ostream \&, const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&)
\begin{DoxyCompactList}\small\item\em print a representation of the constraint to the stream \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Basic properties}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a62f9d6527236b92bce67ef3251ba1fae}\label{group___c_l_s_solvers_a62f9d6527236b92bce67ef3251ba1fae}} 
N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_a62f9d6527236b92bce67ef3251ba1fae}{get\+\_\+number\+\_\+of\+\_\+variables} () const
\begin{DoxyCompactList}\small\item\em Returns the number of variables in the constraint. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aab075ba7c8fa216eff36aeee8fc5552e}\label{group___c_l_s_solvers_aab075ba7c8fa216eff36aeee8fc5552e}} 
C\+O\+N\+S\+T\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_aab075ba7c8fa216eff36aeee8fc5552e}{operator\mbox{[}$\,$\mbox{]}} (N\+V\+A\+R\+\_\+\+T\+Y\+PE index) const
\begin{DoxyCompactList}\small\item\em Returns the coefficient indicated. Numbering starts at 0. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_ac70165b34389dbe7e58d757e1f16bd8d}\label{group___c_l_s_solvers_ac70165b34389dbe7e58d757e1f16bd8d}} 
const C\+O\+N\+S\+T\+R\+\_\+\+T\+Y\+PE $\ast$ \hyperlink{group___c_l_s_solvers_ac70165b34389dbe7e58d757e1f16bd8d}{coeffs} () const
\begin{DoxyCompactList}\small\item\em Returns the coefficients that determine this constraints. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_aecc988c4f28198ecc105f60eddfbfddc}{operator$<$} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&a, const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&b)
\begin{DoxyCompactList}\small\item\em Lexicographic comparison of constraints. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_acb6f7858d12f0c03f1c8be86ecbef902}{operator==} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&a, const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&b)
\begin{DoxyCompactList}\small\item\em check for constraint equality \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a6b57d19474acdea10ab0a0e954ef3ef9}{operator!=} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&a, const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&b)
\begin{DoxyCompactList}\small\item\em check for constraint inequality \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a75ee7037f652ba94155890c109b88ef8}{operator!=} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&a, \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&b)
\begin{DoxyCompactList}\small\item\em check for constraint inequality \end{DoxyCompactList}\end{DoxyCompactItemize}


\paragraph{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_aac499533508fc7e6fcdfad614dbecc48}\label{group___c_l_s_solvers_aac499533508fc7e6fcdfad614dbecc48}} 
\index{constraint@{constraint}!constraint@{constraint}}
\index{constraint@{constraint}!constraint@{constraint}}
\subparagraph{\texorpdfstring{constraint()}{constraint()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily constraint\+::constraint (\begin{DoxyParamCaption}\item[{N\+V\+A\+R\+\_\+\+T\+Y\+PE}]{num\+\_\+variables,  }\item[{C\+O\+N\+S\+T\+R\+\_\+\+T\+Y\+PE}]{coeffs\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}



Initialize constraint to the given coefficients. 

The resulting constraint is $ c_1x_1 + \cdots + c_nx_n \geq 0, $ where $ c_i $ is the coefficient of $ x_i $. 
\begin{DoxyParams}{Parameters}
{\em num\+\_\+variables} & length of coeffs \\
\hline
{\em coeffs} & copies this array of coefficients \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
the size of the array needs to be at least as long as the dimension! 
\end{DoxyPrecond}


Definition at line 23 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_abcf2ec568e0dcfd37c2dc150b738ad2d}\label{group___c_l_s_solvers_abcf2ec568e0dcfd37c2dc150b738ad2d}} 
\index{constraint@{constraint}!constraint@{constraint}}
\index{constraint@{constraint}!constraint@{constraint}}
\subparagraph{\texorpdfstring{constraint()}{constraint()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily constraint\+::constraint (\begin{DoxyParamCaption}\item[{vector$<$ C\+O\+N\+S\+T\+R\+\_\+\+T\+Y\+PE $>$ \&}]{coeffs }\end{DoxyParamCaption})}



Initialize constraint to the given coefficients. 

The resulting constraint is $ c_1x_1 + \cdots + c_nx_n \geq 0, $ where $ c_i $ is the coefficient of $ x_i $. 
\begin{DoxyParams}{Parameters}
{\em coeffs} & copies thiis vector of coefficients \\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{Postcondition}
{\ttfamily nvars} will have the value equal to {\ttfamily coeffs.\+size()} 
\end{DoxyPostcond}


Definition at line 31 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a02e58b1ce0b271e3daac2da841152582}\label{group___c_l_s_solvers_a02e58b1ce0b271e3daac2da841152582}} 
\index{constraint@{constraint}!````~constraint@{$\sim$constraint}}
\index{````~constraint@{$\sim$constraint}!constraint@{constraint}}
\subparagraph{\texorpdfstring{$\sim$constraint()}{~constraint()}}
{\footnotesize\ttfamily constraint\+::$\sim$constraint (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Deletes memory allocated by the constructor. 

Currently, that means it deletes an array created by the constructors. 

Definition at line 111 of file lp\+\_\+solver.\+cpp.



\paragraph{Friends And Related Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a6b57d19474acdea10ab0a0e954ef3ef9}\label{group___c_l_s_solvers_a6b57d19474acdea10ab0a0e954ef3ef9}} 
\index{constraint@{constraint}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!constraint@{constraint}}
\subparagraph{\texorpdfstring{operator"!=}{operator!=}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool operator!= (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{a,  }\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



check for constraint inequality 


\begin{DoxyParams}{Parameters}
{\em a} & a constraint \\
\hline
{\em b} & a constraint \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}
\mbox{\Hypertarget{group___c_l_s_solvers_a75ee7037f652ba94155890c109b88ef8}\label{group___c_l_s_solvers_a75ee7037f652ba94155890c109b88ef8}} 
\index{constraint@{constraint}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!constraint@{constraint}}
\subparagraph{\texorpdfstring{operator"!=}{operator!=}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool operator!= (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{a,  }\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



check for constraint inequality 


\begin{DoxyParams}{Parameters}
{\em a} & a constraint \\
\hline
{\em b} & a constraint \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 71 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_aecc988c4f28198ecc105f60eddfbfddc}\label{group___c_l_s_solvers_aecc988c4f28198ecc105f60eddfbfddc}} 
\index{constraint@{constraint}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!constraint@{constraint}}
\subparagraph{\texorpdfstring{operator$<$}{operator<}}
{\footnotesize\ttfamily bool operator$<$ (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{a,  }\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Lexicographic comparison of constraints. 


\begin{DoxyParams}{Parameters}
{\em a} & a constraint \\
\hline
{\em b} & a constraint \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 48 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a829b1dbba361c34d021ebe82ccf5cb7f}\label{group___c_l_s_solvers_a829b1dbba361c34d021ebe82ccf5cb7f}} 
\index{constraint@{constraint}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!constraint@{constraint}}
\subparagraph{\texorpdfstring{operator$<$$<$}{operator<<}}
{\footnotesize\ttfamily ostream\& operator$<$$<$ (\begin{DoxyParamCaption}\item[{ostream \&}]{ostr,  }\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



print a representation of the constraint to the stream 

Output is of the form $ c_1 x_1 + \ldots + c_n x_n $ , where $ c_i $ is the coefficient of $ x_i $. 

Definition at line 81 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_acb6f7858d12f0c03f1c8be86ecbef902}\label{group___c_l_s_solvers_acb6f7858d12f0c03f1c8be86ecbef902}} 
\index{constraint@{constraint}!operator==@{operator==}}
\index{operator==@{operator==}!constraint@{constraint}}
\subparagraph{\texorpdfstring{operator==}{operator==}}
{\footnotesize\ttfamily bool operator== (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{a,  }\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



check for constraint equality 


\begin{DoxyParams}{Parameters}
{\em a} & a constraint \\
\hline
{\em b} & a constraint \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 61 of file lp\+\_\+solver.\+cpp.

\index{edge@{edge}}\label{classedge}
\Hypertarget{group___c_l_s_solvers_classedge}
\subsubsection{class edge}
an edge $(r_1,r_2)$ connecting the two rays $ r_1 $ and $ r_2 $ 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
October 2014 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class encapsulates an edge, the other major part of a skeleton. Edges describe how the rays of the skeleton are connected. Edges are ordered, so that the smaller ray always comes first.

\begin{DoxyWarning}{Warning}
An edge\textquotesingle{}s rays should have the same dimension. To start with, it doesn\textquotesingle{}t make mathematical sense to ``join'' two rays of different dimension. Moreover, comparison of edges requires comparison of rays,which requires that the rays have the same dimension. (But you wouldn\textquotesingle{}t be dumb enough to do this in the first place.) 
\end{DoxyWarning}


Definition at line 58 of file skeleton.\+hpp.

\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a80e74eefbaf1864ae1297fe2cea223ad}\label{group___c_l_s_solvers_a80e74eefbaf1864ae1297fe2cea223ad}} 
\hyperlink{group___c_l_s_solvers_a80e74eefbaf1864ae1297fe2cea223ad}{edge} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Creates a new edge that joins the two rays. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a93cf571922e2c7609ddeccaa24df1b59}\label{group___c_l_s_solvers_a93cf571922e2c7609ddeccaa24df1b59}} 
\hyperlink{group___c_l_s_solvers_a93cf571922e2c7609ddeccaa24df1b59}{edge} (const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&)
\begin{DoxyCompactList}\small\item\em Copies the rays in {\ttfamily other} to two new rays. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{group___c_l_s_solvers_a6295b7f8e62fa95cd887fb78d64347f5}{$\sim$edge} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properties}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a7c35e5555bd71f1e9f6231216b8c882e}\label{group___c_l_s_solvers_a7c35e5555bd71f1e9f6231216b8c882e}} 
\hyperlink{group___c_l_s_solvers_classray}{ray} \hyperlink{group___c_l_s_solvers_a7c35e5555bd71f1e9f6231216b8c882e}{get\+\_\+first\+\_\+ray} () const
\begin{DoxyCompactList}\small\item\em Returns the first ray listed in this edge. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a2baca8d9ca7f40edfb9364df3ec4c4a8}\label{group___c_l_s_solvers_a2baca8d9ca7f40edfb9364df3ec4c4a8}} 
\hyperlink{group___c_l_s_solvers_classray}{ray} \hyperlink{group___c_l_s_solvers_a2baca8d9ca7f40edfb9364df3ec4c4a8}{get\+\_\+second\+\_\+ray} () const
\begin{DoxyCompactList}\small\item\em Returns the second ray listed in this edge. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_acd5e308a604773f2d414732b6a873032}\label{group___c_l_s_solvers_acd5e308a604773f2d414732b6a873032}} 
\hyperlink{group___c_l_s_solvers_classedge}{edge} \& \hyperlink{group___c_l_s_solvers_acd5e308a604773f2d414732b6a873032}{operator=} (const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Friends}
\begin{Indent}\textbf{ Comparison}\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{group___c_l_s_solvers_a87086330455166d1fe4bb71be060fbcc}{operator==} (const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&e1, const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&e2)
\begin{DoxyCompactList}\small\item\em Equal if and only if. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a983f5438e6720d3bc1d7763c0c04fcae}{operator$<$} (const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&, const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&)
\begin{DoxyCompactList}\small\item\em Compares two edges lexicographically. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ I/O}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aad6bb96213a9839cb6b32592a4105f53}\label{group___c_l_s_solvers_aad6bb96213a9839cb6b32592a4105f53}} 
ostream \& \hyperlink{group___c_l_s_solvers_aad6bb96213a9839cb6b32592a4105f53}{operator$<$$<$} (ostream \&, const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&)
\begin{DoxyCompactList}\small\item\em Output has the form $ \{ \mathbf{r}_1, \mathbf{r}_2 \} $ where $ \mathbf{r}_1 $ is the first ray in this edge, etc. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}


\paragraph{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a6295b7f8e62fa95cd887fb78d64347f5}\label{group___c_l_s_solvers_a6295b7f8e62fa95cd887fb78d64347f5}} 
\index{edge@{edge}!````~edge@{$\sim$edge}}
\index{````~edge@{$\sim$edge}!edge@{edge}}
\subparagraph{\texorpdfstring{$\sim$edge()}{~edge()}}
{\footnotesize\ttfamily edge\+::$\sim$edge (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Does nothing beyond what the compiler would do. 

Definition at line 76 of file skeleton.\+hpp.



\paragraph{Friends And Related Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a983f5438e6720d3bc1d7763c0c04fcae}\label{group___c_l_s_solvers_a983f5438e6720d3bc1d7763c0c04fcae}} 
\index{edge@{edge}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!edge@{edge}}
\subparagraph{\texorpdfstring{operator$<$}{operator<}}
{\footnotesize\ttfamily bool operator$<$ (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&}]{first,  }\item[{const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&}]{second }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Compares two edges lexicographically. 

If the first ray in {\ttfamily this} edge is smaller, then {\ttfamily this} edge is smaller. Otherwise, if the first rays are equal, and the second ray in {\ttfamily this} edge is smaller, then {\ttfamily this} edge is smaller. 

Definition at line 58 of file skeleton.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a87086330455166d1fe4bb71be060fbcc}\label{group___c_l_s_solvers_a87086330455166d1fe4bb71be060fbcc}} 
\index{edge@{edge}!operator==@{operator==}}
\index{operator==@{operator==}!edge@{edge}}
\subparagraph{\texorpdfstring{operator==}{operator==}}
{\footnotesize\ttfamily bool operator== (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&}]{e1,  }\item[{const \hyperlink{group___c_l_s_solvers_classedge}{edge} \&}]{e2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Equal if and only if. 


\begin{DoxyParams}{Parameters}
{\em e1} & an edge \\
\hline
{\em e2} & an edge \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the linked rays are identical 
\end{DoxyReturn}


Definition at line 100 of file skeleton.\+hpp.

\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}\label{class_g_l_p_k___solver}
\Hypertarget{group___c_l_s_solvers_class_g_l_p_k___solver}
\subsubsection{class G\+L\+P\+K\+\_\+\+Solver}
approximate skeleton of a polyhedral cone, using G\+L\+PK linear solver 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
January 2017 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class serves as an interface to G\+L\+PK \cite{glpk}, which we can use to find an approximate skeleton to a polyhedral cone. 

Definition at line 37 of file glpk\+\_\+solver.\+hpp.

Inheritance diagram for G\+L\+P\+K\+\_\+\+Solver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{group___c_l_s_solvers}
\end{center}
\end{figure}
\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a290ed6f0f6be3c6edf5ec5b5f5bfbb3a}\label{group___c_l_s_solvers_a290ed6f0f6be3c6edf5ec5b5f5bfbb3a}} 
\hyperlink{group___c_l_s_solvers_a290ed6f0f6be3c6edf5ec5b5f5bfbb3a}{G\+L\+P\+K\+\_\+\+Solver} (N\+V\+A\+R\+\_\+\+T\+Y\+PE n)
\begin{DoxyCompactList}\small\item\em initializes solver for $ n $ variables \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a6cbd7db2555c39cb789fa45a8ad22f8f}\label{group___c_l_s_solvers_a6cbd7db2555c39cb789fa45a8ad22f8f}} 
\hyperlink{group___c_l_s_solvers_a6cbd7db2555c39cb789fa45a8ad22f8f}{G\+L\+P\+K\+\_\+\+Solver} (const \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver} \&)
\begin{DoxyCompactList}\small\item\em copy constructor (deep copy) \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_aff3a58ef3def363dfad9e0ba8eee3e67}{copy} (const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$)
\begin{DoxyCompactList}\small\item\em performs a deep copy, similar to a copy constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a4a4505a58f6d0f93a1c003797b39e468}\label{group___c_l_s_solvers_a4a4505a58f6d0f93a1c003797b39e468}} 
virtual {\bfseries $\sim$\+G\+L\+P\+K\+\_\+\+Solver} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properties}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aa7ea7b9f4bb731fcb3b48991d33efe0a}\label{group___c_l_s_solvers_aa7ea7b9f4bb731fcb3b48991d33efe0a}} 
virtual N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_aa7ea7b9f4bb731fcb3b48991d33efe0a}{get\+\_\+dimension} () const
\begin{DoxyCompactList}\small\item\em Returns the dimension of the underlying vector space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_ae687af797043acd0e7621e75dd97b37a}\label{group___c_l_s_solvers_ae687af797043acd0e7621e75dd97b37a}} 
virtual unsigned long \hyperlink{group___c_l_s_solvers_ae687af797043acd0e7621e75dd97b37a}{get\+\_\+number\+\_\+of\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the number of rays defining the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_abd6239c7b6c914ba4c30e357d9fbc59c}\label{group___c_l_s_solvers_abd6239c7b6c914ba4c30e357d9fbc59c}} 
virtual const set$<$ \hyperlink{group___c_l_s_solvers_classray}{ray} $>$ \& \hyperlink{group___c_l_s_solvers_abd6239c7b6c914ba4c30e357d9fbc59c}{get\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the rays that define the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a714f9e1e02b53d1a785297e86567b133}\label{group___c_l_s_solvers_a714f9e1e02b53d1a785297e86567b133}} 
virtual unsigned long {\bfseries get\+\_\+number\+\_\+of\+\_\+constraints} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{group___c_l_s_solvers_acb3a10f3961c65b4cf23ff61f0e2310b}{solve} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraint (singular!) and re-\/computes the solution. \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_a6d800f0ec270c782e3cf855aa7f59f4c}{solve} (vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraints (plural!) and re-\/computes the solution. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Computation}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_ad79040934b5bf246b24aa36f30403dce}\label{group___c_l_s_solvers_ad79040934b5bf246b24aa36f30403dce}} 
virtual bool \hyperlink{group___c_l_s_solvers_ad79040934b5bf246b24aa36f30403dce}{makes\+\_\+consistent\+\_\+constraint} (const \hyperlink{group__polygroup_class_monomial}{Monomial} \&t, const \hyperlink{group__polygroup_class_monomial}{Monomial} \&u, bool show\+\_\+data=false)
\begin{DoxyCompactList}\small\item\em tests for consistency of a constraint generated by two monomials. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Additional Inherited Members}


\paragraph{Member Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_aff3a58ef3def363dfad9e0ba8eee3e67}\label{group___c_l_s_solvers_aff3a58ef3def363dfad9e0ba8eee3e67}} 
\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}!copy@{copy}}
\index{copy@{copy}!G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily bool G\+L\+P\+K\+\_\+\+Solver\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



performs a deep copy, similar to a copy constructor 

\begin{DoxyReturn}{Returns}
{\ttfamily true} iff copying was successful 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Do not mix-\/and-\/match solvers. At the present time, a \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} is not equipped to copy a \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, or vice versa. (This doesn\textquotesingle{}t even make sense between exact and approximate solvers.) 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_a442ad4ad67ee2feff0df49e9201d61ca}{L\+P\+\_\+\+Solver}.



Definition at line 58 of file glpk\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_acb3a10f3961c65b4cf23ff61f0e2310b}\label{group___c_l_s_solvers_acb3a10f3961c65b4cf23ff61f0e2310b}} 
\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool G\+L\+P\+K\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraint (singular!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraint is consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}{L\+P\+\_\+\+Solver}.



Definition at line 116 of file glpk\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a6d800f0ec270c782e3cf855aa7f59f4c}\label{group___c_l_s_solvers_a6d800f0ec270c782e3cf855aa7f59f4c}} 
\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool G\+L\+P\+K\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraints (plural!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraints are consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_a35da4bdf5db971c445f495b6eaab072d}{L\+P\+\_\+\+Solver}.



Definition at line 85 of file glpk\+\_\+solver.\+cpp.

\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}\label{class_l_p___solver}
\Hypertarget{group___c_l_s_solvers_class_l_p___solver}
\subsubsection{class L\+P\+\_\+\+Solver}
exact or approximate polyhedral cone solution, with methods allowing definition and refinement 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
January 2017 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class encapsulates the skeleton of a polyhedral cone, defined by a sequence of inequalities of the form $ c_1 x_1 + \cdots c_n x_n \geq 0 $.

\begin{DoxyWarning}{Warning}
Some classes may provide only an {\itshape approximate} cone; see, for example, \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}. In addition, Clients must ensure two things.
\begin{DoxyEnumerate}
\item The rays must have the same number $ m $ of dimensions, constraints must have the same number $ n $ of variables, and $ m=n $. Violating any of these three conditions will lead to undesirable behavior.
\item When refining the cone, it is essential to check that the return value of \hyperlink{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}{solve()} is {\ttfamily true}; for if it is not, then the cone is no longer be consistent. Please read the relevant documentation. 
\end{DoxyEnumerate}
\end{DoxyWarning}


Definition at line 504 of file lp\+\_\+solver.\+hpp.

Inheritance diagram for L\+P\+\_\+\+Solver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{group___c_l_s_solvers}
\end{center}
\end{figure}
\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{group___c_l_s_solvers_a442ad4ad67ee2feff0df49e9201d61ca}{copy} (const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$)=0
\begin{DoxyCompactList}\small\item\em performs a deep copy, similar to a copy constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a3cdeb4d133d147bae2c071bd41ed10aa}\label{group___c_l_s_solvers_a3cdeb4d133d147bae2c071bd41ed10aa}} 
virtual \hyperlink{group___c_l_s_solvers_a3cdeb4d133d147bae2c071bd41ed10aa}{$\sim$\+L\+P\+\_\+\+Solver} ()
\begin{DoxyCompactList}\small\item\em the default destructor does nothing (this is an abstract class) \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}{solve} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&)=0
\begin{DoxyCompactList}\small\item\em Adds the indicated constraint (singular!) and re-\/computes the solution. \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_a35da4bdf5db971c445f495b6eaab072d}{solve} (vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&)=0
\begin{DoxyCompactList}\small\item\em Adds the indicated constraints (plural!) and re-\/computes the solution. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properies}\par
{\em Returns rays that define a skeleton.

When using an approximate solver such as \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, this will give only an approximate skeleton. }\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_ae85c7e9a24774fd3c08a7dd9a7b8a27c}\label{group___c_l_s_solvers_ae85c7e9a24774fd3c08a7dd9a7b8a27c}} 
virtual N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_ae85c7e9a24774fd3c08a7dd9a7b8a27c}{get\+\_\+dimension} () const =0
\begin{DoxyCompactList}\small\item\em Returns the dimension of the underlying vector space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a4262d944695d0cfcddf9e24908f72e8f}\label{group___c_l_s_solvers_a4262d944695d0cfcddf9e24908f72e8f}} 
virtual unsigned long \hyperlink{group___c_l_s_solvers_a4262d944695d0cfcddf9e24908f72e8f}{get\+\_\+number\+\_\+of\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the number of rays defining the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a06363bbbc8dfdb4c161a001d24f94afd}\label{group___c_l_s_solvers_a06363bbbc8dfdb4c161a001d24f94afd}} 
virtual const set$<$ \hyperlink{group___c_l_s_solvers_classray}{ray} $>$ \& \hyperlink{group___c_l_s_solvers_a06363bbbc8dfdb4c161a001d24f94afd}{get\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the rays that define the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a0b587fd39cbefe969e4b3dbf34387b08}\label{group___c_l_s_solvers_a0b587fd39cbefe969e4b3dbf34387b08}} 
virtual unsigned long {\bfseries get\+\_\+number\+\_\+of\+\_\+constraints} ()=0
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Computation}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a2e909dd41a7f116c62868e3e6c278a2e}\label{group___c_l_s_solvers_a2e909dd41a7f116c62868e3e6c278a2e}} 
virtual bool \hyperlink{group___c_l_s_solvers_a2e909dd41a7f116c62868e3e6c278a2e}{makes\+\_\+consistent\+\_\+constraint} (const \hyperlink{group__polygroup_class_monomial}{Monomial} \&t, const \hyperlink{group__polygroup_class_monomial}{Monomial} \&u, bool show\+\_\+data=false)
\begin{DoxyCompactList}\small\item\em tests for consistency of a constraint generated by two monomials. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
set$<$ \hyperlink{group___c_l_s_solvers_classray}{ray} $>$ \hyperlink{group___c_l_s_solvers_aa89c9167eb3ef921b57d74057217f407}{rays}
\end{DoxyCompactItemize}


\paragraph{Member Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a442ad4ad67ee2feff0df49e9201d61ca}\label{group___c_l_s_solvers_a442ad4ad67ee2feff0df49e9201d61ca}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!copy@{copy}}
\index{copy@{copy}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily virtual bool L\+P\+\_\+\+Solver\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



performs a deep copy, similar to a copy constructor 

\begin{DoxyReturn}{Returns}
{\ttfamily true} iff copying was successful 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Do not mix-\/and-\/match solvers. At the present time, a \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} is not equipped to copy a \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, or vice versa. (This doesn\textquotesingle{}t even make sense between exact and approximate solvers.) 
\end{DoxyWarning}


Implemented in \hyperlink{group___c_l_s_solvers_a42d30b92f27936eab11d0fa4f0cc10b4}{skeleton}, \hyperlink{group___c_l_s_solvers_a67408174d2260de5ae5f070a70f27e9d}{P\+P\+L\+\_\+\+Solver}, and \hyperlink{group___c_l_s_solvers_aff3a58ef3def363dfad9e0ba8eee3e67}{G\+L\+P\+K\+\_\+\+Solver}.

\mbox{\Hypertarget{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}\label{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual bool L\+P\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds the indicated constraint (singular!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraint is consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implemented in \hyperlink{group___c_l_s_solvers_a8add1433d3bc6b1a8588f0f88134599f}{skeleton}, \hyperlink{group___c_l_s_solvers_acb3a10f3961c65b4cf23ff61f0e2310b}{G\+L\+P\+K\+\_\+\+Solver}, and \hyperlink{group___c_l_s_solvers_a1ff16def22c734348c626b65437dd1e3}{P\+P\+L\+\_\+\+Solver}.

\mbox{\Hypertarget{group___c_l_s_solvers_a35da4bdf5db971c445f495b6eaab072d}\label{group___c_l_s_solvers_a35da4bdf5db971c445f495b6eaab072d}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual bool L\+P\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds the indicated constraints (plural!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraints are consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implemented in \hyperlink{group___c_l_s_solvers_ac366952c2b0908159255916a1e37f9b3}{skeleton}, \hyperlink{group___c_l_s_solvers_a6d800f0ec270c782e3cf855aa7f59f4c}{G\+L\+P\+K\+\_\+\+Solver}, and \hyperlink{group___c_l_s_solvers_a5000b8c5bee37029276ce63a3568bfb7}{P\+P\+L\+\_\+\+Solver}.



\paragraph{Member Data Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_aa89c9167eb3ef921b57d74057217f407}\label{group___c_l_s_solvers_aa89c9167eb3ef921b57d74057217f407}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!rays@{rays}}
\index{rays@{rays}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{rays}{rays}}
{\footnotesize\ttfamily set$<$\hyperlink{group___c_l_s_solvers_classray}{ray}$>$ L\+P\+\_\+\+Solver\+::rays\hspace{0.3cm}{\ttfamily [protected]}}

the skeleton (may be approximate, depending on solver) 

Definition at line 602 of file lp\+\_\+solver.\+hpp.

\index{P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}}\label{class_p_p_l___solver}
\Hypertarget{group___c_l_s_solvers_class_p_p_l___solver}
\subsubsection{class P\+P\+L\+\_\+\+Solver}
approximate skeleton of a polyhedral cone, using P\+PL linear solver 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
January 2017 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class serves as an interface to P\+PL \cite{BagnaraHZ08SCP}, which we can use to find the skeleton to a polyhedral cone. 

Definition at line 38 of file ppl\+\_\+solver.\+hpp.

Inheritance diagram for P\+P\+L\+\_\+\+Solver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{group___c_l_s_solvers}
\end{center}
\end{figure}
\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a7484421e15572f77d014b2feb9d79f04}\label{group___c_l_s_solvers_a7484421e15572f77d014b2feb9d79f04}} 
\hyperlink{group___c_l_s_solvers_a7484421e15572f77d014b2feb9d79f04}{P\+P\+L\+\_\+\+Solver} (N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_aa70891def9af366c47e01acf952bbdba}{n})
\begin{DoxyCompactList}\small\item\em initializes solver for $ n $ variables \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a7aa1c2c02e059f35f9d9faca9e94f859}\label{group___c_l_s_solvers_a7aa1c2c02e059f35f9d9faca9e94f859}} 
\hyperlink{group___c_l_s_solvers_a7aa1c2c02e059f35f9d9faca9e94f859}{P\+P\+L\+\_\+\+Solver} (const \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} \&)
\begin{DoxyCompactList}\small\item\em copy constructor (deep copy) \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_a67408174d2260de5ae5f070a70f27e9d}{copy} (const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$)
\begin{DoxyCompactList}\small\item\em performs a deep copy, similar to a copy constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aecb2caed09777ca3b6d5e285540abe56}\label{group___c_l_s_solvers_aecb2caed09777ca3b6d5e285540abe56}} 
virtual {\bfseries $\sim$\+P\+P\+L\+\_\+\+Solver} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properties}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a40b49fb3bb0b14cc66cabf54ef17e437}\label{group___c_l_s_solvers_a40b49fb3bb0b14cc66cabf54ef17e437}} 
virtual N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_a40b49fb3bb0b14cc66cabf54ef17e437}{get\+\_\+dimension} () const
\begin{DoxyCompactList}\small\item\em Returns the dimension of the underlying vector space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a7d09fe31148950d46219df67719aef3f}\label{group___c_l_s_solvers_a7d09fe31148950d46219df67719aef3f}} 
virtual unsigned long {\bfseries get\+\_\+number\+\_\+of\+\_\+constraints} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{group___c_l_s_solvers_a1ff16def22c734348c626b65437dd1e3}{solve} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraint (singular!) and re-\/computes the solution. \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_a5000b8c5bee37029276ce63a3568bfb7}{solve} (vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraints (plural!) and re-\/computes the solution. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a00076ee1e8ef90f7d162f02372529666}\label{group___c_l_s_solvers_a00076ee1e8ef90f7d162f02372529666}} 
virtual void \hyperlink{group___c_l_s_solvers_a00076ee1e8ef90f7d162f02372529666}{setup\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em clear the current set of rays and extracts the ones contained in lp \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a6abc19f36a28ed91b4ebc4d3a1e32dc6}\label{group___c_l_s_solvers_a6abc19f36a28ed91b4ebc4d3a1e32dc6}} 
P\+P\+L\+::\+N\+N\+C\+\_\+\+Polyhedron $\ast$ \hyperlink{group___c_l_s_solvers_a6abc19f36a28ed91b4ebc4d3a1e32dc6}{lp}
\begin{DoxyCompactList}\small\item\em P\+PL problem interface. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a6e3852b048b35faf96d8a12155b0547e}\label{group___c_l_s_solvers_a6e3852b048b35faf96d8a12155b0547e}} 
unsigned \hyperlink{group___c_l_s_solvers_a6e3852b048b35faf96d8a12155b0547e}{m}
\begin{DoxyCompactList}\small\item\em number of constraints \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aa70891def9af366c47e01acf952bbdba}\label{group___c_l_s_solvers_aa70891def9af366c47e01acf952bbdba}} 
N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_aa70891def9af366c47e01acf952bbdba}{n}
\begin{DoxyCompactList}\small\item\em number of variables \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a90bb9152de9b1260cdbf938010cd48b2}\label{group___c_l_s_solvers_a90bb9152de9b1260cdbf938010cd48b2}} 
R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE $\ast$ \hyperlink{group___c_l_s_solvers_a90bb9152de9b1260cdbf938010cd48b2}{ray\+\_\+data}
\begin{DoxyCompactList}\small\item\em used to retrieve rays \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a157a18ab31b415a615bca9845248bfcc}\label{group___c_l_s_solvers_a157a18ab31b415a615bca9845248bfcc}} 
P\+P\+L\+::\+Variable $\ast$$\ast$ \hyperlink{group___c_l_s_solvers_a157a18ab31b415a615bca9845248bfcc}{X}
\begin{DoxyCompactList}\small\item\em array of variables \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Static Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a346402cddefaa715291dfb7f243073a2}\label{group___c_l_s_solvers_a346402cddefaa715291dfb7f243073a2}} 
static unsigned \hyperlink{group___c_l_s_solvers_a346402cddefaa715291dfb7f243073a2}{instances} = 0
\begin{DoxyCompactList}\small\item\em number of P\+PL instances \end{DoxyCompactList}\end{DoxyCompactItemize}


\paragraph{Member Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a67408174d2260de5ae5f070a70f27e9d}\label{group___c_l_s_solvers_a67408174d2260de5ae5f070a70f27e9d}} 
\index{P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}!copy@{copy}}
\index{copy@{copy}!P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily bool P\+P\+L\+\_\+\+Solver\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



performs a deep copy, similar to a copy constructor 

\begin{DoxyReturn}{Returns}
{\ttfamily true} iff copying was successful 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Do not mix-\/and-\/match solvers. At the present time, a \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} is not equipped to copy a \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, or vice versa. (This doesn\textquotesingle{}t even make sense between exact and approximate solvers.) 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_a442ad4ad67ee2feff0df49e9201d61ca}{L\+P\+\_\+\+Solver}.



Definition at line 82 of file ppl\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a1ff16def22c734348c626b65437dd1e3}\label{group___c_l_s_solvers_a1ff16def22c734348c626b65437dd1e3}} 
\index{P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool P\+P\+L\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraint (singular!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraint is consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}{L\+P\+\_\+\+Solver}.



Definition at line 113 of file ppl\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a5000b8c5bee37029276ce63a3568bfb7}\label{group___c_l_s_solvers_a5000b8c5bee37029276ce63a3568bfb7}} 
\index{P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!P\+P\+L\+\_\+\+Solver@{P\+P\+L\+\_\+\+Solver}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool P\+P\+L\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraints (plural!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraints are consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_a35da4bdf5db971c445f495b6eaab072d}{L\+P\+\_\+\+Solver}.



Definition at line 125 of file ppl\+\_\+solver.\+cpp.

\index{ray@{ray}}\label{classray}
\Hypertarget{group___c_l_s_solvers_classray}
\subsubsection{class ray}
a ray defined by nonnegative coordinates $(a_1,\ldots,a_n)$ 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
October 2014 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class encapsulates a ray, one major part of the definition of a skeleton. Rays can be initialized to a particular set of coefficients, or to a particular axis (which is then translated into the corresponding coefficients).

A special feature is that a rays can track the constraints known to be active at the ray, allowing for more efficient computation in the double description method. Adding known constraints can be done with or without checking whether the constraint actually is active, so this should be done with care. 

Definition at line 190 of file lp\+\_\+solver.\+hpp.

\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{group___c_l_s_solvers_a48d51151bb229b2b3363869760fe4b3c}{ray} (N\+V\+A\+R\+\_\+\+T\+Y\+PE, long=-\/1)
\begin{DoxyCompactList}\small\item\em Creates a ray with the given number of variables, all set to 0. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_a121e66bf83dfa1582edc24505bbc8095}{ray} (N\+V\+A\+R\+\_\+\+T\+Y\+PE, const R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE \mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Creates a ray with the given number of variables, with coordinates set to the value of the array. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_a3639433d20b97abc32b56ca93779dcaf}{ray} (N\+V\+A\+R\+\_\+\+T\+Y\+PE, const E\+X\+P\+\_\+\+T\+Y\+PE \mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Creates a ray with the given number of variables, with coordinates set to the value of the array. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_a6387c9c134132709f29770212648c718}{ray} (const vector$<$ R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE $>$ \&)
\begin{DoxyCompactList}\small\item\em Creates a ray whose coordinates are given by the vector. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_af4ec5bf395f8b37cb7c4fd7f27999a5d}{ray} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Copies the coordinates of the other ray. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{group___c_l_s_solvers_ae29c6b5cecdc32127dc9e5c0141d120d}{$\sim$ray} ()
\begin{DoxyCompactList}\small\item\em Deletes memory allocated by the constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properies}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a57662d3f86d00384f73869740ec21adf}\label{group___c_l_s_solvers_a57662d3f86d00384f73869740ec21adf}} 
N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_a57662d3f86d00384f73869740ec21adf}{get\+\_\+dimension} () const
\begin{DoxyCompactList}\small\item\em Returns the dimension of this ray. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a952d271bf4f9361c87864e7479fb8677}\label{group___c_l_s_solvers_a952d271bf4f9361c87864e7479fb8677}} 
R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_a952d271bf4f9361c87864e7479fb8677}{operator\mbox{[}$\,$\mbox{]}} (N\+V\+A\+R\+\_\+\+T\+Y\+PE index) const
\begin{DoxyCompactList}\small\item\em Returns the entry indicated. Numbering starts at 0. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aaff8d27de2240e43dc0d20f84f953b1b}\label{group___c_l_s_solvers_aaff8d27de2240e43dc0d20f84f953b1b}} 
const R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE $\ast$ \hyperlink{group___c_l_s_solvers_aaff8d27de2240e43dc0d20f84f953b1b}{weights} () const
\begin{DoxyCompactList}\small\item\em Returns the weights. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a785bb4f7649e9c3db1141fdde55834c0}\label{group___c_l_s_solvers_a785bb4f7649e9c3db1141fdde55834c0}} 
const R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_a785bb4f7649e9c3db1141fdde55834c0}{coordinate} (N\+V\+A\+R\+\_\+\+T\+Y\+PE index)
\begin{DoxyCompactList}\small\item\em Synonym for \mbox{[}\mbox{]}. I have no idea why I added this. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_aa1831b718c9a91d786a1a578cb1cefea}{is\+\_\+active\+\_\+at} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&hyperplane) const
\begin{DoxyCompactList}\small\item\em Returns {\ttfamily true} if and only if the hyperplane is active at this ray. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a5d4113ea6249145c337f4d26a54eb940}{is\+\_\+above} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&hyperplane)
\begin{DoxyCompactList}\small\item\em Returns {\ttfamily true} if and only if this ray is above the hyperplane. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a08f0af168bb0a86db612fdd3ce22045b}{is\+\_\+below} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&hyperplane)
\begin{DoxyCompactList}\small\item\em Returns {\ttfamily true} if and only if this ray is below the hyperplane. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Computation}\par
\begin{DoxyCompactItemize}
\item 
D\+O\+T\+P\+R\+O\+D\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_a25f56f0f7acafe000f98550af47b7da9}{obtain\+\_\+dot\+\_\+product} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&) const
\begin{DoxyCompactList}\small\item\em Convenience function to compute dot product between ray and the given constraint. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a99cfe50a0abd150d7effd8911664c2db}\label{group___c_l_s_solvers_a99cfe50a0abd150d7effd8911664c2db}} 
void \hyperlink{group___c_l_s_solvers_a99cfe50a0abd150d7effd8911664c2db}{simplify\+\_\+ray} ()
\begin{DoxyCompactList}\small\item\em Simplifies the ray by dividing its components by the least common denominator. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_classray}{ray} \& \hyperlink{group___c_l_s_solvers_a83fa2d552fda75b973fe659c39ff9960}{operator=} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Assignment operator; assigns the value of {\ttfamily other} to {\ttfamily this}. \end{DoxyCompactList}\item 
void \hyperlink{group___c_l_s_solvers_a3f95b591c0b92d2ea8cc04b1c9b0d179}{swap} (\hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Swap two rays of equal dimension by swapping their data, avoiding memory reallocation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Friends}
\begin{Indent}\textbf{ Comparison}\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{group___c_l_s_solvers_ae27bf49e1b2756797f82fea0bf810dfd}{operator==} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Indicates whether the two rays are equal. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a22b7d226858aa935e739c696065e4680}{operator!=} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Indicates whether the two rays are unequal. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a088bbdf2a6fc03509fc660aa3aee110e}{operator!=} (\hyperlink{group___c_l_s_solvers_classray}{ray} \&r, \hyperlink{group___c_l_s_solvers_classray}{ray} \&s)
\begin{DoxyCompactList}\small\item\em Indicates whether the two rays are unequal. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_ae27bf49e1b2756797f82fea0bf810dfd}{operator==} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Returns {\ttfamily true} if and only if the coordinates of the two rays are equal. \end{DoxyCompactList}\item 
bool \hyperlink{group___c_l_s_solvers_a5909f048e7cf014f880adb43da3862d3}{operator$<$} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Lexicographic comparison of rays. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ I/O}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a1fa347ed00fc99eec663252c28108a3f}\label{group___c_l_s_solvers_a1fa347ed00fc99eec663252c28108a3f}} 
ostream \& \hyperlink{group___c_l_s_solvers_a1fa347ed00fc99eec663252c28108a3f}{operator$<$$<$} (ostream \&, const \hyperlink{group___c_l_s_solvers_classray}{ray} \&)
\begin{DoxyCompactList}\small\item\em Output is of the form $(r_1, \ldots, r_n)$. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}


\paragraph{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a48d51151bb229b2b3363869760fe4b3c}\label{group___c_l_s_solvers_a48d51151bb229b2b3363869760fe4b3c}} 
\index{ray@{ray}!ray@{ray}}
\index{ray@{ray}!ray@{ray}}
\subparagraph{\texorpdfstring{ray()}{ray()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily ray\+::ray (\begin{DoxyParamCaption}\item[{N\+V\+A\+R\+\_\+\+T\+Y\+PE}]{dimension,  }\item[{long}]{direction = {\ttfamily -\/1} }\end{DoxyParamCaption})}



Creates a ray with the given number of variables, all set to 0. 

The optional second argument specifies a direction, and sets that coordinate to 1. In this case, there is no need to set the ray\textquotesingle{}s known active constraints, as this is known and populated automatically. \begin{DoxyPrecond}{Precondition}
The dimension should be greater than zero. While the direction need not be specified{$\dots$} (see postcondition) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
{$\dots$}the result when the direction is zero is a zero ray. If the direction is $ i $, then the result is the $i$th canonical vector. 
\end{DoxyPostcond}


Definition at line 132 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a121e66bf83dfa1582edc24505bbc8095}\label{group___c_l_s_solvers_a121e66bf83dfa1582edc24505bbc8095}} 
\index{ray@{ray}!ray@{ray}}
\index{ray@{ray}!ray@{ray}}
\subparagraph{\texorpdfstring{ray()}{ray()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily ray\+::ray (\begin{DoxyParamCaption}\item[{N\+V\+A\+R\+\_\+\+T\+Y\+PE}]{dimension,  }\item[{const R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE}]{entries\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}



Creates a ray with the given number of variables, with coordinates set to the value of the array. 

\begin{DoxyPrecond}{Precondition}
the size of the array needs to be at least as long as the number of variables! 
\end{DoxyPrecond}


Definition at line 143 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a3639433d20b97abc32b56ca93779dcaf}\label{group___c_l_s_solvers_a3639433d20b97abc32b56ca93779dcaf}} 
\index{ray@{ray}!ray@{ray}}
\index{ray@{ray}!ray@{ray}}
\subparagraph{\texorpdfstring{ray()}{ray()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily ray\+::ray (\begin{DoxyParamCaption}\item[{N\+V\+A\+R\+\_\+\+T\+Y\+PE}]{dimension,  }\item[{const E\+X\+P\+\_\+\+T\+Y\+PE}]{entries\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}



Creates a ray with the given number of variables, with coordinates set to the value of the array. 

\begin{DoxyPrecond}{Precondition}
the size of the array needs to be at least as long as the number of variables! 
\end{DoxyPrecond}


Definition at line 152 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a6387c9c134132709f29770212648c718}\label{group___c_l_s_solvers_a6387c9c134132709f29770212648c718}} 
\index{ray@{ray}!ray@{ray}}
\index{ray@{ray}!ray@{ray}}
\subparagraph{\texorpdfstring{ray()}{ray()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily ray\+::ray (\begin{DoxyParamCaption}\item[{const vector$<$ R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE $>$ \&}]{entries }\end{DoxyParamCaption})}



Creates a ray whose coordinates are given by the vector. 

\begin{DoxyPostcond}{Postcondition}
The dimension of this ray will equal the number of entries in the vector, and the values of their entries will be equal. 
\end{DoxyPostcond}


Definition at line 161 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_af4ec5bf395f8b37cb7c4fd7f27999a5d}\label{group___c_l_s_solvers_af4ec5bf395f8b37cb7c4fd7f27999a5d}} 
\index{ray@{ray}!ray@{ray}}
\index{ray@{ray}!ray@{ray}}
\subparagraph{\texorpdfstring{ray()}{ray()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily ray\+::ray (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{old\+\_\+ray }\end{DoxyParamCaption})}



Copies the coordinates of the other ray. 

Allocates new memory, and copies the active constraints. 

Definition at line 170 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ae29c6b5cecdc32127dc9e5c0141d120d}\label{group___c_l_s_solvers_ae29c6b5cecdc32127dc9e5c0141d120d}} 
\index{ray@{ray}!````~ray@{$\sim$ray}}
\index{````~ray@{$\sim$ray}!ray@{ray}}
\subparagraph{\texorpdfstring{$\sim$ray()}{~ray()}}
{\footnotesize\ttfamily ray\+::$\sim$ray (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Deletes memory allocated by the constructor. 

Currently, that means it deletes {\ttfamily coords}. 

Definition at line 180 of file lp\+\_\+solver.\+cpp.



\paragraph{Member Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a5d4113ea6249145c337f4d26a54eb940}\label{group___c_l_s_solvers_a5d4113ea6249145c337f4d26a54eb940}} 
\index{ray@{ray}!is\+\_\+above@{is\+\_\+above}}
\index{is\+\_\+above@{is\+\_\+above}!ray@{ray}}
\subparagraph{\texorpdfstring{is\+\_\+above()}{is\_above()}}
{\footnotesize\ttfamily bool ray\+::is\+\_\+above (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{hyperplane }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns {\ttfamily true} if and only if this ray is above the hyperplane. 


\begin{DoxyParams}{Parameters}
{\em hyperplane} & a constraint; we would like to know whether {\ttfamily this} is above it \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if and only if {\ttfamily this} is above {\ttfamily constraint} 
\end{DoxyReturn}
Practically speaking, if the hyperplane is defined by the vector $ \mathbf c $ and the ray is defined by $ \mathbf r $ , this function returns true if and only if $ c\cdot r > 0 $. 

Definition at line 293 of file lp\+\_\+solver.\+hpp.

\mbox{\Hypertarget{group___c_l_s_solvers_aa1831b718c9a91d786a1a578cb1cefea}\label{group___c_l_s_solvers_aa1831b718c9a91d786a1a578cb1cefea}} 
\index{ray@{ray}!is\+\_\+active\+\_\+at@{is\+\_\+active\+\_\+at}}
\index{is\+\_\+active\+\_\+at@{is\+\_\+active\+\_\+at}!ray@{ray}}
\subparagraph{\texorpdfstring{is\+\_\+active\+\_\+at()}{is\_active\_at()}}
{\footnotesize\ttfamily bool ray\+::is\+\_\+active\+\_\+at (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{hyperplane }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns {\ttfamily true} if and only if the hyperplane is active at this ray. 


\begin{DoxyParams}{Parameters}
{\em hyperplane} & a constraint; we would like to know whether {\ttfamily this} lies on it \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if and only if {\ttfamily this} lies on {\ttfamily constraint} 
\end{DoxyReturn}
Practically speaking, if the hyperplane is defined by the vector $ \mathbf c $ and the ray is defined by $ \mathbf r $ , this function returns true if and only if $ c\cdot r = 0 $. 

Definition at line 279 of file lp\+\_\+solver.\+hpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a08f0af168bb0a86db612fdd3ce22045b}\label{group___c_l_s_solvers_a08f0af168bb0a86db612fdd3ce22045b}} 
\index{ray@{ray}!is\+\_\+below@{is\+\_\+below}}
\index{is\+\_\+below@{is\+\_\+below}!ray@{ray}}
\subparagraph{\texorpdfstring{is\+\_\+below()}{is\_below()}}
{\footnotesize\ttfamily bool ray\+::is\+\_\+below (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{hyperplane }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns {\ttfamily true} if and only if this ray is below the hyperplane. 


\begin{DoxyParams}{Parameters}
{\em hyperplane} & a constraint; we would like to know whether {\ttfamily this} is below it \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if and only if {\ttfamily this} is below {\ttfamily constraint} 
\end{DoxyReturn}
Practically speaking, if the hyperplane is defined by the vector $ \mathbf c $ and the ray is defined by $ \mathbf r $ , this function returns true if and only if $ c\cdot r < 0 $. 

Definition at line 307 of file lp\+\_\+solver.\+hpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a25f56f0f7acafe000f98550af47b7da9}\label{group___c_l_s_solvers_a25f56f0f7acafe000f98550af47b7da9}} 
\index{ray@{ray}!obtain\+\_\+dot\+\_\+product@{obtain\+\_\+dot\+\_\+product}}
\index{obtain\+\_\+dot\+\_\+product@{obtain\+\_\+dot\+\_\+product}!ray@{ray}}
\subparagraph{\texorpdfstring{obtain\+\_\+dot\+\_\+product()}{obtain\_dot\_product()}}
{\footnotesize\ttfamily D\+O\+T\+P\+R\+O\+D\+\_\+\+T\+Y\+PE ray\+::obtain\+\_\+dot\+\_\+product (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{hyperplane }\end{DoxyParamCaption}) const}



Convenience function to compute dot product between ray and the given constraint. 

\begin{DoxyReturn}{Returns}
the dot product of {\ttfamily this} and {\ttfamily constraint} 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 212 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a83fa2d552fda75b973fe659c39ff9960}\label{group___c_l_s_solvers_a83fa2d552fda75b973fe659c39ff9960}} 
\index{ray@{ray}!operator=@{operator=}}
\index{operator=@{operator=}!ray@{ray}}
\subparagraph{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \hyperlink{group___c_l_s_solvers_classray}{ray} \& ray\+::operator= (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{other }\end{DoxyParamCaption})}



Assignment operator; assigns the value of {\ttfamily other} to {\ttfamily this}. 

\begin{DoxyReturn}{Returns}
{\ttfamily this} 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 330 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a3f95b591c0b92d2ea8cc04b1c9b0d179}\label{group___c_l_s_solvers_a3f95b591c0b92d2ea8cc04b1c9b0d179}} 
\index{ray@{ray}!swap@{swap}}
\index{swap@{swap}!ray@{ray}}
\subparagraph{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily void ray\+::swap (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{other }\end{DoxyParamCaption})}



Swap two rays of equal dimension by swapping their data, avoiding memory reallocation. 

\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 350 of file lp\+\_\+solver.\+cpp.



\paragraph{Friends And Related Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a22b7d226858aa935e739c696065e4680}\label{group___c_l_s_solvers_a22b7d226858aa935e739c696065e4680}} 
\index{ray@{ray}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!ray@{ray}}
\subparagraph{\texorpdfstring{operator"!=}{operator!=}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool operator!= (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r1,  }\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Indicates whether the two rays are unequal. 

\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 312 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a088bbdf2a6fc03509fc660aa3aee110e}\label{group___c_l_s_solvers_a088bbdf2a6fc03509fc660aa3aee110e}} 
\index{ray@{ray}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!ray@{ray}}
\subparagraph{\texorpdfstring{operator"!=}{operator!=}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool operator!= (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r,  }\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Indicates whether the two rays are unequal. 


\begin{DoxyParams}{Parameters}
{\em r} & a ray \\
\hline
{\em s} & a ray \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 337 of file lp\+\_\+solver.\+hpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a5909f048e7cf014f880adb43da3862d3}\label{group___c_l_s_solvers_a5909f048e7cf014f880adb43da3862d3}} 
\index{ray@{ray}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!ray@{ray}}
\subparagraph{\texorpdfstring{operator$<$}{operator<}}
{\footnotesize\ttfamily bool operator$<$ (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{first\+\_\+ray,  }\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{second\+\_\+ray }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Lexicographic comparison of rays. 

\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 361 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ae27bf49e1b2756797f82fea0bf810dfd}\label{group___c_l_s_solvers_ae27bf49e1b2756797f82fea0bf810dfd}} 
\index{ray@{ray}!operator==@{operator==}}
\index{operator==@{operator==}!ray@{ray}}
\subparagraph{\texorpdfstring{operator==}{operator==}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool operator== (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r1,  }\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Indicates whether the two rays are equal. 

\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 304 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ae27bf49e1b2756797f82fea0bf810dfd}\label{group___c_l_s_solvers_ae27bf49e1b2756797f82fea0bf810dfd}} 
\index{ray@{ray}!operator==@{operator==}}
\index{operator==@{operator==}!ray@{ray}}
\subparagraph{\texorpdfstring{operator==}{operator==}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool operator== (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r1,  }\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Returns {\ttfamily true} if and only if the coordinates of the two rays are equal. 

\begin{DoxyWarning}{Warning}
This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 304 of file lp\+\_\+solver.\+cpp.

\index{skeleton@{skeleton}}\label{classskeleton}
\Hypertarget{group___c_l_s_solvers_classskeleton}
\subsubsection{class skeleton}
skeleton of a polyhedral cone, with methods allowing definition and refinement 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
October 2014 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class implements the Double Description Method, an iterative algorithm for computing the skeleton of a cone. This particular version uses Zolotykh\textquotesingle{}s Graph\+Adj criterion \cite{Zolotych_DoubleDescription}. The iterative nature means that the cone can be updated with new constraints, passed to that algorithm, and the skeleton will be automatically recomputed. 

Definition at line 178 of file skeleton.\+hpp.

Inheritance diagram for skeleton\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{group___c_l_s_solvers}
\end{center}
\end{figure}
\subsubsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a7a9181253fc3b9f7b61871047b2b31cc}\label{group___c_l_s_solvers_a7a9181253fc3b9f7b61871047b2b31cc}} 
void \hyperlink{group___c_l_s_solvers_a7a9181253fc3b9f7b61871047b2b31cc}{common\+\_\+initialization} (N\+V\+A\+R\+\_\+\+T\+Y\+PE)
\begin{DoxyCompactList}\small\item\em Initialization common to all constructors. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_a60f5818e984abe589ea8298d189cd9c6}{skeleton} (N\+V\+A\+R\+\_\+\+T\+Y\+PE)
\begin{DoxyCompactList}\small\item\em Constructs a basic skeleton in the given number of dimensions, initialized to the axes, or (equivalently) to the set of constraints $ x_i \geq 0 $. \end{DoxyCompactList}\item 
\hyperlink{group___c_l_s_solvers_a5d0ebc69ae4ff20afd3096e36b31ab1f}{skeleton} (N\+V\+A\+R\+\_\+\+T\+Y\+PE, vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&)
\begin{DoxyCompactList}\small\item\em Constructs a skeleton described by the given system of constraints. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_abbb0828dc5cd38edf09093e738510d7a}\label{group___c_l_s_solvers_abbb0828dc5cd38edf09093e738510d7a}} 
\hyperlink{group___c_l_s_solvers_abbb0828dc5cd38edf09093e738510d7a}{skeleton} (\hyperlink{group___c_l_s_solvers_classskeleton}{skeleton} \&)
\begin{DoxyCompactList}\small\item\em Performs a deep copy of {\ttfamily other}. \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_a42d30b92f27936eab11d0fa4f0cc10b4}{copy} (const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$)
\begin{DoxyCompactList}\small\item\em performs a deep copy, similar to a copy constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_ae8874234344e5e51f9b81f6199ee2aa6}\label{group___c_l_s_solvers_ae8874234344e5e51f9b81f6199ee2aa6}} 
virtual \hyperlink{group___c_l_s_solvers_ae8874234344e5e51f9b81f6199ee2aa6}{$\sim$skeleton} ()
\begin{DoxyCompactList}\small\item\em Currently does nothing the compiler wouldn\textquotesingle{}t do. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properties}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_ac6dd4f7d7e79ab08d6cf49ad4925f5ef}\label{group___c_l_s_solvers_ac6dd4f7d7e79ab08d6cf49ad4925f5ef}} 
N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{group___c_l_s_solvers_ac6dd4f7d7e79ab08d6cf49ad4925f5ef}{get\+\_\+dimension} () const
\begin{DoxyCompactList}\small\item\em Returns the dimension of the underlying vector space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a3e2662e9f9e6a0dde0459dee0b27fd1c}\label{group___c_l_s_solvers_a3e2662e9f9e6a0dde0459dee0b27fd1c}} 
unsigned long \hyperlink{group___c_l_s_solvers_a3e2662e9f9e6a0dde0459dee0b27fd1c}{get\+\_\+number\+\_\+of\+\_\+edges} ()
\begin{DoxyCompactList}\small\item\em Returns the number of edges defining the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_adc4557716509bfeeae99f99b93953cf8}\label{group___c_l_s_solvers_adc4557716509bfeeae99f99b93953cf8}} 
set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \hyperlink{group___c_l_s_solvers_adc4557716509bfeeae99f99b93953cf8}{get\+\_\+edges} ()
\begin{DoxyCompactList}\small\item\em Returns the edges that define the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a0b75f0ce54e512673169b193955fc58f}\label{group___c_l_s_solvers_a0b75f0ce54e512673169b193955fc58f}} 
unsigned long \hyperlink{group___c_l_s_solvers_a0b75f0ce54e512673169b193955fc58f}{get\+\_\+number\+\_\+of\+\_\+constraints} ()
\begin{DoxyCompactList}\small\item\em Returns the number of constraints defining the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a29665cf3b04694b349f224e54f93f2db}\label{group___c_l_s_solvers_a29665cf3b04694b349f224e54f93f2db}} 
const vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \& \hyperlink{group___c_l_s_solvers_a29665cf3b04694b349f224e54f93f2db}{get\+\_\+constraints} ()
\begin{DoxyCompactList}\small\item\em Returns the constraints that define the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a8c0ceb21b570a4a4084902a497de79a0}\label{group___c_l_s_solvers_a8c0ceb21b570a4a4084902a497de79a0}} 
\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \hyperlink{group___c_l_s_solvers_a8c0ceb21b570a4a4084902a497de79a0}{get\+\_\+constraint} (int index)
\begin{DoxyCompactList}\small\item\em Returns the indicated constraint. Numbering starts at 0. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Computation}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a6b48120d11e7b244c14c748d990d2ade}\label{group___c_l_s_solvers_a6b48120d11e7b244c14c748d990d2ade}} 
void \hyperlink{group___c_l_s_solvers_a6b48120d11e7b244c14c748d990d2ade}{which\+\_\+constraints\+\_\+active\+\_\+at} (const \hyperlink{group___c_l_s_solvers_classray}{ray} \&u, bool $\ast$result) const
\begin{DoxyCompactList}\small\item\em returns the set of constraints in the skeleton active at {\ttfamily u} \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aca399adccf69ea8f9df6cf557526032b}\label{group___c_l_s_solvers_aca399adccf69ea8f9df6cf557526032b}} 
bool \hyperlink{group___c_l_s_solvers_aca399adccf69ea8f9df6cf557526032b}{is\+\_\+consistent} (const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&c) const
\begin{DoxyCompactList}\small\item\em tests for consistency of a potentially new constraint. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{group___c_l_s_solvers_ac366952c2b0908159255916a1e37f9b3}{solve} (vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraints (plural!) and re-\/computes the skeleton. \end{DoxyCompactList}\item 
virtual bool \hyperlink{group___c_l_s_solvers_a8add1433d3bc6b1a8588f0f88134599f}{solve} (\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraint (singular!) and re-\/computes the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a1af8c607a3dc93633e0d395e73cb1c97}\label{group___c_l_s_solvers_a1af8c607a3dc93633e0d395e73cb1c97}} 
set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \hyperlink{group___c_l_s_solvers_a1af8c607a3dc93633e0d395e73cb1c97}{adjacencies\+\_\+by\+\_\+graphs} (set$<$ \hyperlink{group___c_l_s_solvers_classray}{ray} $>$)
\begin{DoxyCompactList}\small\item\em Re-\/computes the edges in the skeleton using Zolotych\textquotesingle{}s {\ttfamily Graph\+Adj} algorithm and returns the result. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___c_l_s_solvers_aa5991e7e25783c2b8cfd772f41f7b99b}\label{group___c_l_s_solvers_aa5991e7e25783c2b8cfd772f41f7b99b}} 
\hyperlink{group___c_l_s_solvers_classskeleton}{skeleton} \& \hyperlink{group___c_l_s_solvers_aa5991e7e25783c2b8cfd772f41f7b99b}{operator=} (const \hyperlink{group___c_l_s_solvers_classskeleton}{skeleton} \&)
\begin{DoxyCompactList}\small\item\em Assignment operator; empties current set \& copies from other. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{Friends}
\begin{Indent}\textbf{ I/O}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___c_l_s_solvers_a5732209c39488881acfc0fb5831e513b}\label{group___c_l_s_solvers_a5732209c39488881acfc0fb5831e513b}} 
ostream \& \hyperlink{group___c_l_s_solvers_a5732209c39488881acfc0fb5831e513b}{operator$<$$<$} (ostream \&, const \hyperlink{group___c_l_s_solvers_classskeleton}{skeleton} \&)
\begin{DoxyCompactList}\small\item\em prints out the constraints, then the rays, then the edges. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Additional Inherited Members}


\paragraph{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a60f5818e984abe589ea8298d189cd9c6}\label{group___c_l_s_solvers_a60f5818e984abe589ea8298d189cd9c6}} 
\index{skeleton@{skeleton}!skeleton@{skeleton}}
\index{skeleton@{skeleton}!skeleton@{skeleton}}
\subparagraph{\texorpdfstring{skeleton()}{skeleton()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily skeleton\+::skeleton (\begin{DoxyParamCaption}\item[{N\+V\+A\+R\+\_\+\+T\+Y\+PE}]{dimension }\end{DoxyParamCaption})}



Constructs a basic skeleton in the given number of dimensions, initialized to the axes, or (equivalently) to the set of constraints $ x_i \geq 0 $. 

The rays are informed of their active constraints. \begin{DoxyPrecond}{Precondition}
the argument should be at least two 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
the skeleton of the positive orthant 
\end{DoxyPostcond}


Definition at line 119 of file skeleton.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a5d0ebc69ae4ff20afd3096e36b31ab1f}\label{group___c_l_s_solvers_a5d0ebc69ae4ff20afd3096e36b31ab1f}} 
\index{skeleton@{skeleton}!skeleton@{skeleton}}
\index{skeleton@{skeleton}!skeleton@{skeleton}}
\subparagraph{\texorpdfstring{skeleton()}{skeleton()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily skeleton\+::skeleton (\begin{DoxyParamCaption}\item[{N\+V\+A\+R\+\_\+\+T\+Y\+PE}]{dimension,  }\item[{vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&}]{constraints }\end{DoxyParamCaption})}



Constructs a skeleton described by the given system of constraints. 

Practically speaking, it first generates a basic skeleton, then iterates on the given constraints. \begin{DoxyPrecond}{Precondition}
{\ttfamily u.\+size() == v.\+size()} for all {\ttfamily u}, {\ttfamily v} in the vector 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
unless the system supplied was inconsistent, a valid skeleton of the corresponding polyhedral cone 
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
Your program will almost certainly fail if you do not respect the precondition. 
\end{DoxyWarning}


Definition at line 124 of file skeleton.\+cpp.



\paragraph{Member Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_a42d30b92f27936eab11d0fa4f0cc10b4}\label{group___c_l_s_solvers_a42d30b92f27936eab11d0fa4f0cc10b4}} 
\index{skeleton@{skeleton}!copy@{copy}}
\index{copy@{copy}!skeleton@{skeleton}}
\subparagraph{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily bool skeleton\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



performs a deep copy, similar to a copy constructor 

\begin{DoxyReturn}{Returns}
{\ttfamily true} iff copying was successful 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Do not mix-\/and-\/match solvers. At the present time, a \hyperlink{group___c_l_s_solvers_class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} is not equipped to copy a \hyperlink{group___c_l_s_solvers_class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, or vice versa. (This doesn\textquotesingle{}t even make sense between exact and approximate solvers.) 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_a442ad4ad67ee2feff0df49e9201d61ca}{L\+P\+\_\+\+Solver}.



Definition at line 140 of file skeleton.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ac366952c2b0908159255916a1e37f9b3}\label{group___c_l_s_solvers_ac366952c2b0908159255916a1e37f9b3}} 
\index{skeleton@{skeleton}!solve@{solve}}
\index{solve@{solve}!skeleton@{skeleton}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool skeleton\+::solve (\begin{DoxyParamCaption}\item[{vector$<$ \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} $>$ \&}]{new\+\_\+constraints }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraints (plural!) and re-\/computes the skeleton. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraints are consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_a35da4bdf5db971c445f495b6eaab072d}{L\+P\+\_\+\+Solver}.



Definition at line 270 of file skeleton.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_a8add1433d3bc6b1a8588f0f88134599f}\label{group___c_l_s_solvers_a8add1433d3bc6b1a8588f0f88134599f}} 
\index{skeleton@{skeleton}!solve@{solve}}
\index{solve@{solve}!skeleton@{skeleton}}
\subparagraph{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool skeleton\+::solve (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{constraint }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraint (singular!) and re-\/computes the skeleton. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraint is consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{group___c_l_s_solvers_abd84374c52124116becc8924dc74e12d}{L\+P\+\_\+\+Solver}.



Definition at line 162 of file skeleton.\+cpp.



\subsection{Function Documentation}
\mbox{\Hypertarget{group___c_l_s_solvers_gacb5ce7e22db91b33c26ea0be6a6026de}\label{group___c_l_s_solvers_gacb5ce7e22db91b33c26ea0be6a6026de}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!intersections\+\_\+of\+\_\+active\+\_\+constraints@{intersections\+\_\+of\+\_\+active\+\_\+constraints}}
\index{intersections\+\_\+of\+\_\+active\+\_\+constraints@{intersections\+\_\+of\+\_\+active\+\_\+constraints}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{intersections\+\_\+of\+\_\+active\+\_\+constraints()}{intersections\_of\_active\_constraints()}}
{\footnotesize\ttfamily vector$<$bool$>$ intersections\+\_\+of\+\_\+active\+\_\+constraints (\begin{DoxyParamCaption}\item[{bool $\ast$}]{,  }\item[{bool $\ast$}]{,  }\item[{unsigned}]{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the intersection between the given sets of constraints. 
\end{DoxyReturn}
\mbox{\Hypertarget{group___c_l_s_solvers_ga06bebd50facdc36f850371e545f82174}\label{group___c_l_s_solvers_ga06bebd50facdc36f850371e545f82174}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second@{is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second}}
\index{is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second@{is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second()}{is\_first\_subset\_of\_second()}}
{\footnotesize\ttfamily bool is\+\_\+first\+\_\+subset\+\_\+of\+\_\+second (\begin{DoxyParamCaption}\item[{bool $\ast$}]{,  }\item[{bool $\ast$}]{,  }\item[{unsigned}]{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the first set is a subset of the second. 
\end{DoxyReturn}


Definition at line 330 of file skeleton.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ga33829eddeaa7be000404e4d281d90973}\label{group___c_l_s_solvers_ga33829eddeaa7be000404e4d281d90973}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!number\+\_\+of\+\_\+common\+\_\+constraints@{number\+\_\+of\+\_\+common\+\_\+constraints}}
\index{number\+\_\+of\+\_\+common\+\_\+constraints@{number\+\_\+of\+\_\+common\+\_\+constraints}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{number\+\_\+of\+\_\+common\+\_\+constraints()}{number\_of\_common\_constraints()}}
{\footnotesize\ttfamily int number\+\_\+of\+\_\+common\+\_\+constraints (\begin{DoxyParamCaption}\item[{bool $\ast$}]{,  }\item[{bool $\ast$}]{,  }\item[{unsigned}]{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
the number of constraints common to both sets. 
\end{DoxyReturn}


Definition at line 297 of file skeleton.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_gae039f9fb46b8c57063342f6203add523}\label{group___c_l_s_solvers_gae039f9fb46b8c57063342f6203add523}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \hyperlink{group___c_l_s_solvers_classray}{ray} operator$\ast$ (\begin{DoxyParamCaption}\item[{R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE}]{,  }\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{ }\end{DoxyParamCaption})}



Multiply every coordinate in the given ray by the given scalar. 

\begin{DoxyReturn}{Returns}
a copy of the ray, scaled by the requesed amount 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 222 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ga30af4b27086e461f862e7d16e9d209df}\label{group___c_l_s_solvers_ga30af4b27086e461f862e7d16e9d209df}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily R\+A\+Y\+E\+N\+T\+\_\+\+T\+Y\+PE operator$\ast$ (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{,  }\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{ }\end{DoxyParamCaption})}



Compute the dot product on the rays. 

\begin{DoxyReturn}{Returns}
the dot product of the rays 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 235 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_gac22c25c0110c6684317aaf0e50c2e9a0}\label{group___c_l_s_solvers_gac22c25c0110c6684317aaf0e50c2e9a0}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily D\+O\+T\+P\+R\+O\+D\+\_\+\+T\+Y\+PE operator$\ast$ (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r,  }\item[{const \hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Compute the dot product between the ray and the constraint. 


\begin{DoxyParams}{Parameters}
{\em r} & a ray \\
\hline
{\em c} & a constraint \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the dot product of the ray and the constraint 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 465 of file lp\+\_\+solver.\+hpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ga240d91c518c3bfe3817504de43039022}\label{group___c_l_s_solvers_ga240d91c518c3bfe3817504de43039022}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{operator$\ast$()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily D\+O\+T\+P\+R\+O\+D\+\_\+\+T\+Y\+PE operator$\ast$ (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classconstraint}{constraint} \&}]{c,  }\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{r }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Compute the dot product between the ray and the constraint. 


\begin{DoxyParams}{Parameters}
{\em c} & a constraint \\
\hline
{\em r} & a ray \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the dot product of the ray and the constraint 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 477 of file lp\+\_\+solver.\+hpp.

\mbox{\Hypertarget{group___c_l_s_solvers_gaaa48bb668551858c8d53e230546042ba}\label{group___c_l_s_solvers_gaaa48bb668551858c8d53e230546042ba}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!operator+@{operator+}}
\index{operator+@{operator+}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{operator+()}{operator+()}}
{\footnotesize\ttfamily \hyperlink{group___c_l_s_solvers_classray}{ray} operator+ (\begin{DoxyParamCaption}\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{,  }\item[{\hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{ }\end{DoxyParamCaption})}



Add the two rays. 

\begin{DoxyReturn}{Returns}
the sum of the two rays 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 259 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_gafcb092cfc55771c4303f540cb7697a40}\label{group___c_l_s_solvers_gafcb092cfc55771c4303f540cb7697a40}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{operator-\/()}{operator-()}}
{\footnotesize\ttfamily \hyperlink{group___c_l_s_solvers_classray}{ray} operator-\/ (\begin{DoxyParamCaption}\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{,  }\item[{const \hyperlink{group___c_l_s_solvers_classray}{ray} \&}]{ }\end{DoxyParamCaption})}



Subtract the two rays. 

\begin{DoxyReturn}{Returns}
the difference of the two rays 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 270 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_gafb95c2b09dc0a5ea693a99cb8340ff28}\label{group___c_l_s_solvers_gafb95c2b09dc0a5ea693a99cb8340ff28}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!ray\+\_\+sum@{ray\+\_\+sum}}
\index{ray\+\_\+sum@{ray\+\_\+sum}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{ray\+\_\+sum()}{ray\_sum()}}
{\footnotesize\ttfamily \hyperlink{group___c_l_s_solvers_classray}{ray} ray\+\_\+sum (\begin{DoxyParamCaption}\item[{const set$<$ \hyperlink{group___c_l_s_solvers_classray}{ray} $>$ \&}]{ }\end{DoxyParamCaption})}



Add all the rays in a set. 

\begin{DoxyReturn}{Returns}
a ray that is the sum of all rays in the given set 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you\textquotesingle{}re doing. 
\end{DoxyWarning}


Definition at line 281 of file lp\+\_\+solver.\+cpp.

\mbox{\Hypertarget{group___c_l_s_solvers_ga2b6dbec1643b53f8e613b0a3de07f3ce}\label{group___c_l_s_solvers_ga2b6dbec1643b53f8e613b0a3de07f3ce}} 
\index{Constrained Linear System Solvers@{Constrained Linear System Solvers}!union\+\_\+of\+\_\+edge\+\_\+sets@{union\+\_\+of\+\_\+edge\+\_\+sets}}
\index{union\+\_\+of\+\_\+edge\+\_\+sets@{union\+\_\+of\+\_\+edge\+\_\+sets}!Constrained Linear System Solvers@{Constrained Linear System Solvers}}
\subsubsection{\texorpdfstring{union\+\_\+of\+\_\+edge\+\_\+sets()}{union\_of\_edge\_sets()}}
{\footnotesize\ttfamily set$<$\hyperlink{group___c_l_s_solvers_classedge}{edge}$>$ union\+\_\+of\+\_\+edge\+\_\+sets (\begin{DoxyParamCaption}\item[{const set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \&}]{,  }\item[{const set$<$ \hyperlink{group___c_l_s_solvers_classedge}{edge} $>$ \&}]{ }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
union of the specified edge sets 
\end{DoxyReturn}


Definition at line 342 of file skeleton.\+cpp.


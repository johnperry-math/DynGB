\hypertarget{test_f4_dynamic_8cpp-example}{}\section{test\+\_\+f4\+\_\+dynamic.\+cpp}
This illustrates ho wto compute a Gr\"{o}bner basis of the Cyclic-\/ $n$ system \[ x_1 + \cdots + x_n,\\ x_1 x_2 + x_2 x_3 + \cdots + x_n x_1,\\ x_1 x_2 x_3 + x_2 x_3 x_4 + \cdots + x_n x_1 x_2,\\ \vdots\\ x_1 \cdots x_{n-1} + x_2 \cdots x_n + \cdots + x_n x_1 \cdots x_{n-2},\\ x_1 \cdots x_n - 1 \] using this package. This version uses a hybrid version of Faug\'{e}re's F4 algorithm to take a dynamic approach\+: that is, it modifies the monomial ordering during computation of the algorithm. See \hyperlink{test__f4_8cpp_source}{test\+\_\+f4.\+cpp} for the dynamic version.


\begin{DoxyCodeInclude}
\textcolor{comment}{/*****************************************************************************\(\backslash\)}
\textcolor{comment}{* This file is part of DynGB.                                                 *}
\textcolor{comment}{*                                                                             *}
\textcolor{comment}{* DynGB is free software: you can redistribute it and/or modify               *}
\textcolor{comment}{* it under the terms of the GNU General Public License as published by        *}
\textcolor{comment}{* the Free Software Foundation, either version 2 of the License, or           *}
\textcolor{comment}{* (at your option) any later version.                                         *}
\textcolor{comment}{*                                                                             *}
\textcolor{comment}{* DynGB is distributed in the hope that it will be useful,                    *}
\textcolor{comment}{* but WITHOUT ANY WARRANTY; without even the implied warranty of              *}
\textcolor{comment}{* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *}
\textcolor{comment}{* GNU General Public License for more details.                                *}
\textcolor{comment}{*                                                                             *}
\textcolor{comment}{* You should have received a copy of the GNU General Public License           *}
\textcolor{comment}{* along with DynGB. If not, see <http://www.gnu.org/licenses/>.               *}
\textcolor{comment}{\(\backslash\)*****************************************************************************/}

\textcolor{preprocessor}{#include <set>}
\textcolor{preprocessor}{#include <cstring>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keyword}{using} std::set;
\textcolor{keyword}{using} std::cout; \textcolor{keyword}{using} std::endl;

\textcolor{preprocessor}{#include "system\_constants.hpp"}

\textcolor{preprocessor}{#include "goda.hpp"}
\textcolor{preprocessor}{#include "cyclic\_n.hpp"}
\textcolor{preprocessor}{#include "polynomial.hpp"}
\textcolor{preprocessor}{#include "strategies.hpp"}
\textcolor{preprocessor}{#include "monomial\_ordering.hpp"}
\textcolor{preprocessor}{#include "particular\_orderings.hpp"}
\textcolor{preprocessor}{#include "polynomial\_linked\_list.hpp"}
\textcolor{preprocessor}{#include "f4\_dynamic.hpp"}

\textcolor{keyword}{extern} \hyperlink{group__orderinggroup_class_monomial___ordering}{Monomial\_Ordering} * generic\_grevlex\_ptr;
\textcolor{keyword}{extern} \hyperlink{group__memorygroup_class_grading___order___data___allocator}{Grading\_Order\_Data\_Allocator<WT\_TYPE>} * 
      \hyperlink{group__memorygroup_gadf1bccf09eada41d10a5d4ceda7ca479}{goda};
\textcolor{keyword}{extern} \hyperlink{group__memorygroup_class_grading___order___data___allocator}{Grading\_Order\_Data\_Allocator<EXP\_TYPE>} * 
      \hyperlink{group__memorygroup_gaf2c367d23e09c5dad7e0273995a3304c}{moda};
\textcolor{keyword}{extern} \hyperlink{group__memorygroup_class_grading___order___data___allocator}{Grading\_Order\_Data\_Allocator<Monomial>} * 
      \hyperlink{group__memorygroup_ga76b5ae808895658b417e3f3a13c60e51}{monoda};
\textcolor{keyword}{extern} \hyperlink{group__memorygroup_class_grading___order___data___allocator}{Grading\_Order\_Data\_Allocator<Monomial\_Node>} * 
      \hyperlink{group__memorygroup_ga2b5eeb775f6c601e624b487f3245983a}{monododa};

\textcolor{comment}{// Forward declarations}
\textcolor{keywordtype}{bool} meaningful\_arguments(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char} **, \textcolor{keywordtype}{bool} &, \textcolor{keywordtype}{int} &, \textcolor{keywordtype}{int} &);

\textcolor{keywordtype}{void} give\_help();

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[]) \{
  \textcolor{keywordtype}{bool} homog;
  \textcolor{keywordtype}{int} modulus, numvars;
  \textcolor{keywordflow}{if} (not meaningful\_arguments(argc, argv, homog, modulus, numvars)) \{
    give\_help();
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordtype}{int} true\_numvars = (homog) ? numvars + 1 : numvars;
    \hyperlink{group___fields_group_class_prime___field}{Prime\_Field} FF = \hyperlink{group___fields_group_class_prime___field}{Prime\_Field}(modulus);
    \textcolor{comment}{// set up the basis}
    list<Abstract\_Polynomial *> F = \hyperlink{group__polygroup_gaa458dfbf51ecbb98f93bf8f0133725d0}{cyclic\_n}(numvars, FF, homog);
    \textcolor{comment}{// message}
    cout << \textcolor{stringliteral}{"Computing a Groebner basis for:\(\backslash\)n"};
    \textcolor{keywordflow}{for} (\hyperlink{group__polygroup_class_abstract___polynomial}{Abstract\_Polynomial} * f : F)
      cout << \textcolor{charliteral}{'\(\backslash\)t'} << *f << endl;
    \textcolor{comment}{// compute basis}
    list<Constant\_Polynomial *> G = \hyperlink{group___g_b_computation_ga24647e1e20f18283bc931e723ba9fc22}{f4\_control}(F);
    \textcolor{comment}{// display basis}
    cout << G.size() << \textcolor{stringliteral}{" polynomials in basis:\(\backslash\)n"};
    \textcolor{comment}{/*for (list<Constant\_Polynomial *>::const\_iterator g = G.begin(); g != G.end(); ++g)}
\textcolor{comment}{      cout << '\(\backslash\)t' << *(*g) << endl;*/}
    \hyperlink{group__polygroup_class_polynomial___ring}{Polynomial\_Ring} * R = & (G.front()->base\_ring());
    \textcolor{keyword}{auto} mord = G.front()->monomial\_ordering();
    cout << G.size() << \textcolor{stringliteral}{" leading monomials:\(\backslash\)n"};
    \textcolor{keywordflow}{for} (\hyperlink{group__polygroup_class_constant___polynomial}{Constant\_Polynomial} * g : G) \{
      cout << g->leading\_monomial() << \textcolor{stringliteral}{", "};
      \textcolor{keyword}{delete} g->strategy();
      \textcolor{keyword}{delete} g;
    \}
    cout << endl;
    \textcolor{keywordflow}{for} (\hyperlink{group__polygroup_class_abstract___polynomial}{Abstract\_Polynomial} * f : F) \{
      \textcolor{keyword}{delete} f->strategy();
      \textcolor{keyword}{delete} f;
    \}
    \textcolor{keyword}{delete} R;
    \textcolor{keywordflow}{if} (mord != generic\_grevlex\_ptr) \{
      \textcolor{keyword}{delete} [] (\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\hyperlink{group__orderinggroup_class_w_grevlex}{WGrevlex} *\textcolor{keyword}{>}(mord)->order\_weights());
      \textcolor{keyword}{delete} mord;
    \}
  \}
  \textcolor{keywordflow}{if} (goda != \textcolor{keyword}{nullptr}) \textcolor{keyword}{delete} \hyperlink{group__memorygroup_gadf1bccf09eada41d10a5d4ceda7ca479}{goda};
  \textcolor{keywordflow}{if} (moda != \textcolor{keyword}{nullptr}) \textcolor{keyword}{delete} \hyperlink{group__memorygroup_gaf2c367d23e09c5dad7e0273995a3304c}{moda};
  \textcolor{keywordflow}{if} (monoda != \textcolor{keyword}{nullptr}) \textcolor{keyword}{delete} \hyperlink{group__memorygroup_ga76b5ae808895658b417e3f3a13c60e51}{monoda};
  \textcolor{keywordflow}{if} (monododa != \textcolor{keyword}{nullptr}) \textcolor{keyword}{delete} \hyperlink{group__memorygroup_ga2b5eeb775f6c601e624b487f3245983a}{monododa};
  cout << \textcolor{stringliteral}{"bye\(\backslash\)n"};
\}

\textcolor{keyword}{enum} order\_flags \{ GENERIC\_GREVLEX = 0, GREVLEX, LEX, WGREVLEX \};

\textcolor{keywordtype}{bool} meaningful\_arguments(
    \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[],
    \textcolor{keywordtype}{bool} & homogeneous, \textcolor{keywordtype}{int} & modulus, \textcolor{keywordtype}{int} & numvars
) \{
  modulus = 43;
  homogeneous = \textcolor{keyword}{false};
  WT\_TYPE * weights = \textcolor{keyword}{nullptr};
  \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} order\_flag = 0;
  \textcolor{keywordtype}{bool} good\_args = (argc > 1);
  \textcolor{keywordflow}{if} (good\_args) \{
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; good\_args and i < argc; ++i) \{
      \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"hom"}) or !strcmp(argv[i],\textcolor{stringliteral}{"homog"})
          or !strcmp(argv[i],"homogeneous"))
        homogeneous = true;
      else \{
        \textcolor{keywordtype}{int} j = 0;
        \textcolor{keywordflow}{for} (\textcolor{comment}{/* */}; argv[i][j] != \textcolor{charliteral}{'='} and argv[i][j] != \textcolor{charliteral}{'\(\backslash\)0'}; ++j) \{ \textcolor{comment}{/* */} \}
        \textcolor{keywordflow}{if} (argv[i][j] != \textcolor{charliteral}{'='}) \{
          good\_args = \textcolor{keyword}{false};
          cout << \textcolor{stringliteral}{"Options must have form <option>=<value>.\(\backslash\)n"};
        \}
        \textcolor{keywordflow}{else} \{
          argv[i][j] = \textcolor{charliteral}{'\(\backslash\)0'};
          \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"n"}) or !strcmp(argv[i],\textcolor{stringliteral}{"num"})
              or !strcmp(argv[i],\textcolor{stringliteral}{"numvars"})) \{
            numvars = atoi(&(argv[i][j+1]));
            \textcolor{keywordflow}{if} (numvars < 3) \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Invalid number of variables: must be at least 3.\(\backslash\)n"};
            \}
          \}
          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"m"}) or !strcmp(argv[i],\textcolor{stringliteral}{"mod"})
                   or !strcmp(argv[i],\textcolor{stringliteral}{"modulus"}))
          \{
            modulus = atoi(&(argv[i][j+1]));
            \textcolor{keywordflow}{if} (modulus < 2) \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Invalid modulus; must be at least 2.\(\backslash\)n"};
            \}
          \}
          \textcolor{keywordflow}{else} \{
            cout << \textcolor{stringliteral}{"Unrecognized argument.\(\backslash\)n"}; good\_args = \textcolor{keyword}{false};
          \}
        \}
      \}
    \}
  \}
  \textcolor{keywordflow}{return} good\_args;
\}

\textcolor{keywordtype}{void} give\_help() \{
  cout << \textcolor{stringliteral}{"Call with options n=<num> m=<mod> [hom]\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"You *must* specify <num> vars, an integer greater than 2.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"You can add optional <mod>ulus (please make it prime).\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"The option <hom>ogenize will give you a homogenized ideal.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"So 'test\_f4 n=6 m=43' would compute the Groebner basis\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"of the Cyclic-n ideal in 6 variables, modulo 43."};
\}
\end{DoxyCodeInclude}
 
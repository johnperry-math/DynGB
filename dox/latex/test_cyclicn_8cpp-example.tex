\hypertarget{test_cyclicn_8cpp-example}{}\section{test\+\_\+cyclicn.\+cpp}
This illustrates how to compute a Gr\"{o}bner basis of the Cyclic-\/ $n$ system \[ x_1 + \cdots + x_n,\\ x_1 x_2 + x_2 x_3 + \cdots + x_n x_1,\\ x_1 x_2 x_3 + x_2 x_3 x_4 + \cdots + x_n x_1 x_2,\\ \vdots\\ x_1 \cdots x_{n-1} + x_2 \cdots x_n + \cdots + x_n x_1 \cdots x_{n-2},\\ x_1 \cdots x_n - 1 \] using this package. This version uses the {\bfseries static} Buchberger algorithm. See \hyperlink{test__dynamic_8cpp_source}{test\+\_\+dynamic.\+cpp} for the dynamic version.


\begin{DoxyCodeInclude}
\textcolor{comment}{/*****************************************************************************\(\backslash\)}
\textcolor{comment}{* This file is part of DynGB.                                                 *}
\textcolor{comment}{*                                                                             *}
\textcolor{comment}{* DynGB is free software: you can redistribute it and/or modify               *}
\textcolor{comment}{* it under the terms of the GNU General Public License as published by        *}
\textcolor{comment}{* the Free Software Foundation, either version 2 of the License, or           *}
\textcolor{comment}{* (at your option) any later version.                                         *}
\textcolor{comment}{*                                                                             *}
\textcolor{comment}{* DynGB is distributed in the hope that it will be useful,                    *}
\textcolor{comment}{* but WITHOUT ANY WARRANTY; without even the implied warranty of              *}
\textcolor{comment}{* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *}
\textcolor{comment}{* GNU General Public License for more details.                                *}
\textcolor{comment}{*                                                                             *}
\textcolor{comment}{* You should have received a copy of the GNU General Public License           *}
\textcolor{comment}{* along with DynGB. If not, see <http://www.gnu.org/licenses/>.               *}
\textcolor{comment}{\(\backslash\)*****************************************************************************/}

\textcolor{preprocessor}{#include <set>}
\textcolor{preprocessor}{#include <cstring>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keyword}{using} std::set;
\textcolor{keyword}{using} std::cout; \textcolor{keyword}{using} std::endl;

\textcolor{preprocessor}{#include "system\_constants.hpp"}

\textcolor{preprocessor}{#include "cyclic\_n.hpp"}
\textcolor{preprocessor}{#include "polynomial.hpp"}
\textcolor{preprocessor}{#include "strategies.hpp"}
\textcolor{preprocessor}{#include "monomial\_ordering.hpp"}
\textcolor{preprocessor}{#include "particular\_orderings.hpp"}
\textcolor{preprocessor}{#include "algorithm\_buchberger\_basic.hpp"}
\textcolor{preprocessor}{#include "f4\_reduction.hpp"}
\textcolor{preprocessor}{#include "algorithm\_buchberger\_explorer\_serial.hpp"}

\textcolor{keyword}{extern} \hyperlink{group__orderinggroup_class_monomial___ordering}{Monomial\_Ordering} * generic\_grevlex\_ptr;

\textcolor{comment}{// Forward declarations}
\textcolor{keywordtype}{bool} meaningful\_arguments(
    \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[], \textcolor{keywordtype}{bool} & homogeneous, \textcolor{keywordtype}{int} & modulus, \textcolor{keywordtype}{int} & numvars,
    \hyperlink{group___g_b_computation_ga73257b8a2d5cc826853a71b77d0cebf2}{SPolyCreationFlags} & method, \textcolor{keywordtype}{bool} &f4, \textcolor{keywordtype}{bool} &xplor,
    \hyperlink{group__orderinggroup_class_monomial___ordering}{Monomial\_Ordering} ** mord, \hyperlink{group__strategygroup_ga0ee6c8e033547330e6b89929730007f4}{StrategyFlags} & strategy,
    WT\_TYPE ** grading
);
\textcolor{keywordtype}{void} give\_help();

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[]) \{
  \textcolor{keywordtype}{bool} homog;
  \textcolor{keywordtype}{bool} f4 = \textcolor{keyword}{false};
  \textcolor{keywordtype}{bool} xplor = \textcolor{keyword}{false};
  \textcolor{keywordtype}{int} modulus, numvars;
  \hyperlink{group___g_b_computation_ga73257b8a2d5cc826853a71b77d0cebf2}{SPolyCreationFlags} method = SPolyCreationFlags::GEOBUCKETS;
  \hyperlink{group__strategygroup_ga0ee6c8e033547330e6b89929730007f4}{StrategyFlags} strategy = StrategyFlags::SUGAR\_STRATEGY;
  WT\_TYPE *grading;
  \hyperlink{group__orderinggroup_class_monomial___ordering}{Monomial\_Ordering} * mord = generic\_grevlex\_ptr;
  \textcolor{keywordflow}{if} (not meaningful\_arguments(
        argc, argv, homog, modulus, numvars, method, f4, xplor,
        &mord, strategy, &grading
      )) \{
    give\_help();
  \} \textcolor{keywordflow}{else} \{
    \hyperlink{group___fields_group_class_prime___field}{Prime\_Field} FF = \hyperlink{group___fields_group_class_prime___field}{Prime\_Field}(modulus);
    \textcolor{comment}{// set up the basis}
    list<Abstract\_Polynomial *> F = \hyperlink{group__polygroup_gaa458dfbf51ecbb98f93bf8f0133725d0}{cyclic\_n}(numvars, FF, homog, mord);
    \textcolor{comment}{// message}
    cout << \textcolor{stringliteral}{"Computing a Groebner basis for:\(\backslash\)n"};
    \textcolor{keywordflow}{for} (\hyperlink{group__polygroup_class_abstract___polynomial}{Abstract\_Polynomial} * f : F)
      cout << \textcolor{charliteral}{'\(\backslash\)t'} << *f << endl;
    \textcolor{comment}{// compute basis}
    \textcolor{comment}{//set<Constant\_Polynomial *, smaller\_lm> G = buchberger(F, method);}
    list<Constant\_Polynomial *> G;
    \textcolor{keywordflow}{if} (f4)
      G = \hyperlink{group___g_b_computation_ga24647e1e20f18283bc931e723ba9fc22}{f4\_control}(F);
    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (xplor)
      G = \hyperlink{group___g_b_computation_gaaaca5a3659aba7d4b3a41e253dc1a60f}{buchberger\_explorer}(F, method, strategy, grading);
    \textcolor{keywordflow}{else}
      G = \hyperlink{group___g_b_computation_ga37aa7e2fec96fac6c914934a4243f603}{buchberger}(F, method, strategy, grading);
    \textcolor{comment}{// display basis}
    cout << G.size() << \textcolor{stringliteral}{" polynomials in basis:\(\backslash\)n"};
    \textcolor{comment}{/*for (list<Constant\_Polynomial *>::const\_iterator g = G.begin(); g != G.end(); ++g)}
\textcolor{comment}{      cout << '\(\backslash\)t' << *(*g) << endl;*/}
    \hyperlink{group__polygroup_class_polynomial___ring}{Polynomial\_Ring} * R = & (G.front()->base\_ring());
    cout << G.size() << \textcolor{stringliteral}{" leading monomials:\(\backslash\)n"};
    \textcolor{keywordflow}{for} (\hyperlink{group__polygroup_class_constant___polynomial}{Constant\_Polynomial} * g : G) \{
      cout << g->leading\_monomial() << \textcolor{stringliteral}{", "};
      \textcolor{keywordtype}{bool} verbose = \textcolor{keyword}{false};
      \textcolor{keywordflow}{if} (verbose) cout << \textcolor{charliteral}{'\(\backslash\)t'} << *g << endl;
      \textcolor{keyword}{delete} g;
    \}
    \textcolor{keywordflow}{for} (\hyperlink{group__polygroup_class_abstract___polynomial}{Abstract\_Polynomial} * f : F) \textcolor{keyword}{delete} f;
    \textcolor{keyword}{delete} R;
  \}
  \textcolor{keywordflow}{if} (mord != generic\_grevlex\_ptr)
    \textcolor{keyword}{delete} mord;
  cout << \textcolor{stringliteral}{"bye\(\backslash\)n"};
\}

\textcolor{keyword}{enum} order\_flags \{ GENERIC\_GREVLEX = 0, GREVLEX, LEX, WGREVLEX \};

\textcolor{keywordtype}{bool} meaningful\_arguments(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[], \textcolor{keywordtype}{bool} & homogeneous,
                          \textcolor{keywordtype}{int} & modulus, \textcolor{keywordtype}{int} & numvars,
                          \hyperlink{group___g_b_computation_ga73257b8a2d5cc826853a71b77d0cebf2}{SPolyCreationFlags} & method, \textcolor{keywordtype}{bool} &f4, \textcolor{keywordtype}{bool} &xplor,
                          \hyperlink{group__orderinggroup_class_monomial___ordering}{Monomial\_Ordering} ** mord, 
      \hyperlink{group__strategygroup_ga0ee6c8e033547330e6b89929730007f4}{StrategyFlags} & strategy,
                          WT\_TYPE ** grading
                         )
\{
  modulus = 43;
  method = SPolyCreationFlags::LINKED\_LST;
  homogeneous = \textcolor{keyword}{false};
  WT\_TYPE * weights = \textcolor{keyword}{nullptr};
  \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} order\_flag = 0;
  \textcolor{keywordtype}{bool} good\_args = (argc > 1);
  \textcolor{keywordflow}{if} (good\_args) \{
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; good\_args and i < argc; ++i) \{
      \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"hom"}) or !strcmp(argv[i],\textcolor{stringliteral}{"homog"})
          or !strcmp(argv[i],"homogeneous"))
        homogeneous = true;
      else if (!strcmp(argv[i],"f4"))
        f4 = true;
      else if (!strcmp(argv[i],"xplor"))
        xplor = true;
      else \{
        \textcolor{keywordtype}{int} j = 0;
        \textcolor{keywordflow}{for} (\textcolor{comment}{/* */}; argv[i][j] != \textcolor{charliteral}{'='} and argv[i][j] != \textcolor{charliteral}{'\(\backslash\)0'}; ++j) \{ \textcolor{comment}{/* */} \}
        \textcolor{keywordflow}{if} (argv[i][j] != \textcolor{charliteral}{'='}) \{
          good\_args = \textcolor{keyword}{false};
          cout << \textcolor{stringliteral}{"Arguments must have form <option>=<value>.\(\backslash\)n"};
        \}
        \textcolor{keywordflow}{else} \{
          argv[i][j] = \textcolor{charliteral}{'\(\backslash\)0'};
          \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"n"}) or !strcmp(argv[i],\textcolor{stringliteral}{"num"})
              or !strcmp(argv[i],\textcolor{stringliteral}{"numvars"})) \{
            numvars = atoi(&(argv[i][j+1]));
            \textcolor{keywordflow}{if} (numvars < 3) \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Invalid number of variables: must be at least 3.\(\backslash\)n"};
            \}
          \}
          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"m"}) or !strcmp(argv[i],\textcolor{stringliteral}{"mod"})
                   or !strcmp(argv[i],\textcolor{stringliteral}{"modulus"}))
          \{
            modulus = atoi(&(argv[i][j+1]));
            \textcolor{keywordflow}{if} (modulus < 2) \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Invalid modulus; must be at least 2.\(\backslash\)n"};
            \}
          \}
          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"r"}) or !strcmp(argv[i],\textcolor{stringliteral}{"repr"})
                   or !strcmp(argv[i], \textcolor{stringliteral}{"representation"}))
          \{
            method = (\hyperlink{group___g_b_computation_ga73257b8a2d5cc826853a71b77d0cebf2}{SPolyCreationFlags} )atoi(&(argv[i][j+1]));
            \textcolor{keywordflow}{if} (
                method <= SPolyCreationFlags::MIN\_SPCREATE\_FLAG or
                method >= SPolyCreationFlags::MAX\_SPCREATE\_FLAG
            ) \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Invalid method; must be at least 1 and at most 3.\(\backslash\)n"};
            \}
          \}
          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"ord"}) or !strcmp(argv[i],\textcolor{stringliteral}{"order"})
                   or !strcmp(argv[i],"ordering"))
          \{
            \textcolor{keywordtype}{char} * request = &(argv[i][j+1]);
            \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"generic"}))
              order\_flag = GENERIC\_GREVLEX;
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"grevlex"}))
              order\_flag = GREVLEX;
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"lex"}))
              order\_flag = LEX;
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"wgrevlex"})) \{
              order\_flag = WGREVLEX;
              \textcolor{keywordtype}{unsigned} n = (homogeneous) ? numvars + 1 : numvars;
              weights = \textcolor{keyword}{new} WT\_TYPE [n];
              \textcolor{keywordtype}{unsigned} k = ++i;
              \textcolor{keywordflow}{for} (\textcolor{comment}{/* */}; k < i + n and k < argc; ++k)
                weights[k - i] = atoi(argv[k]);
              \textcolor{keywordflow}{if} (k - i < n)
                good\_args = \textcolor{keyword}{false};
              i = k;
            \}
            \textcolor{keywordflow}{else} \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Ordering must be 'generic', 'grevlex', "}
                   << \textcolor{stringliteral}{"'lex', or 'wgrevlex'.\(\backslash\)n"}
                   << \textcolor{stringliteral}{"(Matrix orderings not yet supported via command line.)\(\backslash\)n"}
                   << \textcolor{stringliteral}{"When using 'wgrevlex', follow it with a list of 'n' "}
                   << \textcolor{stringliteral}{"positive integers.\(\backslash\)n"};
            \}
          \}
          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(argv[i],\textcolor{stringliteral}{"strat"}) or !strcmp(argv[i],\textcolor{stringliteral}{"strategy"})) \{
            \textcolor{keywordtype}{char} * request = &(argv[i][j+1]);
            \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"normal"}) or !strcmp(request, \textcolor{stringliteral}{"norm"}))
              strategy = StrategyFlags::NORMAL\_STRATEGY;
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"sugar"}) or !strcmp(request, \textcolor{stringliteral}{"sug"}))
              strategy = StrategyFlags::SUGAR\_STRATEGY;
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(request, \textcolor{stringliteral}{"wsugar"}) or !strcmp(request, \textcolor{stringliteral}{"wsug"})) \{
              strategy = StrategyFlags::WSUGAR\_STRATEGY;
              \textcolor{keywordtype}{unsigned} n = (homogeneous) ? numvars + 1 : numvars;
              *grading = \textcolor{keyword}{new} WT\_TYPE [n];
              \textcolor{keywordtype}{unsigned} k = ++i;
              \textcolor{keywordflow}{for} (\textcolor{comment}{/* */}; k < i + n and k < argc; ++k)
                (*grading)[k - i] = atoi(argv[k]);
              \textcolor{keywordflow}{if} (k - i < n)
                good\_args = \textcolor{keyword}{false};
              i = k;
            \}
            \textcolor{keywordflow}{else} \{
              good\_args = \textcolor{keyword}{false};
              cout << \textcolor{stringliteral}{"Strategy must be 'normal' or 'sugar'."};
            \}
          \}
          \textcolor{keywordflow}{else} \{
            cout << \textcolor{stringliteral}{"Unrecognized argument.\(\backslash\)n"}; good\_args = \textcolor{keyword}{false};
          \}
        \}
      \}
    \}
  \}
  \textcolor{keywordflow}{if} (good\_args) \{
    \textcolor{keywordtype}{unsigned} n = (homogeneous) ? numvars + 1 : numvars;
    \textcolor{keywordflow}{switch} (order\_flag) \{
    \textcolor{keywordflow}{case} GENERIC\_GREVLEX: *mord = generic\_grevlex\_ptr; \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} GREVLEX: *mord = \textcolor{keyword}{new} \hyperlink{group__orderinggroup_class_grevlex___ordering}{Grevlex\_Ordering}(n); \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} LEX: *mord = \textcolor{keyword}{new} \hyperlink{group__orderinggroup_class_lex___ordering}{Lex\_Ordering}(n); \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} WGREVLEX: *mord = \textcolor{keyword}{new} \hyperlink{group__orderinggroup_class_cached_w_grevlex___ordering}{CachedWGrevlex\_Ordering}(n, weights); \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{default}: *mord = generic\_grevlex\_ptr;
    \}
  \}
  \textcolor{keywordflow}{return} good\_args;
\}

\textcolor{keywordtype}{void} give\_help() \{
  cout << \textcolor{stringliteral}{"Call with options n=<num> m=<mod> r=<repr>\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"You *must* specify <num> vars, an integer greater than 2.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"You can add optional <mod>ulus (please make it prime).\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"The option <hom>ogenize will give you a homogenized ideal.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"You can also select the <repr>esentation of s-polynomials:\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"\(\backslash\)t1) linked lists,\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"\(\backslash\)t2) geobuckets, or\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"\(\backslash\)t3) double-buffered polynomials.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"So 'test\_cyclicn n=6 m=43 r=2' would compute the Groebner basis\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"of the Cyclic-n ideal in 6 variables, modulo 43,"};
  cout << \textcolor{stringliteral}{"using geobuckets.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"You can also specify the strategy ('normal', 'sugar', 'wsugar')\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"('wsugar' requires a list of <num> integers, where <num> is as above,"};
  cout << \textcolor{stringliteral}{"and the term ordering ('generic', 'grevlex', 'lex', 'wgrevlex').\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"('wgrevlex' requires a list of <num> integers, where <num>"};
  cout << \textcolor{stringliteral}{" is as above.\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"The 'f4' option runs the F4 algorithm.\(\backslash\)n"};
\}
\end{DoxyCodeInclude}
 
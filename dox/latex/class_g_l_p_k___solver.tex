\hypertarget{class_g_l_p_k___solver}{}\section{G\+L\+P\+K\+\_\+\+Solver Class Reference}
\label{class_g_l_p_k___solver}\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}


approximate skeleton of a polyhedral cone, using G\+L\+PK linear solver  




{\ttfamily \#include $<$glpk\+\_\+solver.\+hpp$>$}

Inheritance diagram for G\+L\+P\+K\+\_\+\+Solver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_g_l_p_k___solver}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_a290ed6f0f6be3c6edf5ec5b5f5bfbb3a}\label{class_g_l_p_k___solver_a290ed6f0f6be3c6edf5ec5b5f5bfbb3a}} 
\hyperlink{class_g_l_p_k___solver_a290ed6f0f6be3c6edf5ec5b5f5bfbb3a}{G\+L\+P\+K\+\_\+\+Solver} (N\+V\+A\+R\+\_\+\+T\+Y\+PE n)
\begin{DoxyCompactList}\small\item\em initializes solver for $ n $ variables \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_a6cbd7db2555c39cb789fa45a8ad22f8f}\label{class_g_l_p_k___solver_a6cbd7db2555c39cb789fa45a8ad22f8f}} 
\hyperlink{class_g_l_p_k___solver_a6cbd7db2555c39cb789fa45a8ad22f8f}{G\+L\+P\+K\+\_\+\+Solver} (const \hyperlink{class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver} \&)
\begin{DoxyCompactList}\small\item\em copy constructor (deep copy) \end{DoxyCompactList}\item 
virtual bool \hyperlink{class_g_l_p_k___solver_aff3a58ef3def363dfad9e0ba8eee3e67}{copy} (const \hyperlink{class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$)
\begin{DoxyCompactList}\small\item\em performs a deep copy, similar to a copy constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Destruction}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_a4a4505a58f6d0f93a1c003797b39e468}\label{class_g_l_p_k___solver_a4a4505a58f6d0f93a1c003797b39e468}} 
{\bfseries $\sim$\+G\+L\+P\+K\+\_\+\+Solver} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properties}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_aa7ea7b9f4bb731fcb3b48991d33efe0a}\label{class_g_l_p_k___solver_aa7ea7b9f4bb731fcb3b48991d33efe0a}} 
virtual N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{class_g_l_p_k___solver_aa7ea7b9f4bb731fcb3b48991d33efe0a}{get\+\_\+dimension} () const
\begin{DoxyCompactList}\small\item\em Returns the dimension of the underlying vector space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_ae687af797043acd0e7621e75dd97b37a}\label{class_g_l_p_k___solver_ae687af797043acd0e7621e75dd97b37a}} 
virtual unsigned long \hyperlink{class_g_l_p_k___solver_ae687af797043acd0e7621e75dd97b37a}{get\+\_\+number\+\_\+of\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the number of rays defining the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_abd6239c7b6c914ba4c30e357d9fbc59c}\label{class_g_l_p_k___solver_abd6239c7b6c914ba4c30e357d9fbc59c}} 
virtual const set$<$ \hyperlink{classray}{ray} $>$ \& \hyperlink{class_g_l_p_k___solver_abd6239c7b6c914ba4c30e357d9fbc59c}{get\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the rays that define the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_a714f9e1e02b53d1a785297e86567b133}\label{class_g_l_p_k___solver_a714f9e1e02b53d1a785297e86567b133}} 
virtual unsigned long {\bfseries get\+\_\+number\+\_\+of\+\_\+constraints} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{class_g_l_p_k___solver_acb3a10f3961c65b4cf23ff61f0e2310b}{solve} (\hyperlink{classconstraint}{constraint} \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraint (singular!) and re-\/computes the solution. \end{DoxyCompactList}\item 
virtual bool \hyperlink{class_g_l_p_k___solver_a6d800f0ec270c782e3cf855aa7f59f4c}{solve} (vector$<$ \hyperlink{classconstraint}{constraint} $>$ \&)
\begin{DoxyCompactList}\small\item\em Adds the indicated constraints (plural!) and re-\/computes the solution. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Computation}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_g_l_p_k___solver_ad79040934b5bf246b24aa36f30403dce}\label{class_g_l_p_k___solver_ad79040934b5bf246b24aa36f30403dce}} 
virtual bool \hyperlink{class_g_l_p_k___solver_ad79040934b5bf246b24aa36f30403dce}{makes\+\_\+consistent\+\_\+constraint} (const \hyperlink{class_monomial}{Monomial} \&t, const \hyperlink{class_monomial}{Monomial} \&u, bool show\+\_\+data=false)
\begin{DoxyCompactList}\small\item\em tests for consistency of a constraint generated by two monomials. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
approximate skeleton of a polyhedral cone, using G\+L\+PK linear solver 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
January 2017 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class serves as an interface to G\+L\+PK \cite{glpk}, which we can use to find an approximate skeleton to a polyhedral cone. 

Definition at line 20 of file glpk\+\_\+solver.\+hpp.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_g_l_p_k___solver_aff3a58ef3def363dfad9e0ba8eee3e67}\label{class_g_l_p_k___solver_aff3a58ef3def363dfad9e0ba8eee3e67}} 
\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}!copy@{copy}}
\index{copy@{copy}!G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily bool G\+L\+P\+K\+\_\+\+Solver\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



performs a deep copy, similar to a copy constructor 

\begin{DoxyWarning}{Warning}
Do not mix-\/and-\/match solvers. At the present time, a \hyperlink{class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} is not equipped to copy a \hyperlink{class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, or vice versa. (This doesn\textquotesingle{}t even make sense between exact and approximate solvers.) 
\end{DoxyWarning}


Implements \hyperlink{class_l_p___solver_a442ad4ad67ee2feff0df49e9201d61ca}{L\+P\+\_\+\+Solver}.



Definition at line 41 of file glpk\+\_\+solver.\+cpp.

\mbox{\Hypertarget{class_g_l_p_k___solver_acb3a10f3961c65b4cf23ff61f0e2310b}\label{class_g_l_p_k___solver_acb3a10f3961c65b4cf23ff61f0e2310b}} 
\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool G\+L\+P\+K\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{\hyperlink{classconstraint}{constraint} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraint (singular!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraint is consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{class_l_p___solver_abd84374c52124116becc8924dc74e12d}{L\+P\+\_\+\+Solver}.



Definition at line 96 of file glpk\+\_\+solver.\+cpp.

\mbox{\Hypertarget{class_g_l_p_k___solver_a6d800f0ec270c782e3cf855aa7f59f4c}\label{class_g_l_p_k___solver_a6d800f0ec270c782e3cf855aa7f59f4c}} 
\index{G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!G\+L\+P\+K\+\_\+\+Solver@{G\+L\+P\+K\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool G\+L\+P\+K\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{vector$<$ \hyperlink{classconstraint}{constraint} $>$ \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Adds the indicated constraints (plural!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraints are consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implements \hyperlink{class_l_p___solver_a35da4bdf5db971c445f495b6eaab072d}{L\+P\+\_\+\+Solver}.



Definition at line 65 of file glpk\+\_\+solver.\+cpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
glpk\+\_\+solver.\+hpp\item 
glpk\+\_\+solver.\+cpp\end{DoxyCompactItemize}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gröbner basis project: LP_Solvers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gröbner basis project
   </div>
   <div id="projectbrief">Codebase for research into Gröbner basis computation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_l_p___solvers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LP_Solvers Namespace Reference<div class="ingroups"><a class="el" href="group___c_l_s_solvers.html">Constrained Linear System Solvers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>classes that solve constrained linear systems  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:class_l_p___solvers_1_1_constraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">a constraint \( c_1 x_1 + \ldots + c_n x_n \geq 0 \)  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_edge"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_edge"><td class="mdescLeft">&#160;</td><td class="mdescRight">an edge \((r_1,r_2)\) connecting the two rays \( r_1 \) and \( r_2 \)  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_edge"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_g_l_p_k___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver">GLPK_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_g_l_p_k___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximate skeleton of a polyhedral cone, using GLPK linear solver  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_g_l_p_k___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_l_p___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_l_p___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">exact or approximate polyhedral cone solution, with methods allowing definition and refinement  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_l_p___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_p_p_l___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver">PPL_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_p_p_l___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximate skeleton of a polyhedral cone, using PPL linear solver  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_p_p_l___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_ray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_ray"><td class="mdescLeft">&#160;</td><td class="mdescRight">a ray defined by nonnegative coordinates \((a_1,\ldots,a_n)\)  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_ray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_skeleton"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_skeleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">skeleton of a polyhedral cone, with methods allowing definition and refinement  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_skeleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a79355cedbe1e86a93a1d5673b7081f0d"><td class="memItemLeft" align="right" valign="top"><a id="a79355cedbe1e86a93a1d5673b7081f0d"></a>
typedef PPL::Constraint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a79355cedbe1e86a93a1d5673b7081f0d">PPL_Constraint</a></td></tr>
<tr class="memdesc:a79355cedbe1e86a93a1d5673b7081f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorthand for <code>PPL::Constraint</code> <br /></td></tr>
<tr class="separator:a79355cedbe1e86a93a1d5673b7081f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3683d6db493de447cbed079aa8f8a36"><td class="memItemLeft" align="right" valign="top"><a id="af3683d6db493de447cbed079aa8f8a36"></a>
typedef PPL::Generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#af3683d6db493de447cbed079aa8f8a36">PPL_Generator</a></td></tr>
<tr class="memdesc:af3683d6db493de447cbed079aa8f8a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorthand for <code>PPL::Generator</code> <br /></td></tr>
<tr class="separator:af3683d6db493de447cbed079aa8f8a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3434d5c281c16ef7a09d8f73445ea00"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf3434d5c281c16ef7a09d8f73445ea00">intersections_of_active_constraints</a> (bool *, bool *, unsigned)</td></tr>
<tr class="memdesc:gaf3434d5c281c16ef7a09d8f73445ea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates which constraints are active for both sets  <a href="group___c_l_s_solvers.html#gaf3434d5c281c16ef7a09d8f73445ea00">More...</a><br /></td></tr>
<tr class="separator:gaf3434d5c281c16ef7a09d8f73445ea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f87ac127ced7d681b3e51e38eef0cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga1f87ac127ced7d681b3e51e38eef0cf4">intersections_of_active_constraints</a> (bool *a, bool *b, bool *result, unsigned m)</td></tr>
<tr class="memdesc:ga1f87ac127ced7d681b3e51e38eef0cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates which constraints are active for both sets  <a href="group___c_l_s_solvers.html#ga1f87ac127ced7d681b3e51e38eef0cf4">More...</a><br /></td></tr>
<tr class="separator:ga1f87ac127ced7d681b3e51e38eef0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a997634a9b11bec9c54d0243ac29008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga0a997634a9b11bec9c54d0243ac29008">is_first_subset_of_second</a> (bool *, bool *, unsigned)</td></tr>
<tr class="memdesc:ga0a997634a9b11bec9c54d0243ac29008"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether the first set of active constraints is a subset of the second  <a href="group___c_l_s_solvers.html#ga0a997634a9b11bec9c54d0243ac29008">More...</a><br /></td></tr>
<tr class="separator:ga0a997634a9b11bec9c54d0243ac29008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad030de457424bef601e2903eb619926e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gad030de457424bef601e2903eb619926e">number_of_common_constraints</a> (bool *, bool *, unsigned)</td></tr>
<tr class="memdesc:gad030de457424bef601e2903eb619926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">counts the number of constraints active in both sets  <a href="group___c_l_s_solvers.html#gad030de457424bef601e2903eb619926e">More...</a><br /></td></tr>
<tr class="separator:gad030de457424bef601e2903eb619926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c6d0c3337c5bc3379a273ec332ba5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a49c6d0c3337c5bc3379a273ec332ba5c">operator!=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;b)</td></tr>
<tr class="memdesc:a49c6d0c3337c5bc3379a273ec332ba5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint inequality  <a href="#a49c6d0c3337c5bc3379a273ec332ba5c">More...</a><br /></td></tr>
<tr class="separator:a49c6d0c3337c5bc3379a273ec332ba5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a1994c15aacbfd4215abf13fdf1e6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a20a1994c15aacbfd4215abf13fdf1e6d">operator!=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;b)</td></tr>
<tr class="memdesc:a20a1994c15aacbfd4215abf13fdf1e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the two rays are unequal.  <a href="#a20a1994c15aacbfd4215abf13fdf1e6d">More...</a><br /></td></tr>
<tr class="separator:a20a1994c15aacbfd4215abf13fdf1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71a7e68f920518b02b6a58660594ca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf71a7e68f920518b02b6a58660594ca2">operator*</a> (const RAYENT_TYPE, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gaf71a7e68f920518b02b6a58660594ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply every coordinate in the given ray by the given scalar.  <a href="group___c_l_s_solvers.html#gaf71a7e68f920518b02b6a58660594ca2">More...</a><br /></td></tr>
<tr class="separator:gaf71a7e68f920518b02b6a58660594ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1f5d07b6d0f4c12b4c7835977b64eb"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaae1f5d07b6d0f4c12b4c7835977b64eb">operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gaae1f5d07b6d0f4c12b4c7835977b64eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product on the rays.  <a href="group___c_l_s_solvers.html#gaae1f5d07b6d0f4c12b4c7835977b64eb">More...</a><br /></td></tr>
<tr class="separator:gaae1f5d07b6d0f4c12b4c7835977b64eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4f6991b325c2a42e1f14fc09346277"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga9b4f6991b325c2a42e1f14fc09346277">operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const vector&lt; long &gt; &amp;)</td></tr>
<tr class="memdesc:ga9b4f6991b325c2a42e1f14fc09346277"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the dot product of the specified rays, one of which is a vector  <a href="group___c_l_s_solvers.html#ga9b4f6991b325c2a42e1f14fc09346277">More...</a><br /></td></tr>
<tr class="separator:ga9b4f6991b325c2a42e1f14fc09346277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64c33abcc54e5b175b7b567e099c75b"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gab64c33abcc54e5b175b7b567e099c75b">operator*</a> (const vector&lt; long &gt; &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gab64c33abcc54e5b175b7b567e099c75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the dot product of the specified rays, one of which is a vector  <a href="group___c_l_s_solvers.html#gab64c33abcc54e5b175b7b567e099c75b">More...</a><br /></td></tr>
<tr class="separator:gab64c33abcc54e5b175b7b567e099c75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea75db1559315f35242d62e9e5f66e92"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaea75db1559315f35242d62e9e5f66e92">operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;r, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c)</td></tr>
<tr class="memdesc:gaea75db1559315f35242d62e9e5f66e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between the ray and the constraint.  <a href="group___c_l_s_solvers.html#gaea75db1559315f35242d62e9e5f66e92">More...</a><br /></td></tr>
<tr class="separator:gaea75db1559315f35242d62e9e5f66e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f83e5d45bfc080fbffde26ebb93892"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf9f83e5d45bfc080fbffde26ebb93892">operator*</a> (<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c, <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;r)</td></tr>
<tr class="memdesc:gaf9f83e5d45bfc080fbffde26ebb93892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between the ray and the constraint.  <a href="group___c_l_s_solvers.html#gaf9f83e5d45bfc080fbffde26ebb93892">More...</a><br /></td></tr>
<tr class="separator:gaf9f83e5d45bfc080fbffde26ebb93892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf293c6d803dc697897463525aa1d1d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf293c6d803dc697897463525aa1d1d44">operator+</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gaf293c6d803dc697897463525aa1d1d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the two rays.  <a href="group___c_l_s_solvers.html#gaf293c6d803dc697897463525aa1d1d44">More...</a><br /></td></tr>
<tr class="separator:gaf293c6d803dc697897463525aa1d1d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20f6443d37909c326bb31c0399ea634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gac20f6443d37909c326bb31c0399ea634">operator-</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gac20f6443d37909c326bb31c0399ea634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the two rays.  <a href="group___c_l_s_solvers.html#gac20f6443d37909c326bb31c0399ea634">More...</a><br /></td></tr>
<tr class="separator:gac20f6443d37909c326bb31c0399ea634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f6cde3df8ed19a4195584ace43c9d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a28f6cde3df8ed19a4195584ace43c9d9">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;b)</td></tr>
<tr class="memdesc:a28f6cde3df8ed19a4195584ace43c9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of constraints.  <a href="#a28f6cde3df8ed19a4195584ace43c9d9">More...</a><br /></td></tr>
<tr class="separator:a28f6cde3df8ed19a4195584ace43c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa582ccdb98a58f0c688aefa89bb7cdf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#aa582ccdb98a58f0c688aefa89bb7cdf1">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e1, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:aa582ccdb98a58f0c688aefa89bb7cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two edges lexicographically.  <a href="#aa582ccdb98a58f0c688aefa89bb7cdf1">More...</a><br /></td></tr>
<tr class="separator:aa582ccdb98a58f0c688aefa89bb7cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28498e1aa874114a1ae27876d309b0d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a28498e1aa874114a1ae27876d309b0d1">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;b)</td></tr>
<tr class="memdesc:a28498e1aa874114a1ae27876d309b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of rays.  <a href="#a28498e1aa874114a1ae27876d309b0d1">More...</a><br /></td></tr>
<tr class="separator:a28498e1aa874114a1ae27876d309b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839482d44b36df2b4b70e5ab99662e45"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a839482d44b36df2b4b70e5ab99662e45">operator&lt;&lt;</a> (ostream &amp;ostr, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e)</td></tr>
<tr class="memdesc:a839482d44b36df2b4b70e5ab99662e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output has the form \( \{ \mathbf{r}_1, \mathbf{r}_2 \} \) where \( \mathbf{r}_1 \) is the first ray in this edge, etc.  <a href="#a839482d44b36df2b4b70e5ab99662e45">More...</a><br /></td></tr>
<tr class="separator:a839482d44b36df2b4b70e5ab99662e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62089e763b2d098ba78d6f25b296d1a"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#aa62089e763b2d098ba78d6f25b296d1a">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c)</td></tr>
<tr class="memdesc:aa62089e763b2d098ba78d6f25b296d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a representation of the constraint to the stream  <a href="#aa62089e763b2d098ba78d6f25b296d1a">More...</a><br /></td></tr>
<tr class="separator:aa62089e763b2d098ba78d6f25b296d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4d40aebb685ca6ddc48f91939bb523"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a7f4d40aebb685ca6ddc48f91939bb523">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;r)</td></tr>
<tr class="memdesc:a7f4d40aebb685ca6ddc48f91939bb523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is of the form \((r_1, \ldots, r_n)\).  <a href="#a7f4d40aebb685ca6ddc48f91939bb523">More...</a><br /></td></tr>
<tr class="separator:a7f4d40aebb685ca6ddc48f91939bb523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd12afffaacd4070fc0aa3b1297d47d"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#afdd12afffaacd4070fc0aa3b1297d47d">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;s)</td></tr>
<tr class="memdesc:afdd12afffaacd4070fc0aa3b1297d47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints out the constraints, then the rays, then the edges of <code>s</code>.  <a href="#afdd12afffaacd4070fc0aa3b1297d47d">More...</a><br /></td></tr>
<tr class="separator:afdd12afffaacd4070fc0aa3b1297d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4058fe5f5231e90bf5f864c8cc06f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a4f4058fe5f5231e90bf5f864c8cc06f2">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e1, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:a4f4058fe5f5231e90bf5f864c8cc06f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal if and only if.  <a href="#a4f4058fe5f5231e90bf5f864c8cc06f2">More...</a><br /></td></tr>
<tr class="separator:a4f4058fe5f5231e90bf5f864c8cc06f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac547de44c030843952f4dd715accaf1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#ac547de44c030843952f4dd715accaf1d">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;b)</td></tr>
<tr class="memdesc:ac547de44c030843952f4dd715accaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint equality  <a href="#ac547de44c030843952f4dd715accaf1d">More...</a><br /></td></tr>
<tr class="separator:ac547de44c030843952f4dd715accaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda74dc37387f370329de0f20b63f124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#abda74dc37387f370329de0f20b63f124">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;b)</td></tr>
<tr class="memdesc:abda74dc37387f370329de0f20b63f124"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether the two rays are equal  <a href="#abda74dc37387f370329de0f20b63f124">More...</a><br /></td></tr>
<tr class="separator:abda74dc37387f370329de0f20b63f124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1accee51d4f9339ef83bf93d653544"><td class="memItemLeft" align="right" valign="top">DEG_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a7e1accee51d4f9339ef83bf93d653544">ray_data_allocation</a> (NVAR_TYPE n)</td></tr>
<tr class="memdesc:a7e1accee51d4f9339ef83bf93d653544"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates data for a ray  <a href="#a7e1accee51d4f9339ef83bf93d653544">More...</a><br /></td></tr>
<tr class="separator:a7e1accee51d4f9339ef83bf93d653544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f6aa14b6c3adb4df26f8338d486401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga42f6aa14b6c3adb4df26f8338d486401">ray_sum</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ga42f6aa14b6c3adb4df26f8338d486401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the rays in a set.  <a href="group___c_l_s_solvers.html#ga42f6aa14b6c3adb4df26f8338d486401">More...</a><br /></td></tr>
<tr class="separator:ga42f6aa14b6c3adb4df26f8338d486401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b57096f9dac0f00912dd248cfdc89db"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga8b57096f9dac0f00912dd248cfdc89db">union_of_edge_sets</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; &amp;, const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ga8b57096f9dac0f00912dd248cfdc89db"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the union of the specified edge sets  <a href="group___c_l_s_solvers.html#ga8b57096f9dac0f00912dd248cfdc89db">More...</a><br /></td></tr>
<tr class="separator:ga8b57096f9dac0f00912dd248cfdc89db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0dc763860167cb9a6e5c84bfda9a456e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memorygroup.html#class_grading___order___data___allocator">Grading_Order_Data_Allocator</a>&lt; DEG_TYPE &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memorygroup.html#ga0dc763860167cb9a6e5c84bfda9a456e">doda</a> = nullptr</td></tr>
<tr class="memdesc:ga0dc763860167cb9a6e5c84bfda9a456e"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory manager for ray entries  <a href="group__memorygroup.html#ga0dc763860167cb9a6e5c84bfda9a456e">More...</a><br /></td></tr>
<tr class="separator:ga0dc763860167cb9a6e5c84bfda9a456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389e3d1ce5c76dad0e21f232ab720a84"><td class="memItemLeft" align="right" valign="top"><a id="a389e3d1ce5c76dad0e21f232ab720a84"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html#a389e3d1ce5c76dad0e21f232ab720a84">invocations</a> = 0</td></tr>
<tr class="memdesc:a389e3d1ce5c76dad0e21f232ab720a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to count the number of invocations of <a class="el" href="namespace_l_p___solvers.html#a7e1accee51d4f9339ef83bf93d653544" title="allocates data for a ray ">ray_data_allocation()</a> <br /></td></tr>
<tr class="separator:a389e3d1ce5c76dad0e21f232ab720a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>classes that solve constrained linear systems </p>
<p>Classes in this group solve constrained linear systems; that is, they solve systems of the form \(\left\{\sum_{j=1}^na_{ij}x_j\leq b_i\right\}_{i=1}^m\) (where the inequality may or may not be strict). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a49c6d0c3337c5bc3379a273ec332ba5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c6d0c3337c5bc3379a273ec332ba5c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check for constraint inequality </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first constraint </td></tr>
    <tr><td class="paramname">b</td><td>second constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> and <code>b</code> have different entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00083">83</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a20a1994c15aacbfd4215abf13fdf1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a1994c15aacbfd4215abf13fdf1e6d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the two rays are unequal. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first ray </td></tr>
    <tr><td class="paramname">b</td><td>second ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the rays&rsquo; entries have different values</dd></dl>
<p>Notice that the rays can point in the same direction, but still be considered unequal. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00323">323</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a28f6cde3df8ed19a4195584ace43c9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f6cde3df8ed19a4195584ace43c9d9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographic comparison of constraints. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first constraint </td></tr>
    <tr><td class="paramname">b</td><td>second constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> and <code>b</code> have different entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00060">60</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="aa582ccdb98a58f0c688aefa89bb7cdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa582ccdb98a58f0c688aefa89bb7cdf1">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two edges lexicographically. </p>
<p>If the first ray in <code>this</code> edge is smaller, then <code>this</code> edge is smaller. Otherwise, if the first rays are equal, and the second ray in <code>this</code> edge is smaller, then <code>this</code> edge is smaller.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the first edge is lexicographically smaller</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>an edge </td></tr>
    <tr><td class="paramname">e2</td><td>an edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00063">63</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a28498e1aa874114a1ae27876d309b0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28498e1aa874114a1ae27876d309b0d1">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographic comparison of rays. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first ray </td></tr>
    <tr><td class="paramname">b</td><td>second ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> is lexicographically smaller than <code>b</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00371">371</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a839482d44b36df2b4b70e5ab99662e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839482d44b36df2b4b70e5ab99662e45">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; LP_Solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output has the form \( \{ \mathbf{r}_1, \mathbf{r}_2 \} \) where \( \mathbf{r}_1 \) is the first ray in this edge, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>output stream to write to </td></tr>
    <tr><td class="paramname">e</td><td>edge to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00054">54</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="aa62089e763b2d098ba78d6f25b296d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62089e763b2d098ba78d6f25b296d1a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; LP_Solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print a representation of the constraint to the stream </p>
<p>Output is of the form \( c_1 x_1 + \ldots + c_n x_n \) , where \( c_i \) is the coefficient of \( x_i \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">c</td><td>constraint to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00093">93</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a7f4d40aebb685ca6ddc48f91939bb523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4d40aebb685ca6ddc48f91939bb523">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; LP_Solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output is of the form \((r_1, \ldots, r_n)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">r</td><td>ray to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00331">331</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="afdd12afffaacd4070fc0aa3b1297d47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd12afffaacd4070fc0aa3b1297d47d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; LP_Solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints out the constraints, then the rays, then the edges of <code>s</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream to print to </td></tr>
    <tr><td class="paramname">s</td><td>skeleton to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00440">440</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a4f4058fe5f5231e90bf5f864c8cc06f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4058fe5f5231e90bf5f864c8cc06f2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equal if and only if. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>an edge </td></tr>
    <tr><td class="paramname">e2</td><td>an edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the edges have identical entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00060">60</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="ac547de44c030843952f4dd715accaf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac547de44c030843952f4dd715accaf1d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check for constraint equality </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first constraint </td></tr>
    <tr><td class="paramname">b</td><td>second constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> and <code>b</code> have the same entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00073">73</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="abda74dc37387f370329de0f20b63f124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda74dc37387f370329de0f20b63f124">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicates whether the two rays are equal </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first ray </td></tr>
    <tr><td class="paramname">b</td><td>second ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the rays&rsquo; entries have the same values</dd></dl>
<p>Notice that the rays can point in the same direction, but still be considered unequal. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00315">315</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a7e1accee51d4f9339ef83bf93d653544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1accee51d4f9339ef83bf93d653544">&#9670;&nbsp;</a></span>ray_data_allocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEG_TYPE* LP_Solvers::ray_data_allocation </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocates data for a ray </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of entries needed for the ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new block of memory for a ray </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00138">138</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_l_p___solvers.html">LP_Solvers</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

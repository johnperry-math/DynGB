<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gröbner basis project: Constrained Linear System Solvers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gröbner basis project
   </div>
   <div id="projectbrief">Codebase for research into Gröbner basis computation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___c_l_s_solvers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Constrained Linear System Solvers</div>  </div>
</div><!--header-->
<div class="contents">

<p>classes that solve constrained linear systems  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_l_p___solvers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_l_p___solvers.html">LP_Solvers</a></td></tr>
<tr class="memdesc:namespace_l_p___solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">classes that solve constrained linear systems <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:class_l_p___solvers_1_1_constraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">LP_Solvers::Constraint</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">a constraint \( c_1 x_1 + \ldots + c_n x_n \geq 0 \)  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_edge"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">LP_Solvers::Edge</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_edge"><td class="mdescLeft">&#160;</td><td class="mdescRight">an edge \((r_1,r_2)\) connecting the two rays \( r_1 \) and \( r_2 \)  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_edge"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_g_l_p_k___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver">LP_Solvers::GLPK_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_g_l_p_k___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximate skeleton of a polyhedral cone, using GLPK linear solver  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_g_l_p_k___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_l_p___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_l_p___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">exact or approximate polyhedral cone solution, with methods allowing definition and refinement  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_l_p___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_p_p_l___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver">LP_Solvers::PPL_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_p_p_l___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximate skeleton of a polyhedral cone, using PPL linear solver  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_p_p_l___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_ray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">LP_Solvers::Ray</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_ray"><td class="mdescLeft">&#160;</td><td class="mdescRight">a ray defined by nonnegative coordinates \((a_1,\ldots,a_n)\)  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_ray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solvers_1_1_skeleton"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">LP_Solvers::Skeleton</a></td></tr>
<tr class="memdesc:class_l_p___solvers_1_1_skeleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">skeleton of a polyhedral cone, with methods allowing definition and refinement  <a href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solvers_1_1_skeleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3434d5c281c16ef7a09d8f73445ea00"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf3434d5c281c16ef7a09d8f73445ea00">LP_Solvers::intersections_of_active_constraints</a> (bool *, bool *, unsigned)</td></tr>
<tr class="memdesc:gaf3434d5c281c16ef7a09d8f73445ea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates which constraints are active for both sets  <a href="group___c_l_s_solvers.html#gaf3434d5c281c16ef7a09d8f73445ea00">More...</a><br /></td></tr>
<tr class="separator:gaf3434d5c281c16ef7a09d8f73445ea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f87ac127ced7d681b3e51e38eef0cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga1f87ac127ced7d681b3e51e38eef0cf4">LP_Solvers::intersections_of_active_constraints</a> (bool *a, bool *b, bool *result, unsigned m)</td></tr>
<tr class="memdesc:ga1f87ac127ced7d681b3e51e38eef0cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates which constraints are active for both sets  <a href="group___c_l_s_solvers.html#ga1f87ac127ced7d681b3e51e38eef0cf4">More...</a><br /></td></tr>
<tr class="separator:ga1f87ac127ced7d681b3e51e38eef0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a997634a9b11bec9c54d0243ac29008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga0a997634a9b11bec9c54d0243ac29008">LP_Solvers::is_first_subset_of_second</a> (bool *, bool *, unsigned)</td></tr>
<tr class="memdesc:ga0a997634a9b11bec9c54d0243ac29008"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether the first set of active constraints is a subset of the second  <a href="group___c_l_s_solvers.html#ga0a997634a9b11bec9c54d0243ac29008">More...</a><br /></td></tr>
<tr class="separator:ga0a997634a9b11bec9c54d0243ac29008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad030de457424bef601e2903eb619926e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gad030de457424bef601e2903eb619926e">LP_Solvers::number_of_common_constraints</a> (bool *, bool *, unsigned)</td></tr>
<tr class="memdesc:gad030de457424bef601e2903eb619926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">counts the number of constraints active in both sets  <a href="group___c_l_s_solvers.html#gad030de457424bef601e2903eb619926e">More...</a><br /></td></tr>
<tr class="separator:gad030de457424bef601e2903eb619926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71a7e68f920518b02b6a58660594ca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf71a7e68f920518b02b6a58660594ca2">LP_Solvers::operator*</a> (const RAYENT_TYPE, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gaf71a7e68f920518b02b6a58660594ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply every coordinate in the given ray by the given scalar.  <a href="group___c_l_s_solvers.html#gaf71a7e68f920518b02b6a58660594ca2">More...</a><br /></td></tr>
<tr class="separator:gaf71a7e68f920518b02b6a58660594ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1f5d07b6d0f4c12b4c7835977b64eb"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaae1f5d07b6d0f4c12b4c7835977b64eb">LP_Solvers::operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gaae1f5d07b6d0f4c12b4c7835977b64eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product on the rays.  <a href="group___c_l_s_solvers.html#gaae1f5d07b6d0f4c12b4c7835977b64eb">More...</a><br /></td></tr>
<tr class="separator:gaae1f5d07b6d0f4c12b4c7835977b64eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4f6991b325c2a42e1f14fc09346277"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga9b4f6991b325c2a42e1f14fc09346277">LP_Solvers::operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const vector&lt; long &gt; &amp;)</td></tr>
<tr class="memdesc:ga9b4f6991b325c2a42e1f14fc09346277"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the dot product of the specified rays, one of which is a vector  <a href="group___c_l_s_solvers.html#ga9b4f6991b325c2a42e1f14fc09346277">More...</a><br /></td></tr>
<tr class="separator:ga9b4f6991b325c2a42e1f14fc09346277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64c33abcc54e5b175b7b567e099c75b"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gab64c33abcc54e5b175b7b567e099c75b">LP_Solvers::operator*</a> (const vector&lt; long &gt; &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gab64c33abcc54e5b175b7b567e099c75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the dot product of the specified rays, one of which is a vector  <a href="group___c_l_s_solvers.html#gab64c33abcc54e5b175b7b567e099c75b">More...</a><br /></td></tr>
<tr class="separator:gab64c33abcc54e5b175b7b567e099c75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea75db1559315f35242d62e9e5f66e92"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaea75db1559315f35242d62e9e5f66e92">LP_Solvers::operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;r, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c)</td></tr>
<tr class="memdesc:gaea75db1559315f35242d62e9e5f66e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between the ray and the constraint.  <a href="group___c_l_s_solvers.html#gaea75db1559315f35242d62e9e5f66e92">More...</a><br /></td></tr>
<tr class="separator:gaea75db1559315f35242d62e9e5f66e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f83e5d45bfc080fbffde26ebb93892"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf9f83e5d45bfc080fbffde26ebb93892">LP_Solvers::operator*</a> (<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c, <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;r)</td></tr>
<tr class="memdesc:gaf9f83e5d45bfc080fbffde26ebb93892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between the ray and the constraint.  <a href="group___c_l_s_solvers.html#gaf9f83e5d45bfc080fbffde26ebb93892">More...</a><br /></td></tr>
<tr class="separator:gaf9f83e5d45bfc080fbffde26ebb93892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf293c6d803dc697897463525aa1d1d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaf293c6d803dc697897463525aa1d1d44">LP_Solvers::operator+</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gaf293c6d803dc697897463525aa1d1d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the two rays.  <a href="group___c_l_s_solvers.html#gaf293c6d803dc697897463525aa1d1d44">More...</a><br /></td></tr>
<tr class="separator:gaf293c6d803dc697897463525aa1d1d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20f6443d37909c326bb31c0399ea634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gac20f6443d37909c326bb31c0399ea634">LP_Solvers::operator-</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:gac20f6443d37909c326bb31c0399ea634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the two rays.  <a href="group___c_l_s_solvers.html#gac20f6443d37909c326bb31c0399ea634">More...</a><br /></td></tr>
<tr class="separator:gac20f6443d37909c326bb31c0399ea634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f6aa14b6c3adb4df26f8338d486401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga42f6aa14b6c3adb4df26f8338d486401">LP_Solvers::ray_sum</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ga42f6aa14b6c3adb4df26f8338d486401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the rays in a set.  <a href="group___c_l_s_solvers.html#ga42f6aa14b6c3adb4df26f8338d486401">More...</a><br /></td></tr>
<tr class="separator:ga42f6aa14b6c3adb4df26f8338d486401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b57096f9dac0f00912dd248cfdc89db"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga8b57096f9dac0f00912dd248cfdc89db">LP_Solvers::union_of_edge_sets</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; &amp;, const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ga8b57096f9dac0f00912dd248cfdc89db"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the union of the specified edge sets  <a href="group___c_l_s_solvers.html#ga8b57096f9dac0f00912dd248cfdc89db">More...</a><br /></td></tr>
<tr class="separator:ga8b57096f9dac0f00912dd248cfdc89db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>classes that solve constrained linear systems </p>
<p>Classes in this group solve constrained linear systems; that is, they solve systems of the form \(\left\{\sum_{j=1}^na_{ij}x_j\leq b_i\right\}_{i=1}^m\) (where the inequality may or may not be strict). </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="class_l_p___solvers_1_1_constraint" id="class_l_p___solvers_1_1_constraint"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_constraint">&#9670;&nbsp;</a></span>LP_Solvers::Constraint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::Constraint</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>a constraint \( c_1 x_1 + \ldots + c_n x_n \geq 0 \) </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates a simple constraint for a skeleton; that is, an inequality of the form \( c_1 x_1 + \ldots + c_n x_n \geq 0 \). Constraints can be ordered lexicographically using the less-than operator, allowing for their inclusion in ordered collections, such as sets. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00072">72</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a461ed6a3396f874d12b2aec6996180d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a461ed6a3396f874d12b2aec6996180d9">Constraint</a> (NVAR_TYPE, CONSTR_TYPE [])</td></tr>
<tr class="memdesc:a461ed6a3396f874d12b2aec6996180d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize constraint to the given coefficients.  <a href="#a461ed6a3396f874d12b2aec6996180d9">More...</a><br /></td></tr>
<tr class="separator:a461ed6a3396f874d12b2aec6996180d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc362e0473a75944d6b8830f6dc33846"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#abc362e0473a75944d6b8830f6dc33846">Constraint</a> (vector&lt; CONSTR_TYPE &gt; &amp;)</td></tr>
<tr class="memdesc:abc362e0473a75944d6b8830f6dc33846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize constraint to the given coefficients.  <a href="#abc362e0473a75944d6b8830f6dc33846">More...</a><br /></td></tr>
<tr class="separator:abc362e0473a75944d6b8830f6dc33846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfc403f974d4749f133aebdc6f1fb63"><td class="memItemLeft" align="right" valign="top"><a id="aacfc403f974d4749f133aebdc6f1fb63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aacfc403f974d4749f133aebdc6f1fb63">Constraint</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;)</td></tr>
<tr class="memdesc:aacfc403f974d4749f133aebdc6f1fb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the coefficients of the other constraint, including the allocation of new memory. <br /></td></tr>
<tr class="separator:aacfc403f974d4749f133aebdc6f1fb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a2949083e68c41842b613bd8cf78c6389"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a2949083e68c41842b613bd8cf78c6389">~Constraint</a> ()</td></tr>
<tr class="memdesc:a2949083e68c41842b613bd8cf78c6389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes memory allocated by the constructor.  <a href="#a2949083e68c41842b613bd8cf78c6389">More...</a><br /></td></tr>
<tr class="separator:a2949083e68c41842b613bd8cf78c6389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:a10b3789ede36e0b614fb76fbe0248476"><td class="memItemLeft" align="right" valign="top"><a id="a10b3789ede36e0b614fb76fbe0248476"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a10b3789ede36e0b614fb76fbe0248476">get_number_of_variables</a> () const</td></tr>
<tr class="memdesc:a10b3789ede36e0b614fb76fbe0248476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables in the constraint. <br /></td></tr>
<tr class="separator:a10b3789ede36e0b614fb76fbe0248476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286fb7825aa45114478110e17bef1ccc"><td class="memItemLeft" align="right" valign="top"><a id="a286fb7825aa45114478110e17bef1ccc"></a>
CONSTR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a286fb7825aa45114478110e17bef1ccc">operator[]</a> (NVAR_TYPE index) const</td></tr>
<tr class="memdesc:a286fb7825aa45114478110e17bef1ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficient indicated. Numbering starts at 0. <br /></td></tr>
<tr class="separator:a286fb7825aa45114478110e17bef1ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6dd23c317ce6865167b30d1d75de19"><td class="memItemLeft" align="right" valign="top"><a id="a4e6dd23c317ce6865167b30d1d75de19"></a>
const CONSTR_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4e6dd23c317ce6865167b30d1d75de19">coeffs</a> () const</td></tr>
<tr class="memdesc:a4e6dd23c317ce6865167b30d1d75de19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficients that determine this constraints. <br /></td></tr>
<tr class="separator:a4e6dd23c317ce6865167b30d1d75de19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons</div></td></tr>
<tr class="memitem:ad7246226080bd15a0d477cd905b4b71c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad7246226080bd15a0d477cd905b4b71c">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;b)</td></tr>
<tr class="memdesc:ad7246226080bd15a0d477cd905b4b71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of constraints.  <a href="#ad7246226080bd15a0d477cd905b4b71c">More...</a><br /></td></tr>
<tr class="separator:ad7246226080bd15a0d477cd905b4b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9411a8f6505608b523a4d5f28014d4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a9411a8f6505608b523a4d5f28014d4c2">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;b)</td></tr>
<tr class="memdesc:a9411a8f6505608b523a4d5f28014d4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint equality  <a href="#a9411a8f6505608b523a4d5f28014d4c2">More...</a><br /></td></tr>
<tr class="separator:a9411a8f6505608b523a4d5f28014d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67011dc88bf8927d50bf3806e792f8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ab67011dc88bf8927d50bf3806e792f8b">operator!=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;b)</td></tr>
<tr class="memdesc:ab67011dc88bf8927d50bf3806e792f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint inequality  <a href="#ab67011dc88bf8927d50bf3806e792f8b">More...</a><br /></td></tr>
<tr class="separator:ab67011dc88bf8927d50bf3806e792f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a7233f9b589a413e310991431039b05b6"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7233f9b589a413e310991431039b05b6">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c)</td></tr>
<tr class="memdesc:a7233f9b589a413e310991431039b05b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a representation of the constraint to the stream  <a href="#a7233f9b589a413e310991431039b05b6">More...</a><br /></td></tr>
<tr class="separator:a7233f9b589a413e310991431039b05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a461ed6a3396f874d12b2aec6996180d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461ed6a3396f874d12b2aec6996180d9">&#9670;&nbsp;</a></span>Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>num_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTR_TYPE&#160;</td>
          <td class="paramname"><em>coeffs</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize constraint to the given coefficients. </p>
<p>The resulting constraint is \( c_1x_1 + \cdots + c_nx_n \geq 0, \) where \( c_i \) is the coefficient of \( x_i \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_variables</td><td>length of coeffs </td></tr>
    <tr><td class="paramname">coeffs</td><td>copies this array of coefficients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the size of the array needs to be at least as long as the dimension! </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00025">25</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="abc362e0473a75944d6b8830f6dc33846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc362e0473a75944d6b8830f6dc33846">&#9670;&nbsp;</a></span>Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype">vector&lt; CONSTR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize constraint to the given coefficients. </p>
<p>The resulting constraint is \( c_1x_1 + \cdots + c_nx_n \geq 0, \) where \( c_i \) is the coefficient of \( x_i \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>copies thiis vector of coefficients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>nvars</code> will have the value equal to <code>coeffs.size()</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00033">33</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a2949083e68c41842b613bd8cf78c6389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2949083e68c41842b613bd8cf78c6389">&#9670;&nbsp;</a></span>~Constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Constraint::~Constraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes memory allocated by the constructor. </p>
<p>Currently, that means it deletes an array created by the constructors. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00113">113</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="ab67011dc88bf8927d50bf3806e792f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67011dc88bf8927d50bf3806e792f8b">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check for constraint inequality </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first constraint </td></tr>
    <tr><td class="paramname">b</td><td>second constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> and <code>b</code> have different entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00073">73</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ad7246226080bd15a0d477cd905b4b71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7246226080bd15a0d477cd905b4b71c">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographic comparison of constraints. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first constraint </td></tr>
    <tr><td class="paramname">b</td><td>second constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> and <code>b</code> have different entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00050">50</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a7233f9b589a413e310991431039b05b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7233f9b589a413e310991431039b05b6">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print a representation of the constraint to the stream </p>
<p>Output is of the form \( c_1 x_1 + \ldots + c_n x_n \) , where \( c_i \) is the coefficient of \( x_i \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">c</td><td>constraint to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00083">83</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a9411a8f6505608b523a4d5f28014d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9411a8f6505608b523a4d5f28014d4c2">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check for constraint equality </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first constraint </td></tr>
    <tr><td class="paramname">b</td><td>second constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> and <code>b</code> have the same entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00063">63</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solvers_1_1_edge" id="class_l_p___solvers_1_1_edge"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_edge">&#9670;&nbsp;</a></span>LP_Solvers::Edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::Edge</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>an edge \((r_1,r_2)\) connecting the two rays \( r_1 \) and \( r_2 \) </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates an edge, the other major part of a skeleton. Edges describe how the rays of the skeleton are connected. Edges are ordered, so that the smaller ray always comes first.</p>
<dl class="section warning"><dt>Warning</dt><dd>An edge's rays should have the same dimension. To start with, it doesn't make mathematical sense to &ldquo;join&rdquo; two rays of different dimension. Moreover, comparison of edges requires comparison of rays,which requires that the rays have the same dimension. (But you wouldn't be dumb enough to do this in the first place.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00060">60</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a0e0d55af1b62a30f927d22a4d4a606aa"><td class="memItemLeft" align="right" valign="top"><a id="a0e0d55af1b62a30f927d22a4d4a606aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a0e0d55af1b62a30f927d22a4d4a606aa">Edge</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:a0e0d55af1b62a30f927d22a4d4a606aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new edge that joins the two rays. <br /></td></tr>
<tr class="separator:a0e0d55af1b62a30f927d22a4d4a606aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057b073d9eb422d71f083f2422eafcef"><td class="memItemLeft" align="right" valign="top"><a id="a057b073d9eb422d71f083f2422eafcef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a057b073d9eb422d71f083f2422eafcef">Edge</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;)</td></tr>
<tr class="memdesc:a057b073d9eb422d71f083f2422eafcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the rays in <code>other</code> to two new rays. <br /></td></tr>
<tr class="separator:a057b073d9eb422d71f083f2422eafcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a752de1869e522b7b7a1eb9ef67664c9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a752de1869e522b7b7a1eb9ef67664c9f">~Edge</a> ()</td></tr>
<tr class="separator:a752de1869e522b7b7a1eb9ef67664c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:a42bdb7c77776fcdd004ccc116dad062c"><td class="memItemLeft" align="right" valign="top"><a id="a42bdb7c77776fcdd004ccc116dad062c"></a>
<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a42bdb7c77776fcdd004ccc116dad062c">get_first_ray</a> () const</td></tr>
<tr class="memdesc:a42bdb7c77776fcdd004ccc116dad062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ray listed in this edge. <br /></td></tr>
<tr class="separator:a42bdb7c77776fcdd004ccc116dad062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d370c22d17a71e588e1e7f55dd92546"><td class="memItemLeft" align="right" valign="top"><a id="a9d370c22d17a71e588e1e7f55dd92546"></a>
<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a9d370c22d17a71e588e1e7f55dd92546">get_second_ray</a> () const</td></tr>
<tr class="memdesc:a9d370c22d17a71e588e1e7f55dd92546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second ray listed in this edge. <br /></td></tr>
<tr class="separator:a9d370c22d17a71e588e1e7f55dd92546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:a61244022cf65ac1c5cb9d11377985bc8"><td class="memItemLeft" align="right" valign="top"><a id="a61244022cf65ac1c5cb9d11377985bc8"></a>
<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a61244022cf65ac1c5cb9d11377985bc8">operator=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;)</td></tr>
<tr class="memdesc:a61244022cf65ac1c5cb9d11377985bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a61244022cf65ac1c5cb9d11377985bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:a02f62dc93f3810dedf600e1890d0a01a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a02f62dc93f3810dedf600e1890d0a01a">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e1, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:a02f62dc93f3810dedf600e1890d0a01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal if and only if.  <a href="#a02f62dc93f3810dedf600e1890d0a01a">More...</a><br /></td></tr>
<tr class="separator:a02f62dc93f3810dedf600e1890d0a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1d947f208d0ba281c45ec9717522d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aab1d947f208d0ba281c45ec9717522d6">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e1, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:aab1d947f208d0ba281c45ec9717522d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two edges lexicographically.  <a href="#aab1d947f208d0ba281c45ec9717522d6">More...</a><br /></td></tr>
<tr class="separator:aab1d947f208d0ba281c45ec9717522d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a21cc787db181be486f871e88cfc2ef54"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a21cc787db181be486f871e88cfc2ef54">operator&lt;&lt;</a> (ostream &amp;ostr, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;e)</td></tr>
<tr class="memdesc:a21cc787db181be486f871e88cfc2ef54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output has the form \( \{ \mathbf{r}_1, \mathbf{r}_2 \} \) where \( \mathbf{r}_1 \) is the first ray in this edge, etc.  <a href="#a21cc787db181be486f871e88cfc2ef54">More...</a><br /></td></tr>
<tr class="separator:a21cc787db181be486f871e88cfc2ef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a752de1869e522b7b7a1eb9ef67664c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752de1869e522b7b7a1eb9ef67664c9f">&#9670;&nbsp;</a></span>~Edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Edge::~Edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does nothing beyond what the compiler would do. </p>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00078">78</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="aab1d947f208d0ba281c45ec9717522d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1d947f208d0ba281c45ec9717522d6">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two edges lexicographically. </p>
<p>If the first ray in <code>this</code> edge is smaller, then <code>this</code> edge is smaller. Otherwise, if the first rays are equal, and the second ray in <code>this</code> edge is smaller, then <code>this</code> edge is smaller.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the first edge is lexicographically smaller</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>an edge </td></tr>
    <tr><td class="paramname">e2</td><td>an edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00063">63</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a21cc787db181be486f871e88cfc2ef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cc787db181be486f871e88cfc2ef54">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output has the form \( \{ \mathbf{r}_1, \mathbf{r}_2 \} \) where \( \mathbf{r}_1 \) is the first ray in this edge, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>output stream to write to </td></tr>
    <tr><td class="paramname">e</td><td>edge to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00054">54</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a02f62dc93f3810dedf600e1890d0a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f62dc93f3810dedf600e1890d0a01a">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal if and only if. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>an edge </td></tr>
    <tr><td class="paramname">e2</td><td>an edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the edges have identical entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00060">60</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solvers_1_1_g_l_p_k___solver" id="class_l_p___solvers_1_1_g_l_p_k___solver"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_g_l_p_k___solver">&#9670;&nbsp;</a></span>LP_Solvers::GLPK_Solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::GLPK_Solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>approximate skeleton of a polyhedral cone, using GLPK linear solver </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2017 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class serves as an interface to GLPK <a class="el" href="citelist.html#CITEREF_glpk">[8]</a>, which we can use to find an approximate skeleton to a polyhedral cone. </p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8hpp_source.html#l00039">39</a> of file <a class="el" href="glpk__solver_8hpp_source.html">glpk_solver.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for LP_Solvers::GLPK_Solver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#LP_5FSolvers::GLPK_5FSolver_map" alt=""/>
  <map id="LP_5FSolvers::GLPK_5FSolver_map" name="LP_5FSolvers::GLPK_5FSolver_map">
<area href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ..." alt="LP_Solvers::LP_Solver" shape="rect" coords="0,0,159,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a10b3981d1807e86315318505ae0faeba"><td class="memItemLeft" align="right" valign="top"><a id="a10b3981d1807e86315318505ae0faeba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a10b3981d1807e86315318505ae0faeba">GLPK_Solver</a> (NVAR_TYPE n)</td></tr>
<tr class="memdesc:a10b3981d1807e86315318505ae0faeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes solver for \( n \) variables <br /></td></tr>
<tr class="separator:a10b3981d1807e86315318505ae0faeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdba8634513aafff25e17d42e3f8261b"><td class="memItemLeft" align="right" valign="top"><a id="acdba8634513aafff25e17d42e3f8261b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#acdba8634513aafff25e17d42e3f8261b">GLPK_Solver</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver">GLPK_Solver</a> &amp;)</td></tr>
<tr class="memdesc:acdba8634513aafff25e17d42e3f8261b"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor (deep copy) <br /></td></tr>
<tr class="separator:acdba8634513aafff25e17d42e3f8261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a745172366a1dfd893dee00f0ce0fb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a43a745172366a1dfd893dee00f0ce0fb">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *) override</td></tr>
<tr class="memdesc:a43a745172366a1dfd893dee00f0ce0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#a43a745172366a1dfd893dee00f0ce0fb">More...</a><br /></td></tr>
<tr class="separator:a43a745172366a1dfd893dee00f0ce0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a5712c834300cea2063aa932ad8a817d7"><td class="memItemLeft" align="right" valign="top"><a id="a5712c834300cea2063aa932ad8a817d7"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~GLPK_Solver</b> ()</td></tr>
<tr class="separator:a5712c834300cea2063aa932ad8a817d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:af6e6f37b09b2e4b1f45581c8a772f3eb"><td class="memItemLeft" align="right" valign="top"><a id="af6e6f37b09b2e4b1f45581c8a772f3eb"></a>
virtual NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#af6e6f37b09b2e4b1f45581c8a772f3eb">get_dimension</a> () const override</td></tr>
<tr class="memdesc:af6e6f37b09b2e4b1f45581c8a772f3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:af6e6f37b09b2e4b1f45581c8a772f3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee0b95d41c3861267176f5b249837e8"><td class="memItemLeft" align="right" valign="top"><a id="a4ee0b95d41c3861267176f5b249837e8"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4ee0b95d41c3861267176f5b249837e8">get_number_of_rays</a> () override</td></tr>
<tr class="memdesc:a4ee0b95d41c3861267176f5b249837e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a4ee0b95d41c3861267176f5b249837e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ded7ec7a82decb93132e10e25851528"><td class="memItemLeft" align="right" valign="top">virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a9ded7ec7a82decb93132e10e25851528">get_rays</a> () const override</td></tr>
<tr class="memdesc:a9ded7ec7a82decb93132e10e25851528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rays that define a skeleton.  <a href="#a9ded7ec7a82decb93132e10e25851528">More...</a><br /></td></tr>
<tr class="separator:a9ded7ec7a82decb93132e10e25851528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28eb491140e583b453773ead208ae32"><td class="memItemLeft" align="right" valign="top">virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#af28eb491140e583b453773ead208ae32">get_number_of_constraints</a> () const override</td></tr>
<tr class="memdesc:af28eb491140e583b453773ead208ae32"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of constraints used by the skeleton  <a href="#af28eb491140e583b453773ead208ae32">More...</a><br /></td></tr>
<tr class="separator:af28eb491140e583b453773ead208ae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:aadfa4655b194b3b095db962c5900fee6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aadfa4655b194b3b095db962c5900fee6">solve</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;) override</td></tr>
<tr class="memdesc:aadfa4655b194b3b095db962c5900fee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the solution.  <a href="#aadfa4655b194b3b095db962c5900fee6">More...</a><br /></td></tr>
<tr class="separator:aadfa4655b194b3b095db962c5900fee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fcdf86d0fcd8ac3e5da077b627e477"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a08fcdf86d0fcd8ac3e5da077b627e477">solve</a> (const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;) override</td></tr>
<tr class="memdesc:a08fcdf86d0fcd8ac3e5da077b627e477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the solution.  <a href="#a08fcdf86d0fcd8ac3e5da077b627e477">More...</a><br /></td></tr>
<tr class="separator:a08fcdf86d0fcd8ac3e5da077b627e477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:a23e950a4911f140ddffdcaeb062f7b80"><td class="memItemLeft" align="right" valign="top"><a id="a23e950a4911f140ddffdcaeb062f7b80"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a23e950a4911f140ddffdcaeb062f7b80">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false) const override</td></tr>
<tr class="memdesc:a23e950a4911f140ddffdcaeb062f7b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a23e950a4911f140ddffdcaeb062f7b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memitem:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a1d530b23b2516c36cbc02173e667d0cf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1d530b23b2516c36cbc02173e667d0cf">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Attributes</h3></td></tr>
<tr class="memitem:ad748438e4625935b7c4ce4d677b2cdfd"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad748438e4625935b7c4ce4d677b2cdfd">rays</a></td></tr>
<tr class="memdesc:ad748438e4625935b7c4ce4d677b2cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">overrides <code>rays</code> from <code><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ...">LP_Solver</a></code> ; necessary because for GLPK it is helpful to avoid updating the rays until they are needed  <a href="#ad748438e4625935b7c4ce4d677b2cdfd">More...</a><br /></td></tr>
<tr class="separator:ad748438e4625935b7c4ce4d677b2cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memitem:ad4c9fb3708c156496c23515c8e841374 inherit pro_attribs_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad4c9fb3708c156496c23515c8e841374">rays</a></td></tr>
<tr class="separator:ad4c9fb3708c156496c23515c8e841374 inherit pro_attribs_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a43a745172366a1dfd893dee00f0ce0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a745172366a1dfd893dee00f0ce0fb">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::GLPK_Solver::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a36c14a88e9d3ae9d9321acc7877236d0">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00060">60</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>
<a id="af28eb491140e583b453773ead208ae32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28eb491140e583b453773ead208ae32">&#9670;&nbsp;</a></span>get_number_of_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned long LP_Solvers::GLPK_Solver::get_number_of_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of constraints used by the skeleton </p>
<dl class="section return"><dt>Returns</dt><dd>number of constraints </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a1a220bc10c6d8696dd5885d7f3678e5f">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8hpp_source.html#l00063">63</a> of file <a class="el" href="glpk__solver_8hpp_source.html">glpk_solver.hpp</a>.</p>

</div>
</div>
<a id="a9ded7ec7a82decb93132e10e25851528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ded7ec7a82decb93132e10e25851528">&#9670;&nbsp;</a></span>get_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp; LP_Solvers::GLPK_Solver::get_rays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns rays that define a skeleton. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray" title="a ray defined by nonnegative coordinates  ">Ray</a> that define the given skeleton</dd></dl>
<p>When using an approximate solver such as <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, this will give only an approximate skeleton. </p>

<p>Reimplemented from <a class="el" href="group___c_l_s_solvers.html#a8328f67af66c81db467a6366f48ba3c8">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00144">144</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>
<a id="aadfa4655b194b3b095db962c5900fee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfa4655b194b3b095db962c5900fee6">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::GLPK_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a8b9979fb228ac9ccfe037ad6ca48b314">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00118">118</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>
<a id="a08fcdf86d0fcd8ac3e5da077b627e477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fcdf86d0fcd8ac3e5da077b627e477">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::GLPK_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#aea1a5bf98a2c4c06b0550cacdf8b88fd">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00087">87</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="ad748438e4625935b7c4ce4d677b2cdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad748438e4625935b7c4ce4d677b2cdfd">&#9670;&nbsp;</a></span>rays</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&gt; LP_Solvers::GLPK_Solver::rays</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overrides <code>rays</code> from <code><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ...">LP_Solver</a></code> ; necessary because for GLPK it is helpful to avoid updating the rays until they are needed </p>
<p>You shouldn&rsquo;t care about the details, but here we go. When <code><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a></code> adds one or more constraints, it does not actually solve until requested. Until then, the rays are marked as &ldquo;dirty&rdquo;. Any attempt to access dirty rays prompts the solver. In some cases, the solver will have been marked as &ldquo;const&rdquo;; this is inherited from <code><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ...">LP_Solver</a></code> and I think it&rsquo;s A Good Idea<sup>TM</sup> for exact solvers. So I mark the rays here as <code>mutable</code>. Arguably I should do that in <code><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ...">LP_Solver</a></code> but I&rsquo;m not really in the mood to argue at the moment. </p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8hpp_source.html#l00110">110</a> of file <a class="el" href="glpk__solver_8hpp_source.html">glpk_solver.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solvers_1_1_l_p___solver" id="class_l_p___solvers_1_1_l_p___solver"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_l_p___solver">&#9670;&nbsp;</a></span>LP_Solvers::LP_Solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::LP_Solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>exact or approximate polyhedral cone solution, with methods allowing definition and refinement </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2017 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates the skeleton of a polyhedral cone, defined by a sequence of inequalities of the form \( c_1 x_1 + \cdots c_n x_n \geq 0 \).</p>
<dl class="section warning"><dt>Warning</dt><dd>Some classes may provide only an <em>approximate</em> cone; see, for example, <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>. In addition, Clients must ensure two things.<ol type="1">
<li>The rays must have the same number \( m \) of dimensions, constraints must have the same number \( n \) of variables, and \( m=n \). Violating any of these three conditions will lead to undesirable behavior.</li>
<li>When refining the cone, it is essential to check that the return value of <a class="el" href="group___c_l_s_solvers.html#a8b9979fb228ac9ccfe037ad6ca48b314" title="Adds the indicated constraint (singular!) and re-computes the solution. ">solve()</a> is <code>true</code>; for if it is not, then the cone is no longer be consistent. Please read the relevant documentation. </li>
</ol>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00564">564</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for LP_Solvers::LP_Solver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#LP_5FSolvers::LP_5FSolver_map" alt=""/>
  <map id="LP_5FSolvers::LP_5FSolver_map" name="LP_5FSolvers::LP_5FSolver_map">
<area href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver " alt="LP_Solvers::GLPK_Solver" shape="rect" coords="0,56,159,80"/>
<area href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver " alt="LP_Solvers::PPL_Solver" shape="rect" coords="169,56,328,80"/>
<area href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton" title="skeleton of a polyhedral cone, with methods allowing definition and refinement " alt="LP_Solvers::Skeleton" shape="rect" coords="338,56,497,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a36c14a88e9d3ae9d9321acc7877236d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a36c14a88e9d3ae9d9321acc7877236d0">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *)=0</td></tr>
<tr class="memdesc:a36c14a88e9d3ae9d9321acc7877236d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#a36c14a88e9d3ae9d9321acc7877236d0">More...</a><br /></td></tr>
<tr class="separator:a36c14a88e9d3ae9d9321acc7877236d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a1d530b23b2516c36cbc02173e667d0cf"><td class="memItemLeft" align="right" valign="top"><a id="a1d530b23b2516c36cbc02173e667d0cf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1d530b23b2516c36cbc02173e667d0cf">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a1d530b23b2516c36cbc02173e667d0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a1d530b23b2516c36cbc02173e667d0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:a8b9979fb228ac9ccfe037ad6ca48b314"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8b9979fb228ac9ccfe037ad6ca48b314">solve</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;)=0</td></tr>
<tr class="memdesc:a8b9979fb228ac9ccfe037ad6ca48b314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the solution.  <a href="#a8b9979fb228ac9ccfe037ad6ca48b314">More...</a><br /></td></tr>
<tr class="separator:a8b9979fb228ac9ccfe037ad6ca48b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a5bf98a2c4c06b0550cacdf8b88fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aea1a5bf98a2c4c06b0550cacdf8b88fd">solve</a> (const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;)=0</td></tr>
<tr class="memdesc:aea1a5bf98a2c4c06b0550cacdf8b88fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the solution.  <a href="#aea1a5bf98a2c4c06b0550cacdf8b88fd">More...</a><br /></td></tr>
<tr class="separator:aea1a5bf98a2c4c06b0550cacdf8b88fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properies</div></td></tr>
<tr class="memitem:a5801b4bd5322a78e0cf3dcad83383a2e"><td class="memItemLeft" align="right" valign="top"><a id="a5801b4bd5322a78e0cf3dcad83383a2e"></a>
virtual NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5801b4bd5322a78e0cf3dcad83383a2e">get_dimension</a> () const =0</td></tr>
<tr class="memdesc:a5801b4bd5322a78e0cf3dcad83383a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:a5801b4bd5322a78e0cf3dcad83383a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d455722e6ae8b0bc9928dcd1bfa48"><td class="memItemLeft" align="right" valign="top"><a id="a7a8d455722e6ae8b0bc9928dcd1bfa48"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7a8d455722e6ae8b0bc9928dcd1bfa48">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:a7a8d455722e6ae8b0bc9928dcd1bfa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a7a8d455722e6ae8b0bc9928dcd1bfa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f67af66c81db467a6366f48ba3c8"><td class="memItemLeft" align="right" valign="top">virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8328f67af66c81db467a6366f48ba3c8">get_rays</a> () const</td></tr>
<tr class="memdesc:a8328f67af66c81db467a6366f48ba3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rays that define a skeleton.  <a href="#a8328f67af66c81db467a6366f48ba3c8">More...</a><br /></td></tr>
<tr class="separator:a8328f67af66c81db467a6366f48ba3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a220bc10c6d8696dd5885d7f3678e5f"><td class="memItemLeft" align="right" valign="top">virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1a220bc10c6d8696dd5885d7f3678e5f">get_number_of_constraints</a> () const =0</td></tr>
<tr class="memdesc:a1a220bc10c6d8696dd5885d7f3678e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of constraints used by the skeleton  <a href="#a1a220bc10c6d8696dd5885d7f3678e5f">More...</a><br /></td></tr>
<tr class="separator:a1a220bc10c6d8696dd5885d7f3678e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:a4b2ef4e520631f5ad73d3cddffc832a1"><td class="memItemLeft" align="right" valign="top"><a id="a4b2ef4e520631f5ad73d3cddffc832a1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4b2ef4e520631f5ad73d3cddffc832a1">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false) const</td></tr>
<tr class="memdesc:a4b2ef4e520631f5ad73d3cddffc832a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a4b2ef4e520631f5ad73d3cddffc832a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Attributes</h3></td></tr>
<tr class="memitem:ad4c9fb3708c156496c23515c8e841374"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad4c9fb3708c156496c23515c8e841374">rays</a></td></tr>
<tr class="separator:ad4c9fb3708c156496c23515c8e841374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a36c14a88e9d3ae9d9321acc7877236d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c14a88e9d3ae9d9321acc7877236d0">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LP_Solvers::LP_Solver::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#a242f1dc35468e2326e6f7c10bc0d0fd4">LP_Solvers::Skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#acc03418759754dbeda266dba9eefe98b">LP_Solvers::PPL_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#a43a745172366a1dfd893dee00f0ce0fb">LP_Solvers::GLPK_Solver</a>.</p>

</div>
</div>
<a id="a1a220bc10c6d8696dd5885d7f3678e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a220bc10c6d8696dd5885d7f3678e5f">&#9670;&nbsp;</a></span>get_number_of_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned long LP_Solvers::LP_Solver::get_number_of_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of constraints used by the skeleton </p>
<dl class="section return"><dt>Returns</dt><dd>number of constraints </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#ac13c3eb80cc3a4fdee872c4c976da489">LP_Solvers::Skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#af28eb491140e583b453773ead208ae32">LP_Solvers::GLPK_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#afb7f014f84eb37026fe26f8c3114c0f0">LP_Solvers::PPL_Solver</a>.</p>

</div>
</div>
<a id="a8328f67af66c81db467a6366f48ba3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8328f67af66c81db467a6366f48ba3c8">&#9670;&nbsp;</a></span>get_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp; LP_Solvers::LP_Solver::get_rays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns rays that define a skeleton. </p>
<dl class="section return"><dt>Returns</dt><dd>a set of <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray" title="a ray defined by nonnegative coordinates  ">Ray</a> that define the given skeleton</dd></dl>
<p>When using an approximate solver such as <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, this will give only an approximate skeleton. </p>

<p>Reimplemented in <a class="el" href="group___c_l_s_solvers.html#a9ded7ec7a82decb93132e10e25851528">LP_Solvers::GLPK_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00380">380</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a8b9979fb228ac9ccfe037ad6ca48b314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9979fb228ac9ccfe037ad6ca48b314">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LP_Solvers::LP_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#a3b0e821ab6a683ab4f936b7552074a15">LP_Solvers::Skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#aadfa4655b194b3b095db962c5900fee6">LP_Solvers::GLPK_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#a9a4a7563d62e4394162aaa4bd08aae29">LP_Solvers::PPL_Solver</a>.</p>

</div>
</div>
<a id="aea1a5bf98a2c4c06b0550cacdf8b88fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1a5bf98a2c4c06b0550cacdf8b88fd">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LP_Solvers::LP_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#adf50f125e2bfc6834fdd93e3fff22c48">LP_Solvers::Skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#a08fcdf86d0fcd8ac3e5da077b627e477">LP_Solvers::GLPK_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#a3763d4bc551a98546f1f5be4df49390d">LP_Solvers::PPL_Solver</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="ad4c9fb3708c156496c23515c8e841374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c9fb3708c156496c23515c8e841374">&#9670;&nbsp;</a></span>rays</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a>&gt; LP_Solvers::LP_Solver::rays</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the skeleton (may be approximate, depending on solver) </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00666">666</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solvers_1_1_p_p_l___solver" id="class_l_p___solvers_1_1_p_p_l___solver"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_p_p_l___solver">&#9670;&nbsp;</a></span>LP_Solvers::PPL_Solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::PPL_Solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>approximate skeleton of a polyhedral cone, using PPL linear solver </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2017 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class serves as an interface to PPL <a class="el" href="citelist.html#CITEREF_BagnaraHZ08SCP">[1]</a>, which we can use to find the skeleton to a polyhedral cone. </p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8hpp_source.html#l00040">40</a> of file <a class="el" href="ppl__solver_8hpp_source.html">ppl_solver.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for LP_Solvers::PPL_Solver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#LP_5FSolvers::PPL_5FSolver_map" alt=""/>
  <map id="LP_5FSolvers::PPL_5FSolver_map" name="LP_5FSolvers::PPL_5FSolver_map">
<area href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ..." alt="LP_Solvers::LP_Solver" shape="rect" coords="0,0,150,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a8676ceed54fc8883fd0c2cab45e7d9a4"><td class="memItemLeft" align="right" valign="top"><a id="a8676ceed54fc8883fd0c2cab45e7d9a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8676ceed54fc8883fd0c2cab45e7d9a4">PPL_Solver</a> (NVAR_TYPE <a class="el" href="group___c_l_s_solvers.html#a10d4394603a6a565a95fc65ce0f9a172">n</a>)</td></tr>
<tr class="memdesc:a8676ceed54fc8883fd0c2cab45e7d9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes solver for \( n \) variables <br /></td></tr>
<tr class="separator:a8676ceed54fc8883fd0c2cab45e7d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d5564f046f82f07f58e557228f10c5"><td class="memItemLeft" align="right" valign="top"><a id="a53d5564f046f82f07f58e557228f10c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a53d5564f046f82f07f58e557228f10c5">PPL_Solver</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver">PPL_Solver</a> &amp;)</td></tr>
<tr class="memdesc:a53d5564f046f82f07f58e557228f10c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor (deep copy) <br /></td></tr>
<tr class="separator:a53d5564f046f82f07f58e557228f10c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc03418759754dbeda266dba9eefe98b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#acc03418759754dbeda266dba9eefe98b">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *) override</td></tr>
<tr class="memdesc:acc03418759754dbeda266dba9eefe98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#acc03418759754dbeda266dba9eefe98b">More...</a><br /></td></tr>
<tr class="separator:acc03418759754dbeda266dba9eefe98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a2d4cd90b9e8bab2ff0fe3178bb894e75"><td class="memItemLeft" align="right" valign="top"><a id="a2d4cd90b9e8bab2ff0fe3178bb894e75"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PPL_Solver</b> ()</td></tr>
<tr class="separator:a2d4cd90b9e8bab2ff0fe3178bb894e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:a5a5f372696416caeae454ce78e9acb86"><td class="memItemLeft" align="right" valign="top"><a id="a5a5f372696416caeae454ce78e9acb86"></a>
virtual NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5a5f372696416caeae454ce78e9acb86">get_dimension</a> () const override</td></tr>
<tr class="memdesc:a5a5f372696416caeae454ce78e9acb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:a5a5f372696416caeae454ce78e9acb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f014f84eb37026fe26f8c3114c0f0"><td class="memItemLeft" align="right" valign="top">virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#afb7f014f84eb37026fe26f8c3114c0f0">get_number_of_constraints</a> () const override</td></tr>
<tr class="memdesc:afb7f014f84eb37026fe26f8c3114c0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of constraints used by the skeleton  <a href="#afb7f014f84eb37026fe26f8c3114c0f0">More...</a><br /></td></tr>
<tr class="separator:afb7f014f84eb37026fe26f8c3114c0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:a9a4a7563d62e4394162aaa4bd08aae29"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a9a4a7563d62e4394162aaa4bd08aae29">solve</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;) override</td></tr>
<tr class="memdesc:a9a4a7563d62e4394162aaa4bd08aae29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the solution.  <a href="#a9a4a7563d62e4394162aaa4bd08aae29">More...</a><br /></td></tr>
<tr class="separator:a9a4a7563d62e4394162aaa4bd08aae29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3763d4bc551a98546f1f5be4df49390d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3763d4bc551a98546f1f5be4df49390d">solve</a> (const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;) override</td></tr>
<tr class="memdesc:a3763d4bc551a98546f1f5be4df49390d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the solution.  <a href="#a3763d4bc551a98546f1f5be4df49390d">More...</a><br /></td></tr>
<tr class="separator:a3763d4bc551a98546f1f5be4df49390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b50fd63c3032192d02d9a1b2411e33a"><td class="memItemLeft" align="right" valign="top"><a id="a1b50fd63c3032192d02d9a1b2411e33a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1b50fd63c3032192d02d9a1b2411e33a">setup_rays</a> ()</td></tr>
<tr class="memdesc:a1b50fd63c3032192d02d9a1b2411e33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear the current set of rays and extracts the ones contained in lp <br /></td></tr>
<tr class="separator:a1b50fd63c3032192d02d9a1b2411e33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memitem:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a1d530b23b2516c36cbc02173e667d0cf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1d530b23b2516c36cbc02173e667d0cf">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d455722e6ae8b0bc9928dcd1bfa48 inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a7a8d455722e6ae8b0bc9928dcd1bfa48"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7a8d455722e6ae8b0bc9928dcd1bfa48">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:a7a8d455722e6ae8b0bc9928dcd1bfa48 inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a7a8d455722e6ae8b0bc9928dcd1bfa48 inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f67af66c81db467a6366f48ba3c8 inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8328f67af66c81db467a6366f48ba3c8">get_rays</a> () const</td></tr>
<tr class="memdesc:a8328f67af66c81db467a6366f48ba3c8 inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rays that define a skeleton.  <a href="group___c_l_s_solvers.html#a8328f67af66c81db467a6366f48ba3c8">More...</a><br /></td></tr>
<tr class="separator:a8328f67af66c81db467a6366f48ba3c8 inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2ef4e520631f5ad73d3cddffc832a1 inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a4b2ef4e520631f5ad73d3cddffc832a1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4b2ef4e520631f5ad73d3cddffc832a1">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false) const</td></tr>
<tr class="memdesc:a4b2ef4e520631f5ad73d3cddffc832a1 inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a4b2ef4e520631f5ad73d3cddffc832a1 inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Attributes</h3></td></tr>
<tr class="memitem:ad85a1f4b919c2f4580b48360571aaf89"><td class="memItemLeft" align="right" valign="top"><a id="ad85a1f4b919c2f4580b48360571aaf89"></a>
PPL::NNC_Polyhedron *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad85a1f4b919c2f4580b48360571aaf89">lp</a></td></tr>
<tr class="memdesc:ad85a1f4b919c2f4580b48360571aaf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">PPL problem interface. <br /></td></tr>
<tr class="separator:ad85a1f4b919c2f4580b48360571aaf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32a90abf2d1ebba9243715bda4cb0c9"><td class="memItemLeft" align="right" valign="top"><a id="ad32a90abf2d1ebba9243715bda4cb0c9"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad32a90abf2d1ebba9243715bda4cb0c9">m</a></td></tr>
<tr class="memdesc:ad32a90abf2d1ebba9243715bda4cb0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of constraints <br /></td></tr>
<tr class="separator:ad32a90abf2d1ebba9243715bda4cb0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4394603a6a565a95fc65ce0f9a172"><td class="memItemLeft" align="right" valign="top"><a id="a10d4394603a6a565a95fc65ce0f9a172"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a10d4394603a6a565a95fc65ce0f9a172">n</a></td></tr>
<tr class="memdesc:a10d4394603a6a565a95fc65ce0f9a172"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of variables <br /></td></tr>
<tr class="separator:a10d4394603a6a565a95fc65ce0f9a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2dd1cfc4bea9e765b405b7297a6838"><td class="memItemLeft" align="right" valign="top"><a id="a7e2dd1cfc4bea9e765b405b7297a6838"></a>
RAYENT_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7e2dd1cfc4bea9e765b405b7297a6838">ray_data</a></td></tr>
<tr class="memdesc:a7e2dd1cfc4bea9e765b405b7297a6838"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to retrieve rays <br /></td></tr>
<tr class="separator:a7e2dd1cfc4bea9e765b405b7297a6838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3579e5105b375b1eb7e9237c39f749fa"><td class="memItemLeft" align="right" valign="top"><a id="a3579e5105b375b1eb7e9237c39f749fa"></a>
PPL::Variable **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3579e5105b375b1eb7e9237c39f749fa">X</a></td></tr>
<tr class="memdesc:a3579e5105b375b1eb7e9237c39f749fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of variables <br /></td></tr>
<tr class="separator:a3579e5105b375b1eb7e9237c39f749fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memitem:ad4c9fb3708c156496c23515c8e841374 inherit pro_attribs_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad4c9fb3708c156496c23515c8e841374">rays</a></td></tr>
<tr class="separator:ad4c9fb3708c156496c23515c8e841374 inherit pro_attribs_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Protected Attributes</h3></td></tr>
<tr class="memitem:a4c6a4a141e8c2eb4adbdef6ad73cec21"><td class="memItemLeft" align="right" valign="top"><a id="a4c6a4a141e8c2eb4adbdef6ad73cec21"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4c6a4a141e8c2eb4adbdef6ad73cec21">instances</a> = 0</td></tr>
<tr class="memdesc:a4c6a4a141e8c2eb4adbdef6ad73cec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of PPL instances <br /></td></tr>
<tr class="separator:a4c6a4a141e8c2eb4adbdef6ad73cec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="acc03418759754dbeda266dba9eefe98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc03418759754dbeda266dba9eefe98b">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::PPL_Solver::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a36c14a88e9d3ae9d9321acc7877236d0">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8cpp_source.html#l00086">86</a> of file <a class="el" href="ppl__solver_8cpp_source.html">ppl_solver.cpp</a>.</p>

</div>
</div>
<a id="afb7f014f84eb37026fe26f8c3114c0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7f014f84eb37026fe26f8c3114c0f0">&#9670;&nbsp;</a></span>get_number_of_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned long LP_Solvers::PPL_Solver::get_number_of_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of constraints used by the skeleton </p>
<dl class="section return"><dt>Returns</dt><dd>number of constraints </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a1a220bc10c6d8696dd5885d7f3678e5f">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8hpp_source.html#l00057">57</a> of file <a class="el" href="ppl__solver_8hpp_source.html">ppl_solver.hpp</a>.</p>

</div>
</div>
<a id="a9a4a7563d62e4394162aaa4bd08aae29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4a7563d62e4394162aaa4bd08aae29">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::PPL_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a8b9979fb228ac9ccfe037ad6ca48b314">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8cpp_source.html#l00117">117</a> of file <a class="el" href="ppl__solver_8cpp_source.html">ppl_solver.cpp</a>.</p>

</div>
</div>
<a id="a3763d4bc551a98546f1f5be4df49390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3763d4bc551a98546f1f5be4df49390d">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::PPL_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#aea1a5bf98a2c4c06b0550cacdf8b88fd">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8cpp_source.html#l00129">129</a> of file <a class="el" href="ppl__solver_8cpp_source.html">ppl_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solvers_1_1_ray" id="class_l_p___solvers_1_1_ray"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_ray">&#9670;&nbsp;</a></span>LP_Solvers::Ray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::Ray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>a ray defined by nonnegative coordinates \((a_1,\ldots,a_n)\) </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates a ray, one major part of the definition of a skeleton. Rays can be initialized to a particular set of coefficients, or to a particular axis (which is then translated into the corresponding coefficients).</p>
<p>A special feature is that a rays can track the constraints known to be active at the ray, allowing for more efficient computation in the double description method. Adding known constraints can be done with or without checking whether the constraint actually is active, so this should be done with care. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00222">222</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:ae6acfc48cec4f68f5855aae467f71095"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae6acfc48cec4f68f5855aae467f71095">Ray</a> (NVAR_TYPE, long=-1)</td></tr>
<tr class="memdesc:ae6acfc48cec4f68f5855aae467f71095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray with the given number of variables, all set to 0.  <a href="#ae6acfc48cec4f68f5855aae467f71095">More...</a><br /></td></tr>
<tr class="separator:ae6acfc48cec4f68f5855aae467f71095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69015f04db3f988b47cd05bae4f41a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad69015f04db3f988b47cd05bae4f41a8">Ray</a> (NVAR_TYPE, const RAYENT_TYPE [])</td></tr>
<tr class="memdesc:ad69015f04db3f988b47cd05bae4f41a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray with the given number of variables, with coordinates set to the value of the array.  <a href="#ad69015f04db3f988b47cd05bae4f41a8">More...</a><br /></td></tr>
<tr class="separator:ad69015f04db3f988b47cd05bae4f41a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc046b9f6a47f40ffddfc3334a47079"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aecc046b9f6a47f40ffddfc3334a47079">Ray</a> (NVAR_TYPE, const EXP_TYPE [])</td></tr>
<tr class="memdesc:aecc046b9f6a47f40ffddfc3334a47079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray with the given number of variables, with coordinates set to the value of the array.  <a href="#aecc046b9f6a47f40ffddfc3334a47079">More...</a><br /></td></tr>
<tr class="separator:aecc046b9f6a47f40ffddfc3334a47079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1e6f09dbb5081c8f34d245b1880ccc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#adb1e6f09dbb5081c8f34d245b1880ccc">Ray</a> (const vector&lt; RAYENT_TYPE &gt; &amp;)</td></tr>
<tr class="memdesc:adb1e6f09dbb5081c8f34d245b1880ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray whose coordinates are given by the vector.  <a href="#adb1e6f09dbb5081c8f34d245b1880ccc">More...</a><br /></td></tr>
<tr class="separator:adb1e6f09dbb5081c8f34d245b1880ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a98b2f969408ba0fa58b46a3dccb9bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3a98b2f969408ba0fa58b46a3dccb9bf">Ray</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:a3a98b2f969408ba0fa58b46a3dccb9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the coordinates of the other ray.  <a href="#a3a98b2f969408ba0fa58b46a3dccb9bf">More...</a><br /></td></tr>
<tr class="separator:a3a98b2f969408ba0fa58b46a3dccb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a4819e44c9151ea96204a5ca5233646f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4819e44c9151ea96204a5ca5233646f6">~Ray</a> ()</td></tr>
<tr class="memdesc:a4819e44c9151ea96204a5ca5233646f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes memory allocated by the constructor.  <a href="#a4819e44c9151ea96204a5ca5233646f6">More...</a><br /></td></tr>
<tr class="separator:a4819e44c9151ea96204a5ca5233646f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properies</div></td></tr>
<tr class="memitem:afa50278b90d4a5482326d351cdf556fc"><td class="memItemLeft" align="right" valign="top"><a id="afa50278b90d4a5482326d351cdf556fc"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#afa50278b90d4a5482326d351cdf556fc">get_dimension</a> () const</td></tr>
<tr class="memdesc:afa50278b90d4a5482326d351cdf556fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of this ray. <br /></td></tr>
<tr class="separator:afa50278b90d4a5482326d351cdf556fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340608efd12ab0f65173a6c0c05e6309"><td class="memItemLeft" align="right" valign="top"><a id="a340608efd12ab0f65173a6c0c05e6309"></a>
RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a340608efd12ab0f65173a6c0c05e6309">operator[]</a> (NVAR_TYPE index) const</td></tr>
<tr class="memdesc:a340608efd12ab0f65173a6c0c05e6309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entry indicated. Numbering starts at 0. <br /></td></tr>
<tr class="separator:a340608efd12ab0f65173a6c0c05e6309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0651d47b9e0b2a332e102c56447a1295"><td class="memItemLeft" align="right" valign="top"><a id="a0651d47b9e0b2a332e102c56447a1295"></a>
const RAYENT_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a0651d47b9e0b2a332e102c56447a1295">weights</a> () const</td></tr>
<tr class="memdesc:a0651d47b9e0b2a332e102c56447a1295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights. <br /></td></tr>
<tr class="separator:a0651d47b9e0b2a332e102c56447a1295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e4d7533edb52e344eb68c7e723a65c"><td class="memItemLeft" align="right" valign="top"><a id="a66e4d7533edb52e344eb68c7e723a65c"></a>
const RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a66e4d7533edb52e344eb68c7e723a65c">coordinate</a> (NVAR_TYPE index)</td></tr>
<tr class="memdesc:a66e4d7533edb52e344eb68c7e723a65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for []. I have no idea why I added this. <br /></td></tr>
<tr class="separator:a66e4d7533edb52e344eb68c7e723a65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935fd2cf258315c989cd4edce32371e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a935fd2cf258315c989cd4edce32371e7">is_active_at</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;hyperplane) const</td></tr>
<tr class="memdesc:a935fd2cf258315c989cd4edce32371e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the hyperplane is active at this ray.  <a href="#a935fd2cf258315c989cd4edce32371e7">More...</a><br /></td></tr>
<tr class="separator:a935fd2cf258315c989cd4edce32371e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0fb992267a74f098fef5ca6c159cad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aec0fb992267a74f098fef5ca6c159cad">is_above</a> (<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;hyperplane)</td></tr>
<tr class="memdesc:aec0fb992267a74f098fef5ca6c159cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if this ray is above the hyperplane.  <a href="#aec0fb992267a74f098fef5ca6c159cad">More...</a><br /></td></tr>
<tr class="separator:aec0fb992267a74f098fef5ca6c159cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdad8c5669c06827f3984583e764353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4bdad8c5669c06827f3984583e764353">is_below</a> (<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;hyperplane)</td></tr>
<tr class="memdesc:a4bdad8c5669c06827f3984583e764353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if this ray is below the hyperplane.  <a href="#a4bdad8c5669c06827f3984583e764353">More...</a><br /></td></tr>
<tr class="separator:a4bdad8c5669c06827f3984583e764353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:a431363fc157d5a8df8b180ac671e19ea"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a431363fc157d5a8df8b180ac671e19ea">obtain_dot_product</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;) const</td></tr>
<tr class="memdesc:a431363fc157d5a8df8b180ac671e19ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to compute dot product between ray and the given constraint.  <a href="#a431363fc157d5a8df8b180ac671e19ea">More...</a><br /></td></tr>
<tr class="separator:a431363fc157d5a8df8b180ac671e19ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:ac25d6feac8d47548fc157b6e3e8f26cc"><td class="memItemLeft" align="right" valign="top"><a id="ac25d6feac8d47548fc157b6e3e8f26cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ac25d6feac8d47548fc157b6e3e8f26cc">simplify_ray</a> ()</td></tr>
<tr class="memdesc:ac25d6feac8d47548fc157b6e3e8f26cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the ray by dividing its components by the least common denominator. <br /></td></tr>
<tr class="separator:ac25d6feac8d47548fc157b6e3e8f26cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70a9ad73b8788c53e0b1cc7c2cdae27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae70a9ad73b8788c53e0b1cc7c2cdae27">operator=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:ae70a9ad73b8788c53e0b1cc7c2cdae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator; assigns the value of <code>other</code> to <code>this</code>.  <a href="#ae70a9ad73b8788c53e0b1cc7c2cdae27">More...</a><br /></td></tr>
<tr class="separator:ae70a9ad73b8788c53e0b1cc7c2cdae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea89ef5df0792e64ce9003ad19913d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#acea89ef5df0792e64ce9003ad19913d4">swap</a> (<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;)</td></tr>
<tr class="memdesc:acea89ef5df0792e64ce9003ad19913d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two rays of equal dimension by swapping their data, avoiding memory reallocation.  <a href="#acea89ef5df0792e64ce9003ad19913d4">More...</a><br /></td></tr>
<tr class="separator:acea89ef5df0792e64ce9003ad19913d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:a12e1a3322151c1d6bbbce9efeeec40ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a12e1a3322151c1d6bbbce9efeeec40ae">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;b)</td></tr>
<tr class="memdesc:a12e1a3322151c1d6bbbce9efeeec40ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether the two rays are equal  <a href="#a12e1a3322151c1d6bbbce9efeeec40ae">More...</a><br /></td></tr>
<tr class="separator:a12e1a3322151c1d6bbbce9efeeec40ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79435f27d182af0ad5dda3646d24ecd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a79435f27d182af0ad5dda3646d24ecd8">operator!=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;b)</td></tr>
<tr class="memdesc:a79435f27d182af0ad5dda3646d24ecd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the two rays are unequal.  <a href="#a79435f27d182af0ad5dda3646d24ecd8">More...</a><br /></td></tr>
<tr class="separator:a79435f27d182af0ad5dda3646d24ecd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3d0a1adb5408b59013e6533e144b98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4c3d0a1adb5408b59013e6533e144b98">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;b)</td></tr>
<tr class="memdesc:a4c3d0a1adb5408b59013e6533e144b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of rays.  <a href="#a4c3d0a1adb5408b59013e6533e144b98">More...</a><br /></td></tr>
<tr class="separator:a4c3d0a1adb5408b59013e6533e144b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a58ab17142b3c74a8d39c1e42dfa7a3f4"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a58ab17142b3c74a8d39c1e42dfa7a3f4">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;r)</td></tr>
<tr class="memdesc:a58ab17142b3c74a8d39c1e42dfa7a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is of the form \((r_1, \ldots, r_n)\).  <a href="#a58ab17142b3c74a8d39c1e42dfa7a3f4">More...</a><br /></td></tr>
<tr class="separator:a58ab17142b3c74a8d39c1e42dfa7a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ae6acfc48cec4f68f5855aae467f71095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6acfc48cec4f68f5855aae467f71095">&#9670;&nbsp;</a></span>Ray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>direction</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray with the given number of variables, all set to 0. </p>
<p>The optional second argument specifies a direction, and sets that coordinate to 1. In this case, there is no need to set the ray's known active constraints, as this is known and populated automatically. </p><dl class="section pre"><dt>Precondition</dt><dd>The dimension should be greater than zero. While the direction need not be specified&hellip; (see postcondition) </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>&hellip;the result when the direction is zero is a zero ray. If the direction is \( i \), then the result is the \(i\)th canonical vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00134">134</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ad69015f04db3f988b47cd05bae4f41a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69015f04db3f988b47cd05bae4f41a8">&#9670;&nbsp;</a></span>Ray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RAYENT_TYPE&#160;</td>
          <td class="paramname"><em>entries</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray with the given number of variables, with coordinates set to the value of the array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the size of the array needs to be at least as long as the number of variables! </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00145">145</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="aecc046b9f6a47f40ffddfc3334a47079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc046b9f6a47f40ffddfc3334a47079">&#9670;&nbsp;</a></span>Ray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EXP_TYPE&#160;</td>
          <td class="paramname"><em>entries</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray with the given number of variables, with coordinates set to the value of the array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the size of the array needs to be at least as long as the number of variables! </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00154">154</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="adb1e6f09dbb5081c8f34d245b1880ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1e6f09dbb5081c8f34d245b1880ccc">&#9670;&nbsp;</a></span>Ray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; RAYENT_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray whose coordinates are given by the vector. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The dimension of this ray will equal the number of entries in the vector, and the values of their entries will be equal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00163">163</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a3a98b2f969408ba0fa58b46a3dccb9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a98b2f969408ba0fa58b46a3dccb9bf">&#9670;&nbsp;</a></span>Ray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Ray::Ray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>old_ray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the coordinates of the other ray. </p>
<p>Allocates new memory, and copies the active constraints. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00172">172</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a4819e44c9151ea96204a5ca5233646f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4819e44c9151ea96204a5ca5233646f6">&#9670;&nbsp;</a></span>~Ray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Ray::~Ray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes memory allocated by the constructor. </p>
<p>Currently, that means it deletes <code>coords</code>. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00182">182</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="aec0fb992267a74f098fef5ca6c159cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0fb992267a74f098fef5ca6c159cad">&#9670;&nbsp;</a></span>is_above()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::Ray::is_above </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if this ray is above the hyperplane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperplane</td><td>a constraint; we would like to know whether <code>this</code> is above it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>this</code> is above <code>constraint</code> </dd></dl>
<p>Practically speaking, if the hyperplane is defined by the vector \( \mathbf c \) and the ray is defined by \( \mathbf r \) , this function returns true if and only if \( c\cdot r &gt; 0 \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00325">325</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="a935fd2cf258315c989cd4edce32371e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935fd2cf258315c989cd4edce32371e7">&#9670;&nbsp;</a></span>is_active_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::Ray::is_active_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the hyperplane is active at this ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperplane</td><td>a constraint; we would like to know whether <code>this</code> lies on it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>this</code> lies on <code>constraint</code> </dd></dl>
<p>Practically speaking, if the hyperplane is defined by the vector \( \mathbf c \) and the ray is defined by \( \mathbf r \) , this function returns true if and only if \( c\cdot r = 0 \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00311">311</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="a4bdad8c5669c06827f3984583e764353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdad8c5669c06827f3984583e764353">&#9670;&nbsp;</a></span>is_below()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::Ray::is_below </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if this ray is below the hyperplane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperplane</td><td>a constraint; we would like to know whether <code>this</code> is below it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>this</code> is below <code>constraint</code> </dd></dl>
<p>Practically speaking, if the hyperplane is defined by the vector \( \mathbf c \) and the ray is defined by \( \mathbf r \) , this function returns true if and only if \( c\cdot r &lt; 0 \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00339">339</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="a431363fc157d5a8df8b180ac671e19ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431363fc157d5a8df8b180ac671e19ea">&#9670;&nbsp;</a></span>obtain_dot_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DOTPROD_TYPE LP_Solvers::Ray::obtain_dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to compute dot product between ray and the given constraint. </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product of <code>this</code> and <code>constraint</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00214">214</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ae70a9ad73b8788c53e0b1cc7c2cdae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70a9ad73b8788c53e0b1cc7c2cdae27">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp; LP_Solvers::Ray::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator; assigns the value of <code>other</code> to <code>this</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00332">332</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="acea89ef5df0792e64ce9003ad19913d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea89ef5df0792e64ce9003ad19913d4">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LP_Solvers::Ray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two rays of equal dimension by swapping their data, avoiding memory reallocation. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00352">352</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="a79435f27d182af0ad5dda3646d24ecd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79435f27d182af0ad5dda3646d24ecd8">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the two rays are unequal. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first ray </td></tr>
    <tr><td class="paramname">b</td><td>second ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the rays&rsquo; entries have different values</dd></dl>
<p>Notice that the rays can point in the same direction, but still be considered unequal. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00314">314</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a4c3d0a1adb5408b59013e6533e144b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3d0a1adb5408b59013e6533e144b98">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographic comparison of rays. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first ray </td></tr>
    <tr><td class="paramname">b</td><td>second ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <code>a</code> is lexicographically smaller than <code>b</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00363">363</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a58ab17142b3c74a8d39c1e42dfa7a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ab17142b3c74a8d39c1e42dfa7a3f4">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output is of the form \((r_1, \ldots, r_n)\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">r</td><td>ray to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00322">322</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a12e1a3322151c1d6bbbce9efeeec40ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e1a3322151c1d6bbbce9efeeec40ae">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates whether the two rays are equal </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first ray </td></tr>
    <tr><td class="paramname">b</td><td>second ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the rays&rsquo; entries have the same values</dd></dl>
<p>Notice that the rays can point in the same direction, but still be considered unequal. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00306">306</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solvers_1_1_skeleton" id="class_l_p___solvers_1_1_skeleton"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solvers_1_1_skeleton">&#9670;&nbsp;</a></span>LP_Solvers::Skeleton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solvers::Skeleton</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>skeleton of a polyhedral cone, with methods allowing definition and refinement </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class implements the Double Description Method, an iterative algorithm for computing the skeleton of a cone. This particular version uses Zolotykh's GraphAdj criterion <a class="el" href="citelist.html#CITEREF_Zolotych_DoubleDescription">[11]</a>. The iterative nature means that the cone can be updated with new constraints, passed to that algorithm, and the skeleton will be automatically recomputed. </p>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00215">215</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for LP_Solvers::Skeleton:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#LP_5FSolvers::Skeleton_map" alt=""/>
  <map id="LP_5FSolvers::Skeleton_map" name="LP_5FSolvers::Skeleton_map">
<area href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ..." alt="LP_Solvers::LP_Solver" shape="rect" coords="0,0,142,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:aa63d9454338c84be898e1a604eba3527"><td class="memItemLeft" align="right" valign="top"><a id="aa63d9454338c84be898e1a604eba3527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa63d9454338c84be898e1a604eba3527">common_initialization</a> (NVAR_TYPE)</td></tr>
<tr class="memdesc:aa63d9454338c84be898e1a604eba3527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization common to all constructors. <br /></td></tr>
<tr class="separator:aa63d9454338c84be898e1a604eba3527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f2f64c49dbf96ebd30852e670e7642"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad9f2f64c49dbf96ebd30852e670e7642">Skeleton</a> (NVAR_TYPE)</td></tr>
<tr class="memdesc:ad9f2f64c49dbf96ebd30852e670e7642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basic skeleton in the given number of dimensions, initialized to the axes, or (equivalently) to the set of constraints \( x_i \geq 0 \).  <a href="#ad9f2f64c49dbf96ebd30852e670e7642">More...</a><br /></td></tr>
<tr class="separator:ad9f2f64c49dbf96ebd30852e670e7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61d70c2397e93141de3ad3c987b1828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad61d70c2397e93141de3ad3c987b1828">Skeleton</a> (NVAR_TYPE, const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ad61d70c2397e93141de3ad3c987b1828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a skeleton described by the given system of constraints.  <a href="#ad61d70c2397e93141de3ad3c987b1828">More...</a><br /></td></tr>
<tr class="separator:ad61d70c2397e93141de3ad3c987b1828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6983329c8624014fa5c9d66f75ac3"><td class="memItemLeft" align="right" valign="top"><a id="ae1d6983329c8624014fa5c9d66f75ac3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae1d6983329c8624014fa5c9d66f75ac3">Skeleton</a> (<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;)</td></tr>
<tr class="memdesc:ae1d6983329c8624014fa5c9d66f75ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep copy of <code>other</code>. <br /></td></tr>
<tr class="separator:ae1d6983329c8624014fa5c9d66f75ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242f1dc35468e2326e6f7c10bc0d0fd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a242f1dc35468e2326e6f7c10bc0d0fd4">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *) override</td></tr>
<tr class="memdesc:a242f1dc35468e2326e6f7c10bc0d0fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#a242f1dc35468e2326e6f7c10bc0d0fd4">More...</a><br /></td></tr>
<tr class="separator:a242f1dc35468e2326e6f7c10bc0d0fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a0da8ede73aea9089d7b81683c08cfc60"><td class="memItemLeft" align="right" valign="top"><a id="a0da8ede73aea9089d7b81683c08cfc60"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a0da8ede73aea9089d7b81683c08cfc60">~Skeleton</a> ()</td></tr>
<tr class="memdesc:a0da8ede73aea9089d7b81683c08cfc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently does nothing the compiler wouldn't do. <br /></td></tr>
<tr class="separator:a0da8ede73aea9089d7b81683c08cfc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:a97df76042269bc785c37f2315c353ed3"><td class="memItemLeft" align="right" valign="top"><a id="a97df76042269bc785c37f2315c353ed3"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a97df76042269bc785c37f2315c353ed3">get_dimension</a> () const override</td></tr>
<tr class="memdesc:a97df76042269bc785c37f2315c353ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:a97df76042269bc785c37f2315c353ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310919f8faa248ffa479004d91c4defa"><td class="memItemLeft" align="right" valign="top"><a id="a310919f8faa248ffa479004d91c4defa"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a310919f8faa248ffa479004d91c4defa">get_number_of_edges</a> ()</td></tr>
<tr class="memdesc:a310919f8faa248ffa479004d91c4defa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges defining the skeleton. <br /></td></tr>
<tr class="separator:a310919f8faa248ffa479004d91c4defa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac51e256cb56e7fe4844c206dcfcf35b"><td class="memItemLeft" align="right" valign="top"><a id="aac51e256cb56e7fe4844c206dcfcf35b"></a>
set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aac51e256cb56e7fe4844c206dcfcf35b">get_edges</a> ()</td></tr>
<tr class="memdesc:aac51e256cb56e7fe4844c206dcfcf35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edges that define the skeleton. <br /></td></tr>
<tr class="separator:aac51e256cb56e7fe4844c206dcfcf35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13c3eb80cc3a4fdee872c4c976da489"><td class="memItemLeft" align="right" valign="top"><a id="ac13c3eb80cc3a4fdee872c4c976da489"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ac13c3eb80cc3a4fdee872c4c976da489">get_number_of_constraints</a> () const override</td></tr>
<tr class="memdesc:ac13c3eb80cc3a4fdee872c4c976da489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints defining the skeleton. <br /></td></tr>
<tr class="separator:ac13c3eb80cc3a4fdee872c4c976da489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1d8c1c056b9ec770f0c9abacdabe5d"><td class="memItemLeft" align="right" valign="top"><a id="a7e1d8c1c056b9ec770f0c9abacdabe5d"></a>
const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7e1d8c1c056b9ec770f0c9abacdabe5d">get_constraints</a> ()</td></tr>
<tr class="memdesc:a7e1d8c1c056b9ec770f0c9abacdabe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraints that define the skeleton. <br /></td></tr>
<tr class="separator:a7e1d8c1c056b9ec770f0c9abacdabe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc8543d03ed7464149e6dba20f77da1"><td class="memItemLeft" align="right" valign="top"><a id="abbc8543d03ed7464149e6dba20f77da1"></a>
const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#abbc8543d03ed7464149e6dba20f77da1">get_constraint</a> (int index)</td></tr>
<tr class="memdesc:abbc8543d03ed7464149e6dba20f77da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indicated constraint. Numbering starts at 0. <br /></td></tr>
<tr class="separator:abbc8543d03ed7464149e6dba20f77da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:ac6e9aadc18f4f7e0d3860682cae3bdf7"><td class="memItemLeft" align="right" valign="top"><a id="ac6e9aadc18f4f7e0d3860682cae3bdf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ac6e9aadc18f4f7e0d3860682cae3bdf7">which_constraints_active_at</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;u, bool *result) const</td></tr>
<tr class="memdesc:ac6e9aadc18f4f7e0d3860682cae3bdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the set of constraints in the skeleton active at <code>u</code> <br /></td></tr>
<tr class="separator:ac6e9aadc18f4f7e0d3860682cae3bdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4c6e4864a90140728d664c8de12cf"><td class="memItemLeft" align="right" valign="top"><a id="a97d4c6e4864a90140728d664c8de12cf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a97d4c6e4864a90140728d664c8de12cf">is_consistent</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;c) const</td></tr>
<tr class="memdesc:a97d4c6e4864a90140728d664c8de12cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a potentially new constraint. <br /></td></tr>
<tr class="separator:a97d4c6e4864a90140728d664c8de12cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:adf50f125e2bfc6834fdd93e3fff22c48"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#adf50f125e2bfc6834fdd93e3fff22c48">solve</a> (const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;) override</td></tr>
<tr class="memdesc:adf50f125e2bfc6834fdd93e3fff22c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the skeleton.  <a href="#adf50f125e2bfc6834fdd93e3fff22c48">More...</a><br /></td></tr>
<tr class="separator:adf50f125e2bfc6834fdd93e3fff22c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0e821ab6a683ab4f936b7552074a15"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3b0e821ab6a683ab4f936b7552074a15">solve</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;) override</td></tr>
<tr class="memdesc:a3b0e821ab6a683ab4f936b7552074a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the skeleton.  <a href="#a3b0e821ab6a683ab4f936b7552074a15">More...</a><br /></td></tr>
<tr class="separator:a3b0e821ab6a683ab4f936b7552074a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e67ca8a8fc7a891534462c21051ea1"><td class="memItemLeft" align="right" valign="top"><a id="a91e67ca8a8fc7a891534462c21051ea1"></a>
set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a91e67ca8a8fc7a891534462c21051ea1">adjacencies_by_graphs</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a91e67ca8a8fc7a891534462c21051ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-computes the edges in the skeleton using Zolotych's <code>GraphAdj</code> algorithm and returns the result. <br /></td></tr>
<tr class="separator:a91e67ca8a8fc7a891534462c21051ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca243248975b2f1935169d78c44033b"><td class="memItemLeft" align="right" valign="top"><a id="a6ca243248975b2f1935169d78c44033b"></a>
<a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6ca243248975b2f1935169d78c44033b">operator=</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;)</td></tr>
<tr class="memdesc:a6ca243248975b2f1935169d78c44033b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator; empties current set &amp; copies from other. <br /></td></tr>
<tr class="separator:a6ca243248975b2f1935169d78c44033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memitem:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a1d530b23b2516c36cbc02173e667d0cf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1d530b23b2516c36cbc02173e667d0cf">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a1d530b23b2516c36cbc02173e667d0cf inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d455722e6ae8b0bc9928dcd1bfa48 inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a7a8d455722e6ae8b0bc9928dcd1bfa48"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7a8d455722e6ae8b0bc9928dcd1bfa48">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:a7a8d455722e6ae8b0bc9928dcd1bfa48 inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a7a8d455722e6ae8b0bc9928dcd1bfa48 inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f67af66c81db467a6366f48ba3c8 inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8328f67af66c81db467a6366f48ba3c8">get_rays</a> () const</td></tr>
<tr class="memdesc:a8328f67af66c81db467a6366f48ba3c8 inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns rays that define a skeleton.  <a href="group___c_l_s_solvers.html#a8328f67af66c81db467a6366f48ba3c8">More...</a><br /></td></tr>
<tr class="separator:a8328f67af66c81db467a6366f48ba3c8 inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2ef4e520631f5ad73d3cddffc832a1 inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a4b2ef4e520631f5ad73d3cddffc832a1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4b2ef4e520631f5ad73d3cddffc832a1">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false) const</td></tr>
<tr class="memdesc:a4b2ef4e520631f5ad73d3cddffc832a1 inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a4b2ef4e520631f5ad73d3cddffc832a1 inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a54f8dc187ec3e238ccc80d7a44b9ca82"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a54f8dc187ec3e238ccc80d7a44b9ca82">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;s)</td></tr>
<tr class="memdesc:a54f8dc187ec3e238ccc80d7a44b9ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints out the constraints, then the rays, then the edges of <code>s</code>.  <a href="#a54f8dc187ec3e238ccc80d7a44b9ca82">More...</a><br /></td></tr>
<tr class="separator:a54f8dc187ec3e238ccc80d7a44b9ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solvers::LP_Solver</a></td></tr>
<tr class="memitem:ad4c9fb3708c156496c23515c8e841374 inherit pro_attribs_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad4c9fb3708c156496c23515c8e841374">rays</a></td></tr>
<tr class="separator:ad4c9fb3708c156496c23515c8e841374 inherit pro_attribs_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ad9f2f64c49dbf96ebd30852e670e7642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f2f64c49dbf96ebd30852e670e7642">&#9670;&nbsp;</a></span>Skeleton() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Skeleton::Skeleton </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a basic skeleton in the given number of dimensions, initialized to the axes, or (equivalently) to the set of constraints \( x_i \geq 0 \). </p>
<p>The rays are informed of their active constraints. </p><dl class="section pre"><dt>Precondition</dt><dd>the argument should be at least two </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the skeleton of the positive orthant </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00124">124</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="ad61d70c2397e93141de3ad3c987b1828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61d70c2397e93141de3ad3c987b1828">&#9670;&nbsp;</a></span>Skeleton() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LP_Solvers::Skeleton::Skeleton </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a skeleton described by the given system of constraints. </p>
<p>Practically speaking, it first generates a basic skeleton, then iterates on the given constraints. </p><dl class="section pre"><dt>Precondition</dt><dd><code>u.size() == v.size()</code> for all <code>u</code>, <code>v</code> in the vector </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>unless the system supplied was inconsistent, a valid skeleton of the corresponding polyhedral cone </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Your program will almost certainly fail if you do not respect the precondition. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00129">129</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a242f1dc35468e2326e6f7c10bc0d0fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242f1dc35468e2326e6f7c10bc0d0fd4">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::Skeleton::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a36c14a88e9d3ae9d9321acc7877236d0">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00145">145</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="adf50f125e2bfc6834fdd93e3fff22c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf50f125e2bfc6834fdd93e3fff22c48">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::Skeleton::solve </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the skeleton. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#aea1a5bf98a2c4c06b0550cacdf8b88fd">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00275">275</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a3b0e821ab6a683ab4f936b7552074a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0e821ab6a683ab4f936b7552074a15">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::Skeleton::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the skeleton. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a8b9979fb228ac9ccfe037ad6ca48b314">LP_Solvers::LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00167">167</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="a54f8dc187ec3e238ccc80d7a44b9ca82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f8dc187ec3e238ccc80d7a44b9ca82">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_skeleton">Skeleton</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints out the constraints, then the rays, then the edges of <code>s</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream to print to </td></tr>
    <tr><td class="paramname">s</td><td>skeleton to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00440">440</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf3434d5c281c16ef7a09d8f73445ea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3434d5c281c16ef7a09d8f73445ea00">&#9670;&nbsp;</a></span>intersections_of_active_constraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt; LP_Solvers::intersections_of_active_constraints </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicates which constraints are active for both sets </p>
<dl class="section return"><dt>Returns</dt><dd>the intersection between the given sets of constraints. </dd></dl>

</div>
</div>
<a id="ga1f87ac127ced7d681b3e51e38eef0cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f87ac127ced7d681b3e51e38eef0cf4">&#9670;&nbsp;</a></span>intersections_of_active_constraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LP_Solvers::intersections_of_active_constraints </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicates which constraints are active for both sets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first set </td></tr>
    <tr><td class="paramname">b</td><td>second set </td></tr>
    <tr><td class="paramname">result</td><td>set where <code>true</code> occurs only if it does in both <code>a</code> and <code>b</code> </td></tr>
    <tr><td class="paramname">m</td><td>number of entries in <code>a</code> and <code>b</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection between the given sets of constraints. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00321">321</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="ga0a997634a9b11bec9c54d0243ac29008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a997634a9b11bec9c54d0243ac29008">&#9670;&nbsp;</a></span>is_first_subset_of_second()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LP_Solvers::is_first_subset_of_second </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines whether the first set of active constraints is a subset of the second </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the first set is a subset of the second. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00335">335</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="gad030de457424bef601e2903eb619926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad030de457424bef601e2903eb619926e">&#9670;&nbsp;</a></span>number_of_common_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LP_Solvers::number_of_common_constraints </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>counts the number of constraints active in both sets </p>
<dl class="section return"><dt>Returns</dt><dd>the number of constraints common to both sets. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00302">302</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="gaf71a7e68f920518b02b6a58660594ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71a7e68f920518b02b6a58660594ca2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> LP_Solvers::operator* </td>
          <td>(</td>
          <td class="paramtype">const RAYENT_TYPE&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply every coordinate in the given ray by the given scalar. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the ray, scaled by the requesed amount </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00224">224</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gaae1f5d07b6d0f4c12b4c7835977b64eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae1f5d07b6d0f4c12b4c7835977b64eb">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RAYENT_TYPE LP_Solvers::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product on the rays. </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the rays </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00237">237</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ga9b4f6991b325c2a42e1f14fc09346277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b4f6991b325c2a42e1f14fc09346277">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RAYENT_TYPE LP_Solvers::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the dot product of the specified rays, one of which is a vector </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00245">245</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gab64c33abcc54e5b175b7b567e099c75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab64c33abcc54e5b175b7b567e099c75b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RAYENT_TYPE LP_Solvers::operator* </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the dot product of the specified rays, one of which is a vector </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00253">253</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gaea75db1559315f35242d62e9e5f66e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea75db1559315f35242d62e9e5f66e92">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DOTPROD_TYPE LP_Solvers::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between the ray and the constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a ray </td></tr>
    <tr><td class="paramname">c</td><td>a constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the ray and the constraint </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00525">525</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="gaf9f83e5d45bfc080fbffde26ebb93892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f83e5d45bfc080fbffde26ebb93892">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DOTPROD_TYPE LP_Solvers::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between the ray and the constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_constraint" title="a constraint  ">Constraint</a> </td></tr>
    <tr><td class="paramname">r</td><td>a ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the ray and the constraint </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00537">537</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="gaf293c6d803dc697897463525aa1d1d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf293c6d803dc697897463525aa1d1d44">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> LP_Solvers::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the two rays. </p>
<dl class="section return"><dt>Returns</dt><dd>the sum of the two rays </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00261">261</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gac20f6443d37909c326bb31c0399ea634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20f6443d37909c326bb31c0399ea634">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> LP_Solvers::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the two rays. </p>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two rays </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00272">272</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ga42f6aa14b6c3adb4df26f8338d486401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f6aa14b6c3adb4df26f8338d486401">&#9670;&nbsp;</a></span>ray_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> LP_Solvers::ray_sum </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_ray">Ray</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all the rays in a set. </p>
<dl class="section return"><dt>Returns</dt><dd>a ray that is the sum of all rays in the given set </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00283">283</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ga8b57096f9dac0f00912dd248cfdc89db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b57096f9dac0f00912dd248cfdc89db">&#9670;&nbsp;</a></span>union_of_edge_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; LP_Solvers::union_of_edge_sets </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="group___c_l_s_solvers.html#class_l_p___solvers_1_1_edge">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the union of the specified edge sets </p>
<dl class="section return"><dt>Returns</dt><dd>union of the specified edge sets </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00347">347</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

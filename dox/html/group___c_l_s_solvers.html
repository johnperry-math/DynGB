<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gröbner basis project: Constrained Linear System Solvers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gröbner basis project
   </div>
   <div id="projectbrief">Codebase for research into Gröbner basis computation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___c_l_s_solvers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Constrained Linear System Solvers</div>  </div>
</div><!--header-->
<div class="contents">

<p>classes that solve constrained linear systems  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classconstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a></td></tr>
<tr class="memdesc:classconstraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">a constraint \( c_1 x_1 + \ldots + c_n x_n \geq 0 \)  <a href="group___c_l_s_solvers.html#classconstraint">More...</a><br /></td></tr>
<tr class="separator:classconstraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classedge"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#classedge">edge</a></td></tr>
<tr class="memdesc:classedge"><td class="mdescLeft">&#160;</td><td class="mdescRight">an edge \((r_1,r_2)\) connecting the two rays \( r_1 \) and \( r_2 \)  <a href="group___c_l_s_solvers.html#classedge">More...</a><br /></td></tr>
<tr class="separator:classedge"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_g_l_p_k___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver">GLPK_Solver</a></td></tr>
<tr class="memdesc:class_g_l_p_k___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximate skeleton of a polyhedral cone, using GLPK linear solver  <a href="group___c_l_s_solvers.html#class_g_l_p_k___solver">More...</a><br /></td></tr>
<tr class="separator:class_g_l_p_k___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_l_p___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memdesc:class_l_p___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">exact or approximate polyhedral cone solution, with methods allowing definition and refinement  <a href="group___c_l_s_solvers.html#class_l_p___solver">More...</a><br /></td></tr>
<tr class="separator:class_l_p___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_p_p_l___solver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#class_p_p_l___solver">PPL_Solver</a></td></tr>
<tr class="memdesc:class_p_p_l___solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">approximate skeleton of a polyhedral cone, using PPL linear solver  <a href="group___c_l_s_solvers.html#class_p_p_l___solver">More...</a><br /></td></tr>
<tr class="separator:class_p_p_l___solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a></td></tr>
<tr class="memdesc:classray"><td class="mdescLeft">&#160;</td><td class="mdescRight">a ray defined by nonnegative coordinates \((a_1,\ldots,a_n)\)  <a href="group___c_l_s_solvers.html#classray">More...</a><br /></td></tr>
<tr class="separator:classray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classskeleton"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#classskeleton">skeleton</a></td></tr>
<tr class="memdesc:classskeleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">skeleton of a polyhedral cone, with methods allowing definition and refinement  <a href="group___c_l_s_solvers.html#classskeleton">More...</a><br /></td></tr>
<tr class="separator:classskeleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb5ce7e22db91b33c26ea0be6a6026de"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gacb5ce7e22db91b33c26ea0be6a6026de">intersections_of_active_constraints</a> (bool *, bool *, unsigned)</td></tr>
<tr class="separator:gacb5ce7e22db91b33c26ea0be6a6026de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bebd50facdc36f850371e545f82174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga06bebd50facdc36f850371e545f82174">is_first_subset_of_second</a> (bool *, bool *, unsigned)</td></tr>
<tr class="separator:ga06bebd50facdc36f850371e545f82174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33829eddeaa7be000404e4d281d90973"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga33829eddeaa7be000404e4d281d90973">number_of_common_constraints</a> (bool *, bool *, unsigned)</td></tr>
<tr class="separator:ga33829eddeaa7be000404e4d281d90973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae039f9fb46b8c57063342f6203add523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gae039f9fb46b8c57063342f6203add523">operator*</a> (RAYENT_TYPE, <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:gae039f9fb46b8c57063342f6203add523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply every coordinate in the given ray by the given scalar.  <a href="#gae039f9fb46b8c57063342f6203add523">More...</a><br /></td></tr>
<tr class="separator:gae039f9fb46b8c57063342f6203add523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30af4b27086e461f862e7d16e9d209df"><td class="memItemLeft" align="right" valign="top">RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga30af4b27086e461f862e7d16e9d209df">operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:ga30af4b27086e461f862e7d16e9d209df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product on the rays.  <a href="#ga30af4b27086e461f862e7d16e9d209df">More...</a><br /></td></tr>
<tr class="separator:ga30af4b27086e461f862e7d16e9d209df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22c25c0110c6684317aaf0e50c2e9a0"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gac22c25c0110c6684317aaf0e50c2e9a0">operator*</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;r, const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;c)</td></tr>
<tr class="memdesc:gac22c25c0110c6684317aaf0e50c2e9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between the ray and the constraint.  <a href="#gac22c25c0110c6684317aaf0e50c2e9a0">More...</a><br /></td></tr>
<tr class="separator:gac22c25c0110c6684317aaf0e50c2e9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240d91c518c3bfe3817504de43039022"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga240d91c518c3bfe3817504de43039022">operator*</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;c, <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;r)</td></tr>
<tr class="memdesc:ga240d91c518c3bfe3817504de43039022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between the ray and the constraint.  <a href="#ga240d91c518c3bfe3817504de43039022">More...</a><br /></td></tr>
<tr class="separator:ga240d91c518c3bfe3817504de43039022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa48bb668551858c8d53e230546042ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gaaa48bb668551858c8d53e230546042ba">operator+</a> (<a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:gaaa48bb668551858c8d53e230546042ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the two rays.  <a href="#gaaa48bb668551858c8d53e230546042ba">More...</a><br /></td></tr>
<tr class="separator:gaaa48bb668551858c8d53e230546042ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb092cfc55771c4303f540cb7697a40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gafcb092cfc55771c4303f540cb7697a40">operator-</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:gafcb092cfc55771c4303f540cb7697a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the two rays.  <a href="#gafcb092cfc55771c4303f540cb7697a40">More...</a><br /></td></tr>
<tr class="separator:gafcb092cfc55771c4303f540cb7697a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb95c2b09dc0a5ea693a99cb8340ff28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#gafb95c2b09dc0a5ea693a99cb8340ff28">ray_sum</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt; &amp;)</td></tr>
<tr class="memdesc:gafb95c2b09dc0a5ea693a99cb8340ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the rays in a set.  <a href="#gafb95c2b09dc0a5ea693a99cb8340ff28">More...</a><br /></td></tr>
<tr class="separator:gafb95c2b09dc0a5ea693a99cb8340ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6dbec1643b53f8e613b0a3de07f3ce"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ga2b6dbec1643b53f8e613b0a3de07f3ce">union_of_edge_sets</a> (const set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt; &amp;, const set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt; &amp;)</td></tr>
<tr class="separator:ga2b6dbec1643b53f8e613b0a3de07f3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>classes that solve constrained linear systems </p>
<p>Classes in this group solve constrained linear systems; that is, they solve systems of the form \(\left\{\sum_{j=1}^na_{ij}x_j\leq b_i\right\}_{i=1}^m\) (where the inequality may or may not be strict). </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classconstraint" id="classconstraint"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classconstraint">&#9670;&nbsp;</a></span>constraint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class constraint</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>a constraint \( c_1 x_1 + \ldots + c_n x_n \geq 0 \) </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates a simple constraint for a skeleton; that is, an inequality of the form \( c_1 x_1 + \ldots + c_n x_n \geq 0 \). Constraints can be ordered lexicographically using the less-than operator, allowing for their inclusion in ordered collections, such as sets. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00053">53</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:aac499533508fc7e6fcdfad614dbecc48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aac499533508fc7e6fcdfad614dbecc48">constraint</a> (NVAR_TYPE, CONSTR_TYPE [])</td></tr>
<tr class="memdesc:aac499533508fc7e6fcdfad614dbecc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize constraint to the given coefficients.  <a href="#aac499533508fc7e6fcdfad614dbecc48">More...</a><br /></td></tr>
<tr class="separator:aac499533508fc7e6fcdfad614dbecc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf2ec568e0dcfd37c2dc150b738ad2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#abcf2ec568e0dcfd37c2dc150b738ad2d">constraint</a> (vector&lt; CONSTR_TYPE &gt; &amp;)</td></tr>
<tr class="memdesc:abcf2ec568e0dcfd37c2dc150b738ad2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize constraint to the given coefficients.  <a href="#abcf2ec568e0dcfd37c2dc150b738ad2d">More...</a><br /></td></tr>
<tr class="separator:abcf2ec568e0dcfd37c2dc150b738ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796ee0ed5407fb1e4a4774156f0faac9"><td class="memItemLeft" align="right" valign="top"><a id="a796ee0ed5407fb1e4a4774156f0faac9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a796ee0ed5407fb1e4a4774156f0faac9">constraint</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;)</td></tr>
<tr class="memdesc:a796ee0ed5407fb1e4a4774156f0faac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the coefficients of the other constraint, including the allocation of new memory. <br /></td></tr>
<tr class="separator:a796ee0ed5407fb1e4a4774156f0faac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a02e58b1ce0b271e3daac2da841152582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a02e58b1ce0b271e3daac2da841152582">~constraint</a> ()</td></tr>
<tr class="memdesc:a02e58b1ce0b271e3daac2da841152582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes memory allocated by the constructor.  <a href="#a02e58b1ce0b271e3daac2da841152582">More...</a><br /></td></tr>
<tr class="separator:a02e58b1ce0b271e3daac2da841152582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a829b1dbba361c34d021ebe82ccf5cb7f"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a829b1dbba361c34d021ebe82ccf5cb7f">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;)</td></tr>
<tr class="memdesc:a829b1dbba361c34d021ebe82ccf5cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a representation of the constraint to the stream  <a href="#a829b1dbba361c34d021ebe82ccf5cb7f">More...</a><br /></td></tr>
<tr class="separator:a829b1dbba361c34d021ebe82ccf5cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Basic properties</h3></td></tr>
<tr class="memitem:a62f9d6527236b92bce67ef3251ba1fae"><td class="memItemLeft" align="right" valign="top"><a id="a62f9d6527236b92bce67ef3251ba1fae"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a62f9d6527236b92bce67ef3251ba1fae">get_number_of_variables</a> () const</td></tr>
<tr class="memdesc:a62f9d6527236b92bce67ef3251ba1fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables in the constraint. <br /></td></tr>
<tr class="separator:a62f9d6527236b92bce67ef3251ba1fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab075ba7c8fa216eff36aeee8fc5552e"><td class="memItemLeft" align="right" valign="top"><a id="aab075ba7c8fa216eff36aeee8fc5552e"></a>
CONSTR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aab075ba7c8fa216eff36aeee8fc5552e">operator[]</a> (NVAR_TYPE index) const</td></tr>
<tr class="memdesc:aab075ba7c8fa216eff36aeee8fc5552e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficient indicated. Numbering starts at 0. <br /></td></tr>
<tr class="separator:aab075ba7c8fa216eff36aeee8fc5552e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70165b34389dbe7e58d757e1f16bd8d"><td class="memItemLeft" align="right" valign="top"><a id="ac70165b34389dbe7e58d757e1f16bd8d"></a>
const CONSTR_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ac70165b34389dbe7e58d757e1f16bd8d">coeffs</a> () const</td></tr>
<tr class="memdesc:ac70165b34389dbe7e58d757e1f16bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficients that determine this constraints. <br /></td></tr>
<tr class="separator:ac70165b34389dbe7e58d757e1f16bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc988c4f28198ecc105f60eddfbfddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aecc988c4f28198ecc105f60eddfbfddc">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;b)</td></tr>
<tr class="memdesc:aecc988c4f28198ecc105f60eddfbfddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of constraints.  <a href="#aecc988c4f28198ecc105f60eddfbfddc">More...</a><br /></td></tr>
<tr class="separator:aecc988c4f28198ecc105f60eddfbfddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6f7858d12f0c03f1c8be86ecbef902"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#acb6f7858d12f0c03f1c8be86ecbef902">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;b)</td></tr>
<tr class="memdesc:acb6f7858d12f0c03f1c8be86ecbef902"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint equality  <a href="#acb6f7858d12f0c03f1c8be86ecbef902">More...</a><br /></td></tr>
<tr class="separator:acb6f7858d12f0c03f1c8be86ecbef902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b57d19474acdea10ab0a0e954ef3ef9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6b57d19474acdea10ab0a0e954ef3ef9">operator!=</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;a, const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;b)</td></tr>
<tr class="memdesc:a6b57d19474acdea10ab0a0e954ef3ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint inequality  <a href="#a6b57d19474acdea10ab0a0e954ef3ef9">More...</a><br /></td></tr>
<tr class="separator:a6b57d19474acdea10ab0a0e954ef3ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee7037f652ba94155890c109b88ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a75ee7037f652ba94155890c109b88ef8">operator!=</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;a, <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;b)</td></tr>
<tr class="memdesc:a75ee7037f652ba94155890c109b88ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for constraint inequality  <a href="#a75ee7037f652ba94155890c109b88ef8">More...</a><br /></td></tr>
<tr class="separator:a75ee7037f652ba94155890c109b88ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="aac499533508fc7e6fcdfad614dbecc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac499533508fc7e6fcdfad614dbecc48">&#9670;&nbsp;</a></span>constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constraint::constraint </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>num_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTR_TYPE&#160;</td>
          <td class="paramname"><em>coeffs</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize constraint to the given coefficients. </p>
<p>The resulting constraint is \( c_1x_1 + \cdots + c_nx_n \geq 0, \) where \( c_i \) is the coefficient of \( x_i \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_variables</td><td>length of coeffs </td></tr>
    <tr><td class="paramname">coeffs</td><td>copies this array of coefficients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the size of the array needs to be at least as long as the dimension! </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00023">23</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="abcf2ec568e0dcfd37c2dc150b738ad2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf2ec568e0dcfd37c2dc150b738ad2d">&#9670;&nbsp;</a></span>constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constraint::constraint </td>
          <td>(</td>
          <td class="paramtype">vector&lt; CONSTR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize constraint to the given coefficients. </p>
<p>The resulting constraint is \( c_1x_1 + \cdots + c_nx_n \geq 0, \) where \( c_i \) is the coefficient of \( x_i \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>copies thiis vector of coefficients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>nvars</code> will have the value equal to <code>coeffs.size()</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00031">31</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a02e58b1ce0b271e3daac2da841152582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e58b1ce0b271e3daac2da841152582">&#9670;&nbsp;</a></span>~constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constraint::~constraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes memory allocated by the constructor. </p>
<p>Currently, that means it deletes an array created by the constructors. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00111">111</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="a6b57d19474acdea10ab0a0e954ef3ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b57d19474acdea10ab0a0e954ef3ef9">&#9670;&nbsp;</a></span>operator!= <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check for constraint inequality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a constraint </td></tr>
    <tr><td class="paramname">b</td><td>a constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

</div>
</div>
<a id="a75ee7037f652ba94155890c109b88ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ee7037f652ba94155890c109b88ef8">&#9670;&nbsp;</a></span>operator!= <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check for constraint inequality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a constraint </td></tr>
    <tr><td class="paramname">b</td><td>a constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00071">71</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="aecc988c4f28198ecc105f60eddfbfddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc988c4f28198ecc105f60eddfbfddc">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographic comparison of constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a constraint </td></tr>
    <tr><td class="paramname">b</td><td>a constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00048">48</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a829b1dbba361c34d021ebe82ccf5cb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829b1dbba361c34d021ebe82ccf5cb7f">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print a representation of the constraint to the stream </p>
<p>Output is of the form \( c_1 x_1 + \ldots + c_n x_n \) , where \( c_i \) is the coefficient of \( x_i \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00081">81</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="acb6f7858d12f0c03f1c8be86ecbef902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6f7858d12f0c03f1c8be86ecbef902">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check for constraint equality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a constraint </td></tr>
    <tr><td class="paramname">b</td><td>a constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00061">61</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classedge" id="classedge"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classedge">&#9670;&nbsp;</a></span>edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class edge</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>an edge \((r_1,r_2)\) connecting the two rays \( r_1 \) and \( r_2 \) </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates an edge, the other major part of a skeleton. Edges describe how the rays of the skeleton are connected. Edges are ordered, so that the smaller ray always comes first.</p>
<dl class="section warning"><dt>Warning</dt><dd>An edge's rays should have the same dimension. To start with, it doesn't make mathematical sense to &ldquo;join&rdquo; two rays of different dimension. Moreover, comparison of edges requires comparison of rays,which requires that the rays have the same dimension. (But you wouldn't be dumb enough to do this in the first place.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00058">58</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a80e74eefbaf1864ae1297fe2cea223ad"><td class="memItemLeft" align="right" valign="top"><a id="a80e74eefbaf1864ae1297fe2cea223ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a80e74eefbaf1864ae1297fe2cea223ad">edge</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:a80e74eefbaf1864ae1297fe2cea223ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new edge that joins the two rays. <br /></td></tr>
<tr class="separator:a80e74eefbaf1864ae1297fe2cea223ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cf571922e2c7609ddeccaa24df1b59"><td class="memItemLeft" align="right" valign="top"><a id="a93cf571922e2c7609ddeccaa24df1b59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a93cf571922e2c7609ddeccaa24df1b59">edge</a> (const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;)</td></tr>
<tr class="memdesc:a93cf571922e2c7609ddeccaa24df1b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the rays in <code>other</code> to two new rays. <br /></td></tr>
<tr class="separator:a93cf571922e2c7609ddeccaa24df1b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a6295b7f8e62fa95cd887fb78d64347f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6295b7f8e62fa95cd887fb78d64347f5">~edge</a> ()</td></tr>
<tr class="separator:a6295b7f8e62fa95cd887fb78d64347f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:a7c35e5555bd71f1e9f6231216b8c882e"><td class="memItemLeft" align="right" valign="top"><a id="a7c35e5555bd71f1e9f6231216b8c882e"></a>
<a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7c35e5555bd71f1e9f6231216b8c882e">get_first_ray</a> () const</td></tr>
<tr class="memdesc:a7c35e5555bd71f1e9f6231216b8c882e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ray listed in this edge. <br /></td></tr>
<tr class="separator:a7c35e5555bd71f1e9f6231216b8c882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baca8d9ca7f40edfb9364df3ec4c4a8"><td class="memItemLeft" align="right" valign="top"><a id="a2baca8d9ca7f40edfb9364df3ec4c4a8"></a>
<a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a2baca8d9ca7f40edfb9364df3ec4c4a8">get_second_ray</a> () const</td></tr>
<tr class="memdesc:a2baca8d9ca7f40edfb9364df3ec4c4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second ray listed in this edge. <br /></td></tr>
<tr class="separator:a2baca8d9ca7f40edfb9364df3ec4c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:acd5e308a604773f2d414732b6a873032"><td class="memItemLeft" align="right" valign="top"><a id="acd5e308a604773f2d414732b6a873032"></a>
<a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#acd5e308a604773f2d414732b6a873032">operator=</a> (const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;)</td></tr>
<tr class="memdesc:acd5e308a604773f2d414732b6a873032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:acd5e308a604773f2d414732b6a873032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:a87086330455166d1fe4bb71be060fbcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a87086330455166d1fe4bb71be060fbcc">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;e1, const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;e2)</td></tr>
<tr class="memdesc:a87086330455166d1fe4bb71be060fbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal if and only if.  <a href="#a87086330455166d1fe4bb71be060fbcc">More...</a><br /></td></tr>
<tr class="separator:a87086330455166d1fe4bb71be060fbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983f5438e6720d3bc1d7763c0c04fcae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a983f5438e6720d3bc1d7763c0c04fcae">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;)</td></tr>
<tr class="memdesc:a983f5438e6720d3bc1d7763c0c04fcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two edges lexicographically.  <a href="#a983f5438e6720d3bc1d7763c0c04fcae">More...</a><br /></td></tr>
<tr class="separator:a983f5438e6720d3bc1d7763c0c04fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:aad6bb96213a9839cb6b32592a4105f53"><td class="memItemLeft" align="right" valign="top"><a id="aad6bb96213a9839cb6b32592a4105f53"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aad6bb96213a9839cb6b32592a4105f53">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;)</td></tr>
<tr class="memdesc:aad6bb96213a9839cb6b32592a4105f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output has the form \( \{ \mathbf{r}_1, \mathbf{r}_2 \} \) where \( \mathbf{r}_1 \) is the first ray in this edge, etc. <br /></td></tr>
<tr class="separator:aad6bb96213a9839cb6b32592a4105f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a6295b7f8e62fa95cd887fb78d64347f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6295b7f8e62fa95cd887fb78d64347f5">&#9670;&nbsp;</a></span>~edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">edge::~edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does nothing beyond what the compiler would do. </p>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00076">76</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="a983f5438e6720d3bc1d7763c0c04fcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983f5438e6720d3bc1d7763c0c04fcae">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two edges lexicographically. </p>
<p>If the first ray in <code>this</code> edge is smaller, then <code>this</code> edge is smaller. Otherwise, if the first rays are equal, and the second ray in <code>this</code> edge is smaller, then <code>this</code> edge is smaller. </p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00058">58</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a87086330455166d1fe4bb71be060fbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87086330455166d1fe4bb71be060fbcc">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equal if and only if. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>an edge </td></tr>
    <tr><td class="paramname">e2</td><td>an edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the linked rays are identical </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00100">100</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_g_l_p_k___solver" id="class_g_l_p_k___solver"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_g_l_p_k___solver">&#9670;&nbsp;</a></span>GLPK_Solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class GLPK_Solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>approximate skeleton of a polyhedral cone, using GLPK linear solver </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2017 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class serves as an interface to GLPK <a class="el" href="citelist.html#CITEREF_glpk">[8]</a>, which we can use to find an approximate skeleton to a polyhedral cone. </p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8hpp_source.html#l00037">37</a> of file <a class="el" href="glpk__solver_8hpp_source.html">glpk_solver.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for GLPK_Solver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#GLPK_5FSolver_map" alt=""/>
  <map id="GLPK_5FSolver_map" name="GLPK_5FSolver_map">
<area href="group___c_l_s_solvers.html#class_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ..." alt="LP_Solver" shape="rect" coords="0,0,88,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a290ed6f0f6be3c6edf5ec5b5f5bfbb3a"><td class="memItemLeft" align="right" valign="top"><a id="a290ed6f0f6be3c6edf5ec5b5f5bfbb3a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a290ed6f0f6be3c6edf5ec5b5f5bfbb3a">GLPK_Solver</a> (NVAR_TYPE n)</td></tr>
<tr class="memdesc:a290ed6f0f6be3c6edf5ec5b5f5bfbb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes solver for \( n \) variables <br /></td></tr>
<tr class="separator:a290ed6f0f6be3c6edf5ec5b5f5bfbb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbd7db2555c39cb789fa45a8ad22f8f"><td class="memItemLeft" align="right" valign="top"><a id="a6cbd7db2555c39cb789fa45a8ad22f8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6cbd7db2555c39cb789fa45a8ad22f8f">GLPK_Solver</a> (const <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver">GLPK_Solver</a> &amp;)</td></tr>
<tr class="memdesc:a6cbd7db2555c39cb789fa45a8ad22f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor (deep copy) <br /></td></tr>
<tr class="separator:a6cbd7db2555c39cb789fa45a8ad22f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3a58ef3def363dfad9e0ba8eee3e67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aff3a58ef3def363dfad9e0ba8eee3e67">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *)</td></tr>
<tr class="memdesc:aff3a58ef3def363dfad9e0ba8eee3e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#aff3a58ef3def363dfad9e0ba8eee3e67">More...</a><br /></td></tr>
<tr class="separator:aff3a58ef3def363dfad9e0ba8eee3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a4a4505a58f6d0f93a1c003797b39e468"><td class="memItemLeft" align="right" valign="top"><a id="a4a4505a58f6d0f93a1c003797b39e468"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~GLPK_Solver</b> ()</td></tr>
<tr class="separator:a4a4505a58f6d0f93a1c003797b39e468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:aa7ea7b9f4bb731fcb3b48991d33efe0a"><td class="memItemLeft" align="right" valign="top"><a id="aa7ea7b9f4bb731fcb3b48991d33efe0a"></a>
virtual NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa7ea7b9f4bb731fcb3b48991d33efe0a">get_dimension</a> () const</td></tr>
<tr class="memdesc:aa7ea7b9f4bb731fcb3b48991d33efe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:aa7ea7b9f4bb731fcb3b48991d33efe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae687af797043acd0e7621e75dd97b37a"><td class="memItemLeft" align="right" valign="top"><a id="ae687af797043acd0e7621e75dd97b37a"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae687af797043acd0e7621e75dd97b37a">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:ae687af797043acd0e7621e75dd97b37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:ae687af797043acd0e7621e75dd97b37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6239c7b6c914ba4c30e357d9fbc59c"><td class="memItemLeft" align="right" valign="top"><a id="abd6239c7b6c914ba4c30e357d9fbc59c"></a>
virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#abd6239c7b6c914ba4c30e357d9fbc59c">get_rays</a> ()</td></tr>
<tr class="memdesc:abd6239c7b6c914ba4c30e357d9fbc59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rays that define the skeleton. <br /></td></tr>
<tr class="separator:abd6239c7b6c914ba4c30e357d9fbc59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714f9e1e02b53d1a785297e86567b133"><td class="memItemLeft" align="right" valign="top"><a id="a714f9e1e02b53d1a785297e86567b133"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>get_number_of_constraints</b> ()</td></tr>
<tr class="separator:a714f9e1e02b53d1a785297e86567b133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:acb3a10f3961c65b4cf23ff61f0e2310b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#acb3a10f3961c65b4cf23ff61f0e2310b">solve</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;)</td></tr>
<tr class="memdesc:acb3a10f3961c65b4cf23ff61f0e2310b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the solution.  <a href="#acb3a10f3961c65b4cf23ff61f0e2310b">More...</a><br /></td></tr>
<tr class="separator:acb3a10f3961c65b4cf23ff61f0e2310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d800f0ec270c782e3cf855aa7f59f4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6d800f0ec270c782e3cf855aa7f59f4c">solve</a> (vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a6d800f0ec270c782e3cf855aa7f59f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the solution.  <a href="#a6d800f0ec270c782e3cf855aa7f59f4c">More...</a><br /></td></tr>
<tr class="separator:a6d800f0ec270c782e3cf855aa7f59f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:ad79040934b5bf246b24aa36f30403dce"><td class="memItemLeft" align="right" valign="top"><a id="ad79040934b5bf246b24aa36f30403dce"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ad79040934b5bf246b24aa36f30403dce">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false)</td></tr>
<tr class="memdesc:ad79040934b5bf246b24aa36f30403dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:ad79040934b5bf246b24aa36f30403dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memitem:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a3cdeb4d133d147bae2c071bd41ed10aa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3cdeb4d133d147bae2c071bd41ed10aa">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memitem:aa89c9167eb3ef921b57d74057217f407 inherit pro_attribs_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa89c9167eb3ef921b57d74057217f407">rays</a></td></tr>
<tr class="separator:aa89c9167eb3ef921b57d74057217f407 inherit pro_attribs_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="aff3a58ef3def363dfad9e0ba8eee3e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3a58ef3def363dfad9e0ba8eee3e67">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GLPK_Solver::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a442ad4ad67ee2feff0df49e9201d61ca">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00058">58</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>
<a id="acb3a10f3961c65b4cf23ff61f0e2310b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3a10f3961c65b4cf23ff61f0e2310b">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GLPK_Solver::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#abd84374c52124116becc8924dc74e12d">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00116">116</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>
<a id="a6d800f0ec270c782e3cf855aa7f59f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d800f0ec270c782e3cf855aa7f59f4c">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GLPK_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a35da4bdf5db971c445f495b6eaab072d">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="glpk__solver_8cpp_source.html#l00085">85</a> of file <a class="el" href="glpk__solver_8cpp_source.html">glpk_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_l_p___solver" id="class_l_p___solver"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_l_p___solver">&#9670;&nbsp;</a></span>LP_Solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LP_Solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>exact or approximate polyhedral cone solution, with methods allowing definition and refinement </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2017 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates the skeleton of a polyhedral cone, defined by a sequence of inequalities of the form \( c_1 x_1 + \cdots c_n x_n \geq 0 \).</p>
<dl class="section warning"><dt>Warning</dt><dd>Some classes may provide only an <em>approximate</em> cone; see, for example, <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>. In addition, Clients must ensure two things.<ol type="1">
<li>The rays must have the same number \( m \) of dimensions, constraints must have the same number \( n \) of variables, and \( m=n \). Violating any of these three conditions will lead to undesirable behavior.</li>
<li>When refining the cone, it is essential to check that the return value of <a class="el" href="group___c_l_s_solvers.html#abd84374c52124116becc8924dc74e12d" title="Adds the indicated constraint (singular!) and re-computes the solution. ">solve()</a> is <code>true</code>; for if it is not, then the cone is no longer be consistent. Please read the relevant documentation. </li>
</ol>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00504">504</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for LP_Solver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#LP_5FSolver_map" alt=""/>
  <map id="LP_5FSolver_map" name="LP_5FSolver_map">
<area href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver " alt="GLPK_Solver" shape="rect" coords="0,56,88,80"/>
<area href="group___c_l_s_solvers.html#class_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver " alt="PPL_Solver" shape="rect" coords="98,56,186,80"/>
<area href="group___c_l_s_solvers.html#classskeleton" title="skeleton of a polyhedral cone, with methods allowing definition and refinement " alt="skeleton" shape="rect" coords="196,56,284,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a442ad4ad67ee2feff0df49e9201d61ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a442ad4ad67ee2feff0df49e9201d61ca">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *)=0</td></tr>
<tr class="memdesc:a442ad4ad67ee2feff0df49e9201d61ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#a442ad4ad67ee2feff0df49e9201d61ca">More...</a><br /></td></tr>
<tr class="separator:a442ad4ad67ee2feff0df49e9201d61ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:a3cdeb4d133d147bae2c071bd41ed10aa"><td class="memItemLeft" align="right" valign="top"><a id="a3cdeb4d133d147bae2c071bd41ed10aa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3cdeb4d133d147bae2c071bd41ed10aa">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a3cdeb4d133d147bae2c071bd41ed10aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a3cdeb4d133d147bae2c071bd41ed10aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:abd84374c52124116becc8924dc74e12d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#abd84374c52124116becc8924dc74e12d">solve</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;)=0</td></tr>
<tr class="memdesc:abd84374c52124116becc8924dc74e12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the solution.  <a href="#abd84374c52124116becc8924dc74e12d">More...</a><br /></td></tr>
<tr class="separator:abd84374c52124116becc8924dc74e12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35da4bdf5db971c445f495b6eaab072d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a35da4bdf5db971c445f495b6eaab072d">solve</a> (vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;)=0</td></tr>
<tr class="memdesc:a35da4bdf5db971c445f495b6eaab072d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the solution.  <a href="#a35da4bdf5db971c445f495b6eaab072d">More...</a><br /></td></tr>
<tr class="separator:a35da4bdf5db971c445f495b6eaab072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properies</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Returns rays that define a skeleton.</p>
<p>When using an approximate solver such as <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, this will give only an approximate skeleton. </p>
</div></td></tr>
<tr class="memitem:ae85c7e9a24774fd3c08a7dd9a7b8a27c"><td class="memItemLeft" align="right" valign="top"><a id="ae85c7e9a24774fd3c08a7dd9a7b8a27c"></a>
virtual NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae85c7e9a24774fd3c08a7dd9a7b8a27c">get_dimension</a> () const =0</td></tr>
<tr class="memdesc:ae85c7e9a24774fd3c08a7dd9a7b8a27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:ae85c7e9a24774fd3c08a7dd9a7b8a27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262d944695d0cfcddf9e24908f72e8f"><td class="memItemLeft" align="right" valign="top"><a id="a4262d944695d0cfcddf9e24908f72e8f"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4262d944695d0cfcddf9e24908f72e8f">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:a4262d944695d0cfcddf9e24908f72e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a4262d944695d0cfcddf9e24908f72e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06363bbbc8dfdb4c161a001d24f94afd"><td class="memItemLeft" align="right" valign="top"><a id="a06363bbbc8dfdb4c161a001d24f94afd"></a>
virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a06363bbbc8dfdb4c161a001d24f94afd">get_rays</a> ()</td></tr>
<tr class="memdesc:a06363bbbc8dfdb4c161a001d24f94afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rays that define the skeleton. <br /></td></tr>
<tr class="separator:a06363bbbc8dfdb4c161a001d24f94afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b587fd39cbefe969e4b3dbf34387b08"><td class="memItemLeft" align="right" valign="top"><a id="a0b587fd39cbefe969e4b3dbf34387b08"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>get_number_of_constraints</b> ()=0</td></tr>
<tr class="separator:a0b587fd39cbefe969e4b3dbf34387b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:a2e909dd41a7f116c62868e3e6c278a2e"><td class="memItemLeft" align="right" valign="top"><a id="a2e909dd41a7f116c62868e3e6c278a2e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a2e909dd41a7f116c62868e3e6c278a2e">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false)</td></tr>
<tr class="memdesc:a2e909dd41a7f116c62868e3e6c278a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a2e909dd41a7f116c62868e3e6c278a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Attributes</h3></td></tr>
<tr class="memitem:aa89c9167eb3ef921b57d74057217f407"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa89c9167eb3ef921b57d74057217f407">rays</a></td></tr>
<tr class="separator:aa89c9167eb3ef921b57d74057217f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a442ad4ad67ee2feff0df49e9201d61ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442ad4ad67ee2feff0df49e9201d61ca">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LP_Solver::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#a42d30b92f27936eab11d0fa4f0cc10b4">skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#a67408174d2260de5ae5f070a70f27e9d">PPL_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#aff3a58ef3def363dfad9e0ba8eee3e67">GLPK_Solver</a>.</p>

</div>
</div>
<a id="abd84374c52124116becc8924dc74e12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd84374c52124116becc8924dc74e12d">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LP_Solver::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#a8add1433d3bc6b1a8588f0f88134599f">skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#acb3a10f3961c65b4cf23ff61f0e2310b">GLPK_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#a1ff16def22c734348c626b65437dd1e3">PPL_Solver</a>.</p>

</div>
</div>
<a id="a35da4bdf5db971c445f495b6eaab072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35da4bdf5db971c445f495b6eaab072d">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LP_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implemented in <a class="el" href="group___c_l_s_solvers.html#ac366952c2b0908159255916a1e37f9b3">skeleton</a>, <a class="el" href="group___c_l_s_solvers.html#a6d800f0ec270c782e3cf855aa7f59f4c">GLPK_Solver</a>, and <a class="el" href="group___c_l_s_solvers.html#a5000b8c5bee37029276ce63a3568bfb7">PPL_Solver</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="aa89c9167eb3ef921b57d74057217f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89c9167eb3ef921b57d74057217f407">&#9670;&nbsp;</a></span>rays</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;<a class="el" href="group___c_l_s_solvers.html#classray">ray</a>&gt; LP_Solver::rays</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the skeleton (may be approximate, depending on solver) </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00602">602</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="class_p_p_l___solver" id="class_p_p_l___solver"></a>
<h2 class="memtitle"><span class="permalink"><a href="#class_p_p_l___solver">&#9670;&nbsp;</a></span>PPL_Solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class PPL_Solver</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>approximate skeleton of a polyhedral cone, using PPL linear solver </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2017 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class serves as an interface to PPL <a class="el" href="citelist.html#CITEREF_BagnaraHZ08SCP">[1]</a>, which we can use to find the skeleton to a polyhedral cone. </p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8hpp_source.html#l00038">38</a> of file <a class="el" href="ppl__solver_8hpp_source.html">ppl_solver.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for PPL_Solver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#PPL_5FSolver_map" alt=""/>
  <map id="PPL_5FSolver_map" name="PPL_5FSolver_map">
<area href="group___c_l_s_solvers.html#class_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ..." alt="LP_Solver" shape="rect" coords="0,0,79,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a7484421e15572f77d014b2feb9d79f04"><td class="memItemLeft" align="right" valign="top"><a id="a7484421e15572f77d014b2feb9d79f04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7484421e15572f77d014b2feb9d79f04">PPL_Solver</a> (NVAR_TYPE <a class="el" href="group___c_l_s_solvers.html#aa70891def9af366c47e01acf952bbdba">n</a>)</td></tr>
<tr class="memdesc:a7484421e15572f77d014b2feb9d79f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes solver for \( n \) variables <br /></td></tr>
<tr class="separator:a7484421e15572f77d014b2feb9d79f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa1c2c02e059f35f9d9faca9e94f859"><td class="memItemLeft" align="right" valign="top"><a id="a7aa1c2c02e059f35f9d9faca9e94f859"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7aa1c2c02e059f35f9d9faca9e94f859">PPL_Solver</a> (const <a class="el" href="group___c_l_s_solvers.html#class_p_p_l___solver">PPL_Solver</a> &amp;)</td></tr>
<tr class="memdesc:a7aa1c2c02e059f35f9d9faca9e94f859"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor (deep copy) <br /></td></tr>
<tr class="separator:a7aa1c2c02e059f35f9d9faca9e94f859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67408174d2260de5ae5f070a70f27e9d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a67408174d2260de5ae5f070a70f27e9d">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *)</td></tr>
<tr class="memdesc:a67408174d2260de5ae5f070a70f27e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#a67408174d2260de5ae5f070a70f27e9d">More...</a><br /></td></tr>
<tr class="separator:a67408174d2260de5ae5f070a70f27e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:aecb2caed09777ca3b6d5e285540abe56"><td class="memItemLeft" align="right" valign="top"><a id="aecb2caed09777ca3b6d5e285540abe56"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PPL_Solver</b> ()</td></tr>
<tr class="separator:aecb2caed09777ca3b6d5e285540abe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:a40b49fb3bb0b14cc66cabf54ef17e437"><td class="memItemLeft" align="right" valign="top"><a id="a40b49fb3bb0b14cc66cabf54ef17e437"></a>
virtual NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a40b49fb3bb0b14cc66cabf54ef17e437">get_dimension</a> () const</td></tr>
<tr class="memdesc:a40b49fb3bb0b14cc66cabf54ef17e437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:a40b49fb3bb0b14cc66cabf54ef17e437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d09fe31148950d46219df67719aef3f"><td class="memItemLeft" align="right" valign="top"><a id="a7d09fe31148950d46219df67719aef3f"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>get_number_of_constraints</b> ()</td></tr>
<tr class="separator:a7d09fe31148950d46219df67719aef3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:a1ff16def22c734348c626b65437dd1e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1ff16def22c734348c626b65437dd1e3">solve</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;)</td></tr>
<tr class="memdesc:a1ff16def22c734348c626b65437dd1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the solution.  <a href="#a1ff16def22c734348c626b65437dd1e3">More...</a><br /></td></tr>
<tr class="separator:a1ff16def22c734348c626b65437dd1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5000b8c5bee37029276ce63a3568bfb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5000b8c5bee37029276ce63a3568bfb7">solve</a> (vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a5000b8c5bee37029276ce63a3568bfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the solution.  <a href="#a5000b8c5bee37029276ce63a3568bfb7">More...</a><br /></td></tr>
<tr class="separator:a5000b8c5bee37029276ce63a3568bfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00076ee1e8ef90f7d162f02372529666"><td class="memItemLeft" align="right" valign="top"><a id="a00076ee1e8ef90f7d162f02372529666"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a00076ee1e8ef90f7d162f02372529666">setup_rays</a> ()</td></tr>
<tr class="memdesc:a00076ee1e8ef90f7d162f02372529666"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear the current set of rays and extracts the ones contained in lp <br /></td></tr>
<tr class="separator:a00076ee1e8ef90f7d162f02372529666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memitem:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a3cdeb4d133d147bae2c071bd41ed10aa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3cdeb4d133d147bae2c071bd41ed10aa">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262d944695d0cfcddf9e24908f72e8f inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a4262d944695d0cfcddf9e24908f72e8f"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4262d944695d0cfcddf9e24908f72e8f">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:a4262d944695d0cfcddf9e24908f72e8f inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a4262d944695d0cfcddf9e24908f72e8f inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06363bbbc8dfdb4c161a001d24f94afd inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a06363bbbc8dfdb4c161a001d24f94afd"></a>
virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a06363bbbc8dfdb4c161a001d24f94afd">get_rays</a> ()</td></tr>
<tr class="memdesc:a06363bbbc8dfdb4c161a001d24f94afd inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rays that define the skeleton. <br /></td></tr>
<tr class="separator:a06363bbbc8dfdb4c161a001d24f94afd inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e909dd41a7f116c62868e3e6c278a2e inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a2e909dd41a7f116c62868e3e6c278a2e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a2e909dd41a7f116c62868e3e6c278a2e">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false)</td></tr>
<tr class="memdesc:a2e909dd41a7f116c62868e3e6c278a2e inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a2e909dd41a7f116c62868e3e6c278a2e inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Attributes</h3></td></tr>
<tr class="memitem:a6abc19f36a28ed91b4ebc4d3a1e32dc6"><td class="memItemLeft" align="right" valign="top"><a id="a6abc19f36a28ed91b4ebc4d3a1e32dc6"></a>
PPL::NNC_Polyhedron *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6abc19f36a28ed91b4ebc4d3a1e32dc6">lp</a></td></tr>
<tr class="memdesc:a6abc19f36a28ed91b4ebc4d3a1e32dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PPL problem interface. <br /></td></tr>
<tr class="separator:a6abc19f36a28ed91b4ebc4d3a1e32dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3852b048b35faf96d8a12155b0547e"><td class="memItemLeft" align="right" valign="top"><a id="a6e3852b048b35faf96d8a12155b0547e"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6e3852b048b35faf96d8a12155b0547e">m</a></td></tr>
<tr class="memdesc:a6e3852b048b35faf96d8a12155b0547e"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of constraints <br /></td></tr>
<tr class="separator:a6e3852b048b35faf96d8a12155b0547e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70891def9af366c47e01acf952bbdba"><td class="memItemLeft" align="right" valign="top"><a id="aa70891def9af366c47e01acf952bbdba"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa70891def9af366c47e01acf952bbdba">n</a></td></tr>
<tr class="memdesc:aa70891def9af366c47e01acf952bbdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of variables <br /></td></tr>
<tr class="separator:aa70891def9af366c47e01acf952bbdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bb9152de9b1260cdbf938010cd48b2"><td class="memItemLeft" align="right" valign="top"><a id="a90bb9152de9b1260cdbf938010cd48b2"></a>
RAYENT_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a90bb9152de9b1260cdbf938010cd48b2">ray_data</a></td></tr>
<tr class="memdesc:a90bb9152de9b1260cdbf938010cd48b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to retrieve rays <br /></td></tr>
<tr class="separator:a90bb9152de9b1260cdbf938010cd48b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157a18ab31b415a615bca9845248bfcc"><td class="memItemLeft" align="right" valign="top"><a id="a157a18ab31b415a615bca9845248bfcc"></a>
PPL::Variable **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a157a18ab31b415a615bca9845248bfcc">X</a></td></tr>
<tr class="memdesc:a157a18ab31b415a615bca9845248bfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of variables <br /></td></tr>
<tr class="separator:a157a18ab31b415a615bca9845248bfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memitem:aa89c9167eb3ef921b57d74057217f407 inherit pro_attribs_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa89c9167eb3ef921b57d74057217f407">rays</a></td></tr>
<tr class="separator:aa89c9167eb3ef921b57d74057217f407 inherit pro_attribs_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Protected Attributes</h3></td></tr>
<tr class="memitem:a346402cddefaa715291dfb7f243073a2"><td class="memItemLeft" align="right" valign="top"><a id="a346402cddefaa715291dfb7f243073a2"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a346402cddefaa715291dfb7f243073a2">instances</a> = 0</td></tr>
<tr class="memdesc:a346402cddefaa715291dfb7f243073a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of PPL instances <br /></td></tr>
<tr class="separator:a346402cddefaa715291dfb7f243073a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a67408174d2260de5ae5f070a70f27e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67408174d2260de5ae5f070a70f27e9d">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PPL_Solver::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a442ad4ad67ee2feff0df49e9201d61ca">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8cpp_source.html#l00082">82</a> of file <a class="el" href="ppl__solver_8cpp_source.html">ppl_solver.cpp</a>.</p>

</div>
</div>
<a id="a1ff16def22c734348c626b65437dd1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff16def22c734348c626b65437dd1e3">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PPL_Solver::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#abd84374c52124116becc8924dc74e12d">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8cpp_source.html#l00113">113</a> of file <a class="el" href="ppl__solver_8cpp_source.html">ppl_solver.cpp</a>.</p>

</div>
</div>
<a id="a5000b8c5bee37029276ce63a3568bfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5000b8c5bee37029276ce63a3568bfb7">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PPL_Solver::solve </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a35da4bdf5db971c445f495b6eaab072d">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="ppl__solver_8cpp_source.html#l00125">125</a> of file <a class="el" href="ppl__solver_8cpp_source.html">ppl_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classray" id="classray"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classray">&#9670;&nbsp;</a></span>ray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ray</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>a ray defined by nonnegative coordinates \((a_1,\ldots,a_n)\) </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class encapsulates a ray, one major part of the definition of a skeleton. Rays can be initialized to a particular set of coefficients, or to a particular axis (which is then translated into the corresponding coefficients).</p>
<p>A special feature is that a rays can track the constraints known to be active at the ray, allowing for more efficient computation in the double description method. Adding known constraints can be done with or without checking whether the constraint actually is active, so this should be done with care. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00190">190</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a48d51151bb229b2b3363869760fe4b3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a48d51151bb229b2b3363869760fe4b3c">ray</a> (NVAR_TYPE, long=-1)</td></tr>
<tr class="memdesc:a48d51151bb229b2b3363869760fe4b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray with the given number of variables, all set to 0.  <a href="#a48d51151bb229b2b3363869760fe4b3c">More...</a><br /></td></tr>
<tr class="separator:a48d51151bb229b2b3363869760fe4b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121e66bf83dfa1582edc24505bbc8095"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a121e66bf83dfa1582edc24505bbc8095">ray</a> (NVAR_TYPE, const RAYENT_TYPE [])</td></tr>
<tr class="memdesc:a121e66bf83dfa1582edc24505bbc8095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray with the given number of variables, with coordinates set to the value of the array.  <a href="#a121e66bf83dfa1582edc24505bbc8095">More...</a><br /></td></tr>
<tr class="separator:a121e66bf83dfa1582edc24505bbc8095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3639433d20b97abc32b56ca93779dcaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3639433d20b97abc32b56ca93779dcaf">ray</a> (NVAR_TYPE, const EXP_TYPE [])</td></tr>
<tr class="memdesc:a3639433d20b97abc32b56ca93779dcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray with the given number of variables, with coordinates set to the value of the array.  <a href="#a3639433d20b97abc32b56ca93779dcaf">More...</a><br /></td></tr>
<tr class="separator:a3639433d20b97abc32b56ca93779dcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6387c9c134132709f29770212648c718"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6387c9c134132709f29770212648c718">ray</a> (const vector&lt; RAYENT_TYPE &gt; &amp;)</td></tr>
<tr class="memdesc:a6387c9c134132709f29770212648c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray whose coordinates are given by the vector.  <a href="#a6387c9c134132709f29770212648c718">More...</a><br /></td></tr>
<tr class="separator:a6387c9c134132709f29770212648c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec5bf395f8b37cb7c4fd7f27999a5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#af4ec5bf395f8b37cb7c4fd7f27999a5d">ray</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:af4ec5bf395f8b37cb7c4fd7f27999a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the coordinates of the other ray.  <a href="#af4ec5bf395f8b37cb7c4fd7f27999a5d">More...</a><br /></td></tr>
<tr class="separator:af4ec5bf395f8b37cb7c4fd7f27999a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:ae29c6b5cecdc32127dc9e5c0141d120d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae29c6b5cecdc32127dc9e5c0141d120d">~ray</a> ()</td></tr>
<tr class="memdesc:ae29c6b5cecdc32127dc9e5c0141d120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes memory allocated by the constructor.  <a href="#ae29c6b5cecdc32127dc9e5c0141d120d">More...</a><br /></td></tr>
<tr class="separator:ae29c6b5cecdc32127dc9e5c0141d120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properies</div></td></tr>
<tr class="memitem:a57662d3f86d00384f73869740ec21adf"><td class="memItemLeft" align="right" valign="top"><a id="a57662d3f86d00384f73869740ec21adf"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a57662d3f86d00384f73869740ec21adf">get_dimension</a> () const</td></tr>
<tr class="memdesc:a57662d3f86d00384f73869740ec21adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of this ray. <br /></td></tr>
<tr class="separator:a57662d3f86d00384f73869740ec21adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952d271bf4f9361c87864e7479fb8677"><td class="memItemLeft" align="right" valign="top"><a id="a952d271bf4f9361c87864e7479fb8677"></a>
RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a952d271bf4f9361c87864e7479fb8677">operator[]</a> (NVAR_TYPE index) const</td></tr>
<tr class="memdesc:a952d271bf4f9361c87864e7479fb8677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entry indicated. Numbering starts at 0. <br /></td></tr>
<tr class="separator:a952d271bf4f9361c87864e7479fb8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff8d27de2240e43dc0d20f84f953b1b"><td class="memItemLeft" align="right" valign="top"><a id="aaff8d27de2240e43dc0d20f84f953b1b"></a>
const RAYENT_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aaff8d27de2240e43dc0d20f84f953b1b">weights</a> () const</td></tr>
<tr class="memdesc:aaff8d27de2240e43dc0d20f84f953b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights. <br /></td></tr>
<tr class="separator:aaff8d27de2240e43dc0d20f84f953b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785bb4f7649e9c3db1141fdde55834c0"><td class="memItemLeft" align="right" valign="top"><a id="a785bb4f7649e9c3db1141fdde55834c0"></a>
const RAYENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a785bb4f7649e9c3db1141fdde55834c0">coordinate</a> (NVAR_TYPE index)</td></tr>
<tr class="memdesc:a785bb4f7649e9c3db1141fdde55834c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for []. I have no idea why I added this. <br /></td></tr>
<tr class="separator:a785bb4f7649e9c3db1141fdde55834c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1831b718c9a91d786a1a578cb1cefea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa1831b718c9a91d786a1a578cb1cefea">is_active_at</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;hyperplane) const</td></tr>
<tr class="memdesc:aa1831b718c9a91d786a1a578cb1cefea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the hyperplane is active at this ray.  <a href="#aa1831b718c9a91d786a1a578cb1cefea">More...</a><br /></td></tr>
<tr class="separator:aa1831b718c9a91d786a1a578cb1cefea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4113ea6249145c337f4d26a54eb940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5d4113ea6249145c337f4d26a54eb940">is_above</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;hyperplane)</td></tr>
<tr class="memdesc:a5d4113ea6249145c337f4d26a54eb940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if this ray is above the hyperplane.  <a href="#a5d4113ea6249145c337f4d26a54eb940">More...</a><br /></td></tr>
<tr class="separator:a5d4113ea6249145c337f4d26a54eb940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f0af168bb0a86db612fdd3ce22045b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a08f0af168bb0a86db612fdd3ce22045b">is_below</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;hyperplane)</td></tr>
<tr class="memdesc:a08f0af168bb0a86db612fdd3ce22045b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if this ray is below the hyperplane.  <a href="#a08f0af168bb0a86db612fdd3ce22045b">More...</a><br /></td></tr>
<tr class="separator:a08f0af168bb0a86db612fdd3ce22045b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:a25f56f0f7acafe000f98550af47b7da9"><td class="memItemLeft" align="right" valign="top">DOTPROD_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a25f56f0f7acafe000f98550af47b7da9">obtain_dot_product</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;) const</td></tr>
<tr class="memdesc:a25f56f0f7acafe000f98550af47b7da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to compute dot product between ray and the given constraint.  <a href="#a25f56f0f7acafe000f98550af47b7da9">More...</a><br /></td></tr>
<tr class="separator:a25f56f0f7acafe000f98550af47b7da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:a99cfe50a0abd150d7effd8911664c2db"><td class="memItemLeft" align="right" valign="top"><a id="a99cfe50a0abd150d7effd8911664c2db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a99cfe50a0abd150d7effd8911664c2db">simplify_ray</a> ()</td></tr>
<tr class="memdesc:a99cfe50a0abd150d7effd8911664c2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the ray by dividing its components by the least common denominator. <br /></td></tr>
<tr class="separator:a99cfe50a0abd150d7effd8911664c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fa2d552fda75b973fe659c39ff9960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a83fa2d552fda75b973fe659c39ff9960">operator=</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:a83fa2d552fda75b973fe659c39ff9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator; assigns the value of <code>other</code> to <code>this</code>.  <a href="#a83fa2d552fda75b973fe659c39ff9960">More...</a><br /></td></tr>
<tr class="separator:a83fa2d552fda75b973fe659c39ff9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f95b591c0b92d2ea8cc04b1c9b0d179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3f95b591c0b92d2ea8cc04b1c9b0d179">swap</a> (<a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:a3f95b591c0b92d2ea8cc04b1c9b0d179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two rays of equal dimension by swapping their data, avoiding memory reallocation.  <a href="#a3f95b591c0b92d2ea8cc04b1c9b0d179">More...</a><br /></td></tr>
<tr class="separator:a3f95b591c0b92d2ea8cc04b1c9b0d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr class="memitem:ae27bf49e1b2756797f82fea0bf810dfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae27bf49e1b2756797f82fea0bf810dfd">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:ae27bf49e1b2756797f82fea0bf810dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the two rays are equal.  <a href="#ae27bf49e1b2756797f82fea0bf810dfd">More...</a><br /></td></tr>
<tr class="separator:ae27bf49e1b2756797f82fea0bf810dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b7d226858aa935e739c696065e4680"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a22b7d226858aa935e739c696065e4680">operator!=</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:a22b7d226858aa935e739c696065e4680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the two rays are unequal.  <a href="#a22b7d226858aa935e739c696065e4680">More...</a><br /></td></tr>
<tr class="separator:a22b7d226858aa935e739c696065e4680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088bbdf2a6fc03509fc660aa3aee110e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a088bbdf2a6fc03509fc660aa3aee110e">operator!=</a> (<a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;r, <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;s)</td></tr>
<tr class="memdesc:a088bbdf2a6fc03509fc660aa3aee110e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the two rays are unequal.  <a href="#a088bbdf2a6fc03509fc660aa3aee110e">More...</a><br /></td></tr>
<tr class="separator:a088bbdf2a6fc03509fc660aa3aee110e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27bf49e1b2756797f82fea0bf810dfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae27bf49e1b2756797f82fea0bf810dfd">operator==</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:ae27bf49e1b2756797f82fea0bf810dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the coordinates of the two rays are equal.  <a href="#ae27bf49e1b2756797f82fea0bf810dfd">More...</a><br /></td></tr>
<tr class="separator:ae27bf49e1b2756797f82fea0bf810dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5909f048e7cf014f880adb43da3862d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5909f048e7cf014f880adb43da3862d3">operator&lt;</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:a5909f048e7cf014f880adb43da3862d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of rays.  <a href="#a5909f048e7cf014f880adb43da3862d3">More...</a><br /></td></tr>
<tr class="separator:a5909f048e7cf014f880adb43da3862d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a1fa347ed00fc99eec663252c28108a3f"><td class="memItemLeft" align="right" valign="top"><a id="a1fa347ed00fc99eec663252c28108a3f"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1fa347ed00fc99eec663252c28108a3f">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;)</td></tr>
<tr class="memdesc:a1fa347ed00fc99eec663252c28108a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output is of the form \((r_1, \ldots, r_n)\). <br /></td></tr>
<tr class="separator:a1fa347ed00fc99eec663252c28108a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a48d51151bb229b2b3363869760fe4b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d51151bb229b2b3363869760fe4b3c">&#9670;&nbsp;</a></span>ray() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ray::ray </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>direction</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray with the given number of variables, all set to 0. </p>
<p>The optional second argument specifies a direction, and sets that coordinate to 1. In this case, there is no need to set the ray's known active constraints, as this is known and populated automatically. </p><dl class="section pre"><dt>Precondition</dt><dd>The dimension should be greater than zero. While the direction need not be specified&hellip; (see postcondition) </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>&hellip;the result when the direction is zero is a zero ray. If the direction is \( i \), then the result is the \(i\)th canonical vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00132">132</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a121e66bf83dfa1582edc24505bbc8095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121e66bf83dfa1582edc24505bbc8095">&#9670;&nbsp;</a></span>ray() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ray::ray </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RAYENT_TYPE&#160;</td>
          <td class="paramname"><em>entries</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray with the given number of variables, with coordinates set to the value of the array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the size of the array needs to be at least as long as the number of variables! </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00143">143</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a3639433d20b97abc32b56ca93779dcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3639433d20b97abc32b56ca93779dcaf">&#9670;&nbsp;</a></span>ray() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ray::ray </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EXP_TYPE&#160;</td>
          <td class="paramname"><em>entries</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray with the given number of variables, with coordinates set to the value of the array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the size of the array needs to be at least as long as the number of variables! </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00152">152</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a6387c9c134132709f29770212648c718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6387c9c134132709f29770212648c718">&#9670;&nbsp;</a></span>ray() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ray::ray </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; RAYENT_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ray whose coordinates are given by the vector. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The dimension of this ray will equal the number of entries in the vector, and the values of their entries will be equal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00161">161</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="af4ec5bf395f8b37cb7c4fd7f27999a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ec5bf395f8b37cb7c4fd7f27999a5d">&#9670;&nbsp;</a></span>ray() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ray::ray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>old_ray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the coordinates of the other ray. </p>
<p>Allocates new memory, and copies the active constraints. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00170">170</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ae29c6b5cecdc32127dc9e5c0141d120d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29c6b5cecdc32127dc9e5c0141d120d">&#9670;&nbsp;</a></span>~ray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ray::~ray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes memory allocated by the constructor. </p>
<p>Currently, that means it deletes <code>coords</code>. </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00180">180</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a5d4113ea6249145c337f4d26a54eb940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4113ea6249145c337f4d26a54eb940">&#9670;&nbsp;</a></span>is_above()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ray::is_above </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if this ray is above the hyperplane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperplane</td><td>a constraint; we would like to know whether <code>this</code> is above it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>this</code> is above <code>constraint</code> </dd></dl>
<p>Practically speaking, if the hyperplane is defined by the vector \( \mathbf c \) and the ray is defined by \( \mathbf r \) , this function returns true if and only if \( c\cdot r &gt; 0 \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00293">293</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="aa1831b718c9a91d786a1a578cb1cefea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1831b718c9a91d786a1a578cb1cefea">&#9670;&nbsp;</a></span>is_active_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ray::is_active_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the hyperplane is active at this ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperplane</td><td>a constraint; we would like to know whether <code>this</code> lies on it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>this</code> lies on <code>constraint</code> </dd></dl>
<p>Practically speaking, if the hyperplane is defined by the vector \( \mathbf c \) and the ray is defined by \( \mathbf r \) , this function returns true if and only if \( c\cdot r = 0 \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00279">279</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="a08f0af168bb0a86db612fdd3ce22045b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f0af168bb0a86db612fdd3ce22045b">&#9670;&nbsp;</a></span>is_below()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ray::is_below </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if this ray is below the hyperplane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperplane</td><td>a constraint; we would like to know whether <code>this</code> is below it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>this</code> is below <code>constraint</code> </dd></dl>
<p>Practically speaking, if the hyperplane is defined by the vector \( \mathbf c \) and the ray is defined by \( \mathbf r \) , this function returns true if and only if \( c\cdot r &lt; 0 \). </p>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00307">307</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="a25f56f0f7acafe000f98550af47b7da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f56f0f7acafe000f98550af47b7da9">&#9670;&nbsp;</a></span>obtain_dot_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DOTPROD_TYPE ray::obtain_dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperplane</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to compute dot product between ray and the given constraint. </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product of <code>this</code> and <code>constraint</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00212">212</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a83fa2d552fda75b973fe659c39ff9960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fa2d552fda75b973fe659c39ff9960">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp; ray::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator; assigns the value of <code>other</code> to <code>this</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00330">330</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a3f95b591c0b92d2ea8cc04b1c9b0d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f95b591c0b92d2ea8cc04b1c9b0d179">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two rays of equal dimension by swapping their data, avoiding memory reallocation. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00350">350</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="a22b7d226858aa935e739c696065e4680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b7d226858aa935e739c696065e4680">&#9670;&nbsp;</a></span>operator!= <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the two rays are unequal. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00312">312</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="a088bbdf2a6fc03509fc660aa3aee110e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088bbdf2a6fc03509fc660aa3aee110e">&#9670;&nbsp;</a></span>operator!= <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the two rays are unequal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a ray </td></tr>
    <tr><td class="paramname">s</td><td>a ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00337">337</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="a5909f048e7cf014f880adb43da3862d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5909f048e7cf014f880adb43da3862d3">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>first_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>second_ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographic comparison of rays. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00361">361</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ae27bf49e1b2756797f82fea0bf810dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27bf49e1b2756797f82fea0bf810dfd">&#9670;&nbsp;</a></span>operator== <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the two rays are equal. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00304">304</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ae27bf49e1b2756797f82fea0bf810dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27bf49e1b2756797f82fea0bf810dfd">&#9670;&nbsp;</a></span>operator== <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the coordinates of the two rays are equal. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when number of variables is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00304">304</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classskeleton" id="classskeleton"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classskeleton">&#9670;&nbsp;</a></span>skeleton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class skeleton</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>skeleton of a polyhedral cone, with methods allowing definition and refinement </p>
<dl class="section author"><dt>Author</dt><dd>John Perry </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2014 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>The University of Southern Mississippi</dd></dl>
<p>This class implements the Double Description Method, an iterative algorithm for computing the skeleton of a cone. This particular version uses Zolotykh's GraphAdj criterion <a class="el" href="citelist.html#CITEREF_Zolotych_DoubleDescription">[11]</a>. The iterative nature means that the cone can be updated with new constraints, passed to that algorithm, and the skeleton will be automatically recomputed. </p>

<p class="definition">Definition at line <a class="el" href="skeleton_8hpp_source.html#l00178">178</a> of file <a class="el" href="skeleton_8hpp_source.html">skeleton.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for skeleton:</div>
<div class="dyncontent">
 <div class="center">
  <img src="group___c_l_s_solvers.png" usemap="#skeleton_map" alt=""/>
  <map id="skeleton_map" name="skeleton_map">
<area href="group___c_l_s_solvers.html#class_l_p___solver" title="exact or approximate polyhedral cone solution, with methods allowing definition and refinement ..." alt="LP_Solver" shape="rect" coords="0,0,71,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a7a9181253fc3b9f7b61871047b2b31cc"><td class="memItemLeft" align="right" valign="top"><a id="a7a9181253fc3b9f7b61871047b2b31cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a7a9181253fc3b9f7b61871047b2b31cc">common_initialization</a> (NVAR_TYPE)</td></tr>
<tr class="memdesc:a7a9181253fc3b9f7b61871047b2b31cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization common to all constructors. <br /></td></tr>
<tr class="separator:a7a9181253fc3b9f7b61871047b2b31cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f5818e984abe589ea8298d189cd9c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a60f5818e984abe589ea8298d189cd9c6">skeleton</a> (NVAR_TYPE)</td></tr>
<tr class="memdesc:a60f5818e984abe589ea8298d189cd9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basic skeleton in the given number of dimensions, initialized to the axes, or (equivalently) to the set of constraints \( x_i \geq 0 \).  <a href="#a60f5818e984abe589ea8298d189cd9c6">More...</a><br /></td></tr>
<tr class="separator:a60f5818e984abe589ea8298d189cd9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0ebc69ae4ff20afd3096e36b31ab1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5d0ebc69ae4ff20afd3096e36b31ab1f">skeleton</a> (NVAR_TYPE, vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a5d0ebc69ae4ff20afd3096e36b31ab1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a skeleton described by the given system of constraints.  <a href="#a5d0ebc69ae4ff20afd3096e36b31ab1f">More...</a><br /></td></tr>
<tr class="separator:a5d0ebc69ae4ff20afd3096e36b31ab1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb0828dc5cd38edf09093e738510d7a"><td class="memItemLeft" align="right" valign="top"><a id="abbb0828dc5cd38edf09093e738510d7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#abbb0828dc5cd38edf09093e738510d7a">skeleton</a> (<a class="el" href="group___c_l_s_solvers.html#classskeleton">skeleton</a> &amp;)</td></tr>
<tr class="memdesc:abbb0828dc5cd38edf09093e738510d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep copy of <code>other</code>. <br /></td></tr>
<tr class="separator:abbb0828dc5cd38edf09093e738510d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d30b92f27936eab11d0fa4f0cc10b4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a42d30b92f27936eab11d0fa4f0cc10b4">copy</a> (const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *)</td></tr>
<tr class="memdesc:a42d30b92f27936eab11d0fa4f0cc10b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a deep copy, similar to a copy constructor  <a href="#a42d30b92f27936eab11d0fa4f0cc10b4">More...</a><br /></td></tr>
<tr class="separator:a42d30b92f27936eab11d0fa4f0cc10b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destruction</div></td></tr>
<tr class="memitem:ae8874234344e5e51f9b81f6199ee2aa6"><td class="memItemLeft" align="right" valign="top"><a id="ae8874234344e5e51f9b81f6199ee2aa6"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ae8874234344e5e51f9b81f6199ee2aa6">~skeleton</a> ()</td></tr>
<tr class="memdesc:ae8874234344e5e51f9b81f6199ee2aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently does nothing the compiler wouldn't do. <br /></td></tr>
<tr class="separator:ae8874234344e5e51f9b81f6199ee2aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic properties</div></td></tr>
<tr class="memitem:ac6dd4f7d7e79ab08d6cf49ad4925f5ef"><td class="memItemLeft" align="right" valign="top"><a id="ac6dd4f7d7e79ab08d6cf49ad4925f5ef"></a>
NVAR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ac6dd4f7d7e79ab08d6cf49ad4925f5ef">get_dimension</a> () const</td></tr>
<tr class="memdesc:ac6dd4f7d7e79ab08d6cf49ad4925f5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the underlying vector space. <br /></td></tr>
<tr class="separator:ac6dd4f7d7e79ab08d6cf49ad4925f5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2662e9f9e6a0dde0459dee0b27fd1c"><td class="memItemLeft" align="right" valign="top"><a id="a3e2662e9f9e6a0dde0459dee0b27fd1c"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3e2662e9f9e6a0dde0459dee0b27fd1c">get_number_of_edges</a> ()</td></tr>
<tr class="memdesc:a3e2662e9f9e6a0dde0459dee0b27fd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges defining the skeleton. <br /></td></tr>
<tr class="separator:a3e2662e9f9e6a0dde0459dee0b27fd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4557716509bfeeae99f99b93953cf8"><td class="memItemLeft" align="right" valign="top"><a id="adc4557716509bfeeae99f99b93953cf8"></a>
set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#adc4557716509bfeeae99f99b93953cf8">get_edges</a> ()</td></tr>
<tr class="memdesc:adc4557716509bfeeae99f99b93953cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edges that define the skeleton. <br /></td></tr>
<tr class="separator:adc4557716509bfeeae99f99b93953cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b75f0ce54e512673169b193955fc58f"><td class="memItemLeft" align="right" valign="top"><a id="a0b75f0ce54e512673169b193955fc58f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a0b75f0ce54e512673169b193955fc58f">get_number_of_constraints</a> ()</td></tr>
<tr class="memdesc:a0b75f0ce54e512673169b193955fc58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints defining the skeleton. <br /></td></tr>
<tr class="separator:a0b75f0ce54e512673169b193955fc58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29665cf3b04694b349f224e54f93f2db"><td class="memItemLeft" align="right" valign="top"><a id="a29665cf3b04694b349f224e54f93f2db"></a>
const vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a29665cf3b04694b349f224e54f93f2db">get_constraints</a> ()</td></tr>
<tr class="memdesc:a29665cf3b04694b349f224e54f93f2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraints that define the skeleton. <br /></td></tr>
<tr class="separator:a29665cf3b04694b349f224e54f93f2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0ceb21b570a4a4084902a497de79a0"><td class="memItemLeft" align="right" valign="top"><a id="a8c0ceb21b570a4a4084902a497de79a0"></a>
<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8c0ceb21b570a4a4084902a497de79a0">get_constraint</a> (int index)</td></tr>
<tr class="memdesc:a8c0ceb21b570a4a4084902a497de79a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indicated constraint. Numbering starts at 0. <br /></td></tr>
<tr class="separator:a8c0ceb21b570a4a4084902a497de79a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computation</div></td></tr>
<tr class="memitem:a6b48120d11e7b244c14c748d990d2ade"><td class="memItemLeft" align="right" valign="top"><a id="a6b48120d11e7b244c14c748d990d2ade"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a6b48120d11e7b244c14c748d990d2ade">which_constraints_active_at</a> (const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;u, bool *result) const</td></tr>
<tr class="memdesc:a6b48120d11e7b244c14c748d990d2ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the set of constraints in the skeleton active at <code>u</code> <br /></td></tr>
<tr class="separator:a6b48120d11e7b244c14c748d990d2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca399adccf69ea8f9df6cf557526032b"><td class="memItemLeft" align="right" valign="top"><a id="aca399adccf69ea8f9df6cf557526032b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aca399adccf69ea8f9df6cf557526032b">is_consistent</a> (const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;c) const</td></tr>
<tr class="memdesc:aca399adccf69ea8f9df6cf557526032b"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a potentially new constraint. <br /></td></tr>
<tr class="separator:aca399adccf69ea8f9df6cf557526032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:ac366952c2b0908159255916a1e37f9b3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#ac366952c2b0908159255916a1e37f9b3">solve</a> (vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ac366952c2b0908159255916a1e37f9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraints (plural!) and re-computes the skeleton.  <a href="#ac366952c2b0908159255916a1e37f9b3">More...</a><br /></td></tr>
<tr class="separator:ac366952c2b0908159255916a1e37f9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8add1433d3bc6b1a8588f0f88134599f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a8add1433d3bc6b1a8588f0f88134599f">solve</a> (<a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;)</td></tr>
<tr class="memdesc:a8add1433d3bc6b1a8588f0f88134599f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the indicated constraint (singular!) and re-computes the skeleton.  <a href="#a8add1433d3bc6b1a8588f0f88134599f">More...</a><br /></td></tr>
<tr class="separator:a8add1433d3bc6b1a8588f0f88134599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af8c607a3dc93633e0d395e73cb1c97"><td class="memItemLeft" align="right" valign="top"><a id="a1af8c607a3dc93633e0d395e73cb1c97"></a>
set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a1af8c607a3dc93633e0d395e73cb1c97">adjacencies_by_graphs</a> (set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt;)</td></tr>
<tr class="memdesc:a1af8c607a3dc93633e0d395e73cb1c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-computes the edges in the skeleton using Zolotych's <code>GraphAdj</code> algorithm and returns the result. <br /></td></tr>
<tr class="separator:a1af8c607a3dc93633e0d395e73cb1c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5991e7e25783c2b8cfd772f41f7b99b"><td class="memItemLeft" align="right" valign="top"><a id="aa5991e7e25783c2b8cfd772f41f7b99b"></a>
<a class="el" href="group___c_l_s_solvers.html#classskeleton">skeleton</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa5991e7e25783c2b8cfd772f41f7b99b">operator=</a> (const <a class="el" href="group___c_l_s_solvers.html#classskeleton">skeleton</a> &amp;)</td></tr>
<tr class="memdesc:aa5991e7e25783c2b8cfd772f41f7b99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator; empties current set &amp; copies from other. <br /></td></tr>
<tr class="separator:aa5991e7e25783c2b8cfd772f41f7b99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memitem:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a3cdeb4d133d147bae2c071bd41ed10aa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a3cdeb4d133d147bae2c071bd41ed10aa">~LP_Solver</a> ()</td></tr>
<tr class="memdesc:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default destructor does nothing (this is an abstract class) <br /></td></tr>
<tr class="separator:a3cdeb4d133d147bae2c071bd41ed10aa inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4262d944695d0cfcddf9e24908f72e8f inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a4262d944695d0cfcddf9e24908f72e8f"></a>
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a4262d944695d0cfcddf9e24908f72e8f">get_number_of_rays</a> ()</td></tr>
<tr class="memdesc:a4262d944695d0cfcddf9e24908f72e8f inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rays defining the skeleton. <br /></td></tr>
<tr class="separator:a4262d944695d0cfcddf9e24908f72e8f inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06363bbbc8dfdb4c161a001d24f94afd inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a06363bbbc8dfdb4c161a001d24f94afd"></a>
virtual const set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a06363bbbc8dfdb4c161a001d24f94afd">get_rays</a> ()</td></tr>
<tr class="memdesc:a06363bbbc8dfdb4c161a001d24f94afd inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rays that define the skeleton. <br /></td></tr>
<tr class="separator:a06363bbbc8dfdb4c161a001d24f94afd inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e909dd41a7f116c62868e3e6c278a2e inherit pub_methods_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top"><a id="a2e909dd41a7f116c62868e3e6c278a2e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a2e909dd41a7f116c62868e3e6c278a2e">makes_consistent_constraint</a> (const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;t, const <a class="el" href="group__polygroup.html#class_monomial">Monomial</a> &amp;u, bool show_data=false)</td></tr>
<tr class="memdesc:a2e909dd41a7f116c62868e3e6c278a2e inherit pub_methods_group___c_l_s_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for consistency of a constraint generated by two monomials. <br /></td></tr>
<tr class="separator:a2e909dd41a7f116c62868e3e6c278a2e inherit pub_methods_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O</div></td></tr>
<tr class="memitem:a5732209c39488881acfc0fb5831e513b"><td class="memItemLeft" align="right" valign="top"><a id="a5732209c39488881acfc0fb5831e513b"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#a5732209c39488881acfc0fb5831e513b">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="group___c_l_s_solvers.html#classskeleton">skeleton</a> &amp;)</td></tr>
<tr class="memdesc:a5732209c39488881acfc0fb5831e513b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints out the constraints, then the rays, then the edges. <br /></td></tr>
<tr class="separator:a5732209c39488881acfc0fb5831e513b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_group___c_l_s_solvers"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group___c_l_s_solvers')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a></td></tr>
<tr class="memitem:aa89c9167eb3ef921b57d74057217f407 inherit pro_attribs_group___c_l_s_solvers"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_s_solvers.html#aa89c9167eb3ef921b57d74057217f407">rays</a></td></tr>
<tr class="separator:aa89c9167eb3ef921b57d74057217f407 inherit pro_attribs_group___c_l_s_solvers"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a60f5818e984abe589ea8298d189cd9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f5818e984abe589ea8298d189cd9c6">&#9670;&nbsp;</a></span>skeleton() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">skeleton::skeleton </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a basic skeleton in the given number of dimensions, initialized to the axes, or (equivalently) to the set of constraints \( x_i \geq 0 \). </p>
<p>The rays are informed of their active constraints. </p><dl class="section pre"><dt>Precondition</dt><dd>the argument should be at least two </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the skeleton of the positive orthant </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00119">119</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a5d0ebc69ae4ff20afd3096e36b31ab1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0ebc69ae4ff20afd3096e36b31ab1f">&#9670;&nbsp;</a></span>skeleton() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">skeleton::skeleton </td>
          <td>(</td>
          <td class="paramtype">NVAR_TYPE&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a skeleton described by the given system of constraints. </p>
<p>Practically speaking, it first generates a basic skeleton, then iterates on the given constraints. </p><dl class="section pre"><dt>Precondition</dt><dd><code>u.size() == v.size()</code> for all <code>u</code>, <code>v</code> in the vector </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>unless the system supplied was inconsistent, a valid skeleton of the corresponding polyhedral cone </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Your program will almost certainly fail if you do not respect the precondition. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00124">124</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a42d30b92f27936eab11d0fa4f0cc10b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d30b92f27936eab11d0fa4f0cc10b4">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool skeleton::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#class_l_p___solver">LP_Solver</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs a deep copy, similar to a copy constructor </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff copying was successful </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix-and-match solvers. At the present time, a <a class="el" href="group___c_l_s_solvers.html#class_p_p_l___solver" title="approximate skeleton of a polyhedral cone, using PPL linear solver ">PPL_Solver</a> is not equipped to copy a <a class="el" href="group___c_l_s_solvers.html#class_g_l_p_k___solver" title="approximate skeleton of a polyhedral cone, using GLPK linear solver ">GLPK_Solver</a>, or vice versa. (This doesn't even make sense between exact and approximate solvers.) </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a442ad4ad67ee2feff0df49e9201d61ca">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00140">140</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="ac366952c2b0908159255916a1e37f9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac366952c2b0908159255916a1e37f9b3">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool skeleton::solve </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraints (plural!) and re-computes the skeleton. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraints are consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#a35da4bdf5db971c445f495b6eaab072d">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00270">270</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="a8add1433d3bc6b1a8588f0f88134599f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8add1433d3bc6b1a8588f0f88134599f">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool skeleton::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the indicated constraint (singular!) and re-computes the skeleton. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the new constraint is consistent with the current constraints</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Checking the return value is crucial! If the function returns <code>false</code>, you have an inconsistent system! While the <em>present</em> cone will remain consistent, <b>the function will not roll back previous changes you have made</b>, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. </dd></dl>

<p>Implements <a class="el" href="group___c_l_s_solvers.html#abd84374c52124116becc8924dc74e12d">LP_Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00162">162</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacb5ce7e22db91b33c26ea0be6a6026de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5ce7e22db91b33c26ea0be6a6026de">&#9670;&nbsp;</a></span>intersections_of_active_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt; intersections_of_active_constraints </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the intersection between the given sets of constraints. </dd></dl>

</div>
</div>
<a id="ga06bebd50facdc36f850371e545f82174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06bebd50facdc36f850371e545f82174">&#9670;&nbsp;</a></span>is_first_subset_of_second()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_first_subset_of_second </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the first set is a subset of the second. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00330">330</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="ga33829eddeaa7be000404e4d281d90973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33829eddeaa7be000404e4d281d90973">&#9670;&nbsp;</a></span>number_of_common_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int number_of_common_constraints </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of constraints common to both sets. </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00297">297</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
<a id="gae039f9fb46b8c57063342f6203add523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae039f9fb46b8c57063342f6203add523">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> operator* </td>
          <td>(</td>
          <td class="paramtype">RAYENT_TYPE&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply every coordinate in the given ray by the given scalar. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the ray, scaled by the requesed amount </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00222">222</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ga30af4b27086e461f862e7d16e9d209df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30af4b27086e461f862e7d16e9d209df">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RAYENT_TYPE operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product on the rays. </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the rays </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00235">235</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gac22c25c0110c6684317aaf0e50c2e9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac22c25c0110c6684317aaf0e50c2e9a0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DOTPROD_TYPE operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between the ray and the constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>a ray </td></tr>
    <tr><td class="paramname">c</td><td>a constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the ray and the constraint </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00465">465</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="ga240d91c518c3bfe3817504de43039022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga240d91c518c3bfe3817504de43039022">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DOTPROD_TYPE operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classconstraint">constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the dot product between the ray and the constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a constraint </td></tr>
    <tr><td class="paramname">r</td><td>a ray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the ray and the constraint </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8hpp_source.html#l00477">477</a> of file <a class="el" href="lp__solver_8hpp_source.html">lp_solver.hpp</a>.</p>

</div>
</div>
<a id="gaaa48bb668551858c8d53e230546042ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa48bb668551858c8d53e230546042ba">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the two rays. </p>
<dl class="section return"><dt>Returns</dt><dd>the sum of the two rays </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00259">259</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gafcb092cfc55771c4303f540cb7697a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcb092cfc55771c4303f540cb7697a40">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the two rays. </p>
<dl class="section return"><dt>Returns</dt><dd>the difference of the two rays </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00270">270</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="gafb95c2b09dc0a5ea693a99cb8340ff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb95c2b09dc0a5ea693a99cb8340ff28">&#9670;&nbsp;</a></span>ray_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_l_s_solvers.html#classray">ray</a> ray_sum </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="group___c_l_s_solvers.html#classray">ray</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all the rays in a set. </p>
<dl class="section return"><dt>Returns</dt><dd>a ray that is the sum of all rays in the given set </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is unsafe when dimension is not the same. It does not check, since the assumption is that you know what you're doing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__solver_8cpp_source.html#l00281">281</a> of file <a class="el" href="lp__solver_8cpp_source.html">lp_solver.cpp</a>.</p>

</div>
</div>
<a id="ga2b6dbec1643b53f8e613b0a3de07f3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b6dbec1643b53f8e613b0a3de07f3ce">&#9670;&nbsp;</a></span>union_of_edge_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;<a class="el" href="group___c_l_s_solvers.html#classedge">edge</a>&gt; union_of_edge_sets </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="group___c_l_s_solvers.html#classedge">edge</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>union of the specified edge sets </dd></dl>

<p class="definition">Definition at line <a class="el" href="skeleton_8cpp_source.html#l00342">342</a> of file <a class="el" href="skeleton_8cpp_source.html">skeleton.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

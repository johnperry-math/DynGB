\hypertarget{class_l_p___solver}{}\section{L\+P\+\_\+\+Solver Class Reference}
\label{class_l_p___solver}\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}


exact or approximate polyhedral cone solution, with methods allowing definition and refinement  




{\ttfamily \#include $<$lp\+\_\+solver.\+hpp$>$}

Inheritance diagram for L\+P\+\_\+\+Solver\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_l_p___solver}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{Indent}\textbf{ Construction}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{class_l_p___solver_a442ad4ad67ee2feff0df49e9201d61ca}{copy} (const \hyperlink{class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$)=0
\begin{DoxyCompactList}\small\item\em performs a deep copy, similar to a copy constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Modification}\par
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{class_l_p___solver_abd84374c52124116becc8924dc74e12d}{solve} (\hyperlink{classconstraint}{constraint} \&)=0
\begin{DoxyCompactList}\small\item\em Adds the indicated constraint (singular!) and re-\/computes the solution. \end{DoxyCompactList}\item 
virtual bool \hyperlink{class_l_p___solver_a35da4bdf5db971c445f495b6eaab072d}{solve} (vector$<$ \hyperlink{classconstraint}{constraint} $>$ \&)=0
\begin{DoxyCompactList}\small\item\em Adds the indicated constraints (plural!) and re-\/computes the solution. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Basic properies}\par
{\em Returns rays that define a skeleton.

When using an approximate solver such as \hyperlink{class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, this will give only an approximate skeleton. }\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_l_p___solver_ae85c7e9a24774fd3c08a7dd9a7b8a27c}\label{class_l_p___solver_ae85c7e9a24774fd3c08a7dd9a7b8a27c}} 
virtual N\+V\+A\+R\+\_\+\+T\+Y\+PE \hyperlink{class_l_p___solver_ae85c7e9a24774fd3c08a7dd9a7b8a27c}{get\+\_\+dimension} () const =0
\begin{DoxyCompactList}\small\item\em Returns the dimension of the underlying vector space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_l_p___solver_a4262d944695d0cfcddf9e24908f72e8f}\label{class_l_p___solver_a4262d944695d0cfcddf9e24908f72e8f}} 
virtual unsigned long \hyperlink{class_l_p___solver_a4262d944695d0cfcddf9e24908f72e8f}{get\+\_\+number\+\_\+of\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the number of rays defining the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_l_p___solver_a06363bbbc8dfdb4c161a001d24f94afd}\label{class_l_p___solver_a06363bbbc8dfdb4c161a001d24f94afd}} 
virtual const set$<$ \hyperlink{classray}{ray} $>$ \& \hyperlink{class_l_p___solver_a06363bbbc8dfdb4c161a001d24f94afd}{get\+\_\+rays} ()
\begin{DoxyCompactList}\small\item\em Returns the rays that define the skeleton. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_l_p___solver_a0b587fd39cbefe969e4b3dbf34387b08}\label{class_l_p___solver_a0b587fd39cbefe969e4b3dbf34387b08}} 
virtual unsigned long {\bfseries get\+\_\+number\+\_\+of\+\_\+constraints} ()=0
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Computation}\par
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_l_p___solver_a2e909dd41a7f116c62868e3e6c278a2e}\label{class_l_p___solver_a2e909dd41a7f116c62868e3e6c278a2e}} 
virtual bool \hyperlink{class_l_p___solver_a2e909dd41a7f116c62868e3e6c278a2e}{makes\+\_\+consistent\+\_\+constraint} (const \hyperlink{class_monomial}{Monomial} \&t, const \hyperlink{class_monomial}{Monomial} \&u, bool show\+\_\+data=false)
\begin{DoxyCompactList}\small\item\em tests for consistency of a constraint generated by two monomials. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
set$<$ \hyperlink{classray}{ray} $>$ \hyperlink{class_l_p___solver_aa89c9167eb3ef921b57d74057217f407}{rays}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
exact or approximate polyhedral cone solution, with methods allowing definition and refinement 

\begin{DoxyAuthor}{Author}
John Perry 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
January 2017 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
The University of Southern Mississippi
\end{DoxyCopyright}
This class encapsulates the skeleton of a polyhedral cone, defined by a sequence of inequalities of the form $ c_1 x_1 + \cdots c_n x_n \geq 0 $.

\begin{DoxyWarning}{Warning}
Some classes may provide only an {\itshape approximate} cone; see, for example, \hyperlink{class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}. In addition, Clients must ensure two things.
\begin{DoxyEnumerate}
\item The rays must have the same number $ m $ of dimensions, constraints must have the same number $ n $ of variables, and $ m=n $. Violating any of these three conditions will lead to undesirable behavior.
\item When refining the cone, it is essential to check that the return value of \hyperlink{class_l_p___solver_abd84374c52124116becc8924dc74e12d}{solve()} is {\ttfamily true}; for if it is not, then the cone is no longer be consistent. Please read the relevant documentation. 
\end{DoxyEnumerate}
\end{DoxyWarning}


Definition at line 452 of file lp\+\_\+solver.\+hpp.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_l_p___solver_a442ad4ad67ee2feff0df49e9201d61ca}\label{class_l_p___solver_a442ad4ad67ee2feff0df49e9201d61ca}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!copy@{copy}}
\index{copy@{copy}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily virtual bool L\+P\+\_\+\+Solver\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{class_l_p___solver}{L\+P\+\_\+\+Solver} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



performs a deep copy, similar to a copy constructor 

\begin{DoxyWarning}{Warning}
Do not mix-\/and-\/match solvers. At the present time, a \hyperlink{class_p_p_l___solver}{P\+P\+L\+\_\+\+Solver} is not equipped to copy a \hyperlink{class_g_l_p_k___solver}{G\+L\+P\+K\+\_\+\+Solver}, or vice versa. (This doesn\textquotesingle{}t even make sense between exact and approximate solvers.) 
\end{DoxyWarning}


Implemented in \hyperlink{classskeleton_a42d30b92f27936eab11d0fa4f0cc10b4}{skeleton}, \hyperlink{class_p_p_l___solver_a67408174d2260de5ae5f070a70f27e9d}{P\+P\+L\+\_\+\+Solver}, and \hyperlink{class_g_l_p_k___solver_aff3a58ef3def363dfad9e0ba8eee3e67}{G\+L\+P\+K\+\_\+\+Solver}.

\mbox{\Hypertarget{class_l_p___solver_abd84374c52124116becc8924dc74e12d}\label{class_l_p___solver_abd84374c52124116becc8924dc74e12d}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual bool L\+P\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{\hyperlink{classconstraint}{constraint} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds the indicated constraint (singular!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraint is consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implemented in \hyperlink{classskeleton_a8add1433d3bc6b1a8588f0f88134599f}{skeleton}, \hyperlink{class_g_l_p_k___solver_acb3a10f3961c65b4cf23ff61f0e2310b}{G\+L\+P\+K\+\_\+\+Solver}, and \hyperlink{class_p_p_l___solver_a1ff16def22c734348c626b65437dd1e3}{P\+P\+L\+\_\+\+Solver}.

\mbox{\Hypertarget{class_l_p___solver_a35da4bdf5db971c445f495b6eaab072d}\label{class_l_p___solver_a35da4bdf5db971c445f495b6eaab072d}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!solve@{solve}}
\index{solve@{solve}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual bool L\+P\+\_\+\+Solver\+::solve (\begin{DoxyParamCaption}\item[{vector$<$ \hyperlink{classconstraint}{constraint} $>$ \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Adds the indicated constraints (plural!) and re-\/computes the solution. 

\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if the new constraints are consistent with the current constraints
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
Checking the return value is crucial! If the function returns {\ttfamily false}, you have an inconsistent system! While the {\itshape present} cone will remain consistent, {\bfseries the function will not roll back previous changes you have made}, so if you want to iterate again, your best bet is to copy the skeleton, and try that copy. Accept the new constraints only if that copy succeeds, in which case, you might as well discard the original, and keep the copy. 
\end{DoxyWarning}


Implemented in \hyperlink{classskeleton_ac366952c2b0908159255916a1e37f9b3}{skeleton}, \hyperlink{class_g_l_p_k___solver_a6d800f0ec270c782e3cf855aa7f59f4c}{G\+L\+P\+K\+\_\+\+Solver}, and \hyperlink{class_p_p_l___solver_a5000b8c5bee37029276ce63a3568bfb7}{P\+P\+L\+\_\+\+Solver}.



\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_l_p___solver_aa89c9167eb3ef921b57d74057217f407}\label{class_l_p___solver_aa89c9167eb3ef921b57d74057217f407}} 
\index{L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}!rays@{rays}}
\index{rays@{rays}!L\+P\+\_\+\+Solver@{L\+P\+\_\+\+Solver}}
\subsubsection{\texorpdfstring{rays}{rays}}
{\footnotesize\ttfamily set$<$\hyperlink{classray}{ray}$>$ L\+P\+\_\+\+Solver\+::rays\hspace{0.3cm}{\ttfamily [protected]}}

the skeleton (may be approximate, depending on solver) 

Definition at line 544 of file lp\+\_\+solver.\+hpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lp\+\_\+solver.\+hpp\item 
lp\+\_\+solver.\+cpp\end{DoxyCompactItemize}

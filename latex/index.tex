\begin{DoxyAuthor}{Author}
John Perry, \href{mailto:john.perry@usm.edu}{\tt john.\+perry@usm.\+edu} 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
2014-\/present 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
\href{../../COPYING.txt}{\tt G\+NU Public License}; see \hyperlink{index_Copyright}{Copyright details} below
\end{DoxyCopyright}
\hypertarget{index_Overview}{}\section{Overview}\label{index_Overview}
This project is designed to be a testbed/reference implementation for dynamic Gr\"{o}bner basis computation, using the algorithms described in \cite{CaboaraDynAlg} and \cite{CaboaraPerry}, along with some newer ideas.

No claim to high efficiency or exemplary programming is implied. I wrote this to be relatively usable (compared to an earlier Sage implementation) and {\itshape easy to modify}, especially as regards modularity, polymorphism, and getting detailed data.\hypertarget{index_Install}{}\section{Installation and dependencies}\label{index_Install}
For {\itshape this} program, a simple {\ttfamily make B\+U\+I\+LD=build} should do. However, there are several prerequisite programs you need to install first\+:
\begin{DoxyItemize}
\item a C++ compiler that understands C++11;
\item \href{https://gmplib.org/}{\tt G\+MP}, the Gnu Multi-\/\+Precision library \cite{gmp};
\item \href{https://www.gnu.org/software/glpk/}{\tt G\+L\+PK}, the Gnu Linear Programming Kit \cite{glpk};
\item \href{http://bugseng.com/products/ppl}{\tt P\+PL}, the Parma Polyhedra Library \cite{BagnaraHZ08SCP}.
\end{DoxyItemize}

The codebase also contains some unrelated forays into parallel programming, which are probably of no interest to the average user, but require\+:
\begin{DoxyItemize}
\item the \href{https://www.open-mpi.org/}{\tt Open\+M\+PI} toolchain. If you do not have Open\+M\+PI and are not interested in these (and I don't see why you should be) just comment out any line that involves {\ttfamily mpicxx}.
\end{DoxyItemize}

On a Linux system you can install these very easily (in Fedora I used {\ttfamily Apper}). All dependencies should build without difficulty on a Macintosh. I have not tried to build on Windows, but I don't use hardware magic, so it {\itshape ought} to build.\hypertarget{index_Usage}{}\section{Usage}\label{index_Usage}
There are two ways to use the system.
\begin{DoxyEnumerate}
\item Write a program that builds a polynomial system and accesses the library directly. Most of the \href{examples.html}{\tt examples} provided illustrate that approach. This is annoying and a rather difficult, though not as difficult as it was before the \hyperlink{group__polygroup_class_indeterminate}{Indeterminate} class.
\item Use the {\ttfamily user\+\_\+interface} file. A number of systems are defined in the directory {\ttfamily examples\+\_\+for\+\_\+user\+\_\+interface}. The format is defined in the documentation to \hyperlink{group__utils_ga72d205e8226d578b892515edc527cc83}{user\+\_\+interface()}. This is still annoying, but not quite so difficult.
\end{DoxyEnumerate}\hypertarget{index_Status}{}\section{Current status}\label{index_Status}
As of January 2017\+: \begin{DoxyItemize}
\item The code works consistently on many different examples. However, it is slow\+: I am not trying to reach Singular-\/level optimization (not at the current time, anyway). Typically, this code is one to two orders of magnitude slower than Singular. \item Nevertheless, it outperforms Singular on at least one system\+: Caboara's Example 2. \item Unless I'm doing something very stupid, the weighted sugar strategy is an unmitigated disaster and should be avoided. \item The code is slow, though in the last week of July the implementation of an $O(1)$ memory manager cut the time required for the dynamic implementation by nearly 2/3. A very simple optimization of assigning an object's array to a local variable before entering a loop cut the time required for both dynamic and static by roughly 40\%.\end{DoxyItemize}
\begin{DoxyNote}{Note}
Exponent-\/packing is currently turned off, since it doesn't seem to help enough to make it worth the trouble.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
I implemented the exponent-\/packing in rather shoddy fashion\+: the first 8 exponents are cast to {\ttfamily uint8\+\_\+t} , then shifted appropriately. Comparisons for {\itshape other} are made explicitly. Trouble will arise when one of the first 8 exponents exceeds $2^8-1$, though practically that hasn't been a problem until now. This may be easy to fix\+: if the exponent comparison passes, test all the variables explicitly, not just those after the first 8. But there are issues with arithmetic operations that could arise, as well; the multiplication and division operators are implemented semi-\/intelligently; that is, intelligently under the assumption that the exponents are valid. So problems could arise there even in the case where we fix the equality comparison.
\end{DoxyWarning}
\hypertarget{index_Todo}{}\section{To-\/do list}\label{index_Todo}
In no particular order, aside from the indicated priority. See the \href{todo.html}{\tt to-\/do page} for a full list (I may have missed some things).\hypertarget{index_hipri}{}\subsection{Higher priority}\label{index_hipri}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000001}{Todo}]These are the highest priority items\+: things I think are needed before I'd call it ``ready.''
\begin{DoxyItemize}
\item Organize files into directories.
\item General improvements to efficiency based on profiling. (ongoing)
\item Implement simplex solver as oracle for D\+DM, compare with D\+DM (idea due to D. Lichtblau).
\item Optimize length() in \hyperlink{group__polygroup_class_polynomial___linked___list}{Polynomial\+\_\+\+Linked\+\_\+\+List}.
\item Add Fukuda and Prodon's cdd as an \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver}. \cite{Fukuda_DoubleDescriptionRevisited}
\item Bring polynomial iterators in line with C++ convention.
\item Implement other C++11 modernizations ({\ttfamily auto}, {\ttfamily noexcept}, {\ttfamily override}, {$\dots$}).
\item Generalize/improve the memory manager.
\item Add P\+PL as an \hyperlink{group___c_l_s_solvers_class_l_p___solver}{L\+P\+\_\+\+Solver}. \cite{BagnaraHZ08SCP}
\item Implement Caboara's examples.
\item Implement graded Hilbert numerators.
\item Implement or link to a simplex solver, compare with D\+DM.
\item Determine what\textquotesingle{}s wrong with the $4\times4$ system. (Turns out nothing was wrong\+: the system is simply not amenable to polyhedra.)
\item Implement a global analysis at the beginning of the algorithm.
\item Implement Hilbert polynomials using multiple-\/precision arithmetic. (Denominators get too large for {\ttfamily long long}!!!)
\end{DoxyItemize}\end{DoxyRefDesc}
\hypertarget{index_mdpri}{}\subsection{Medium priority}\label{index_mdpri}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000002}{Todo}]These items would be nice, but aren't a big deal for me at present.
\begin{DoxyItemize}
\item Improve rings and fields\+:
\begin{DoxyItemize}
\item Create a general {\ttfamily Ring} class.
\begin{DoxyItemize}
\item Build polynomial rings off rings, not off fields. This could be difficult, since we typically want polynomials to have invertible coefficients. It doesn't seem strictly necessary, though\+: S-\/polynomials and top-\/reductions, for instance, can be computed by multiplying by the leading coefficient of the other polynomial, rather than by dividing by one's own coefficient.
\item Implement \hyperlink{group__polygroup_class_dense___univariate___integer___polynomial}{Dense\+\_\+\+Univariate\+\_\+\+Integer\+\_\+\+Polynomial} as a proper {\ttfamily Polynomial} representation.
\item Create a general {\ttfamily Euclidean\+\_\+\+Ring} class. Add to it the \hyperlink{group__utils_gaefe33f79de88accbc6f455e91dab9288}{divide\+\_\+by\+\_\+common\+\_\+term()} function.
\end{DoxyItemize}
\item Create a general {\ttfamily Field} class.
\begin{DoxyItemize}
\item Subclass \hyperlink{group___fields_group_class_prime___field}{Prime\+\_\+\+Field} to be {\ttfamily Field}.
\item Implement \hyperlink{group__polygroup_class_dense___univariate___rational___polynomial}{Dense\+\_\+\+Univariate\+\_\+\+Rational\+\_\+\+Polynomial} as a proper {\ttfamily Polynomial} representation.
\item Implement $\mathbb Q$ as a field.
\end{DoxyItemize}
\end{DoxyItemize}
\item Reimplement \hyperlink{group__polygroup_class_double___buffered___polynomial}{Double\+\_\+\+Buffered\+\_\+\+Polynomial} so its arrays contain pointers to \hyperlink{group__polygroup_class_monomial}{Monomial}, rather than an expanded \hyperlink{group__polygroup_class_monomial}{Monomial}. See if that changes things.
\item Re-\/examine what's going on with masks, since the plus to efficiency doesn't seem worth the effort.
\item Implement marked polynomials with a dynamic algorithm that works practically in the grevlex order, with the marked term being the true leading monomial. This may be very inefficient to reduce.
\item Implement a {\ttfamily Dictionary\+\_\+\+Linked\+\_\+\+Polynomial} class, where any term points to one unique instance of a monomial, rather than having many copies of monomials in different polynomials. Upside is that equality test during canonicalization is instantaneous (compare pointers). Downsides may include finding/sorting the monomials, indirection.
\item Detach monomial ordering from monomials, since caching ordering data doesn't seem to help much?
\item Implement a {\ttfamily Polynomial\+\_\+\+Builder} class to help build polynomials more easily by reading from an input file. That way we don't have to write a fresh control program for each example system. (see \hyperlink{group__utils_ga72d205e8226d578b892515edc527cc83}{user\+\_\+interface()})
\item Implement an \hyperlink{group__polygroup_class_indeterminate}{Indeterminate} class and a {\ttfamily Polynomial\+\_\+\+Builder} class to help build polynomials more easily.
\end{DoxyItemize}\end{DoxyRefDesc}
\hypertarget{index_lopri}{}\subsection{Lower priority}\label{index_lopri}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000003}{Todo}]I'm not sure these are worth doing.
\begin{DoxyItemize}
\item Most skeleton code seems to have little overhead, so most ``improvements'' related to that falls here\+:
\begin{DoxyItemize}
\item Implement D\+DM with the Fukuda-\/\+Prodon criterion, compare to Zolotykh's.
\item Implement Roune's algorithms for Hilbert functions.
\item Compare each potential PP with all other potential PP's, reducing the number of false positives. \mbox{[}This does not seem to be necessary at the moment, as the overhead is quite small, but it is still a thought.\mbox{]}
\item Add a hash mechanism to the {\ttfamily constraint} class to help avoid redundnacy.
\end{DoxyItemize}
\item Create a Matrix\+\_\+\+Ordering\+\_\+\+Data class as a subset of \hyperlink{group__orderinggroup_class_monomial___order___data}{Monomial\+\_\+\+Order\+\_\+\+Data}.
\item Add an {\ttfamily insert()} function to \hyperlink{group__polygroup_class_monomial___node}{Monomial\+\_\+\+Node} to insert another \hyperlink{group__polygroup_class_polynomial___linked___list}{Polynomial\+\_\+\+Linked\+\_\+\+List}, subsequently to be destroyed.
\item Think about computing all inverses of a small prime field immediately at startup.
\item Test matrix orderings more thoroughly.
\end{DoxyItemize}\end{DoxyRefDesc}
\hypertarget{index_Apologia}{}\section{Apologia pro labora sua}\label{index_Apologia}
This probably has bugs I haven't yet worked out, but I have done a lot of bug-\/fixing, including the use of {\ttfamily valgrind} to identify and repair memory leaks.

I originally implemented this in Sage. That was purely a proof-\/of-\/concept product; it was very slow, and I wanted to improve on it. Unfortunately\+:

\begin{DoxyItemize}
\item It is not easy to use the guts of Singular from Sage. In particular, the geobuckets. But even if that were possible{$\dots$} \item In all the computer algebra systems I've looked at, a monomial ordering is part of the ring structure. At least in Singular, a ``wgrevlex'' ordering received a different structure than a ``grevlex'' ordering, in particular a disadvantageous structure. So my preliminary implementation in Singular worked, but tended to be a lot slower than {\ttfamily std()} {\itshape even though it did less work.} In addition, the implementation crashed often, for reasons I wasn't able to sort out, even with help from the developers.\end{DoxyItemize}
That is when I decided to develop this code. As it turns out, that was a good thing, because the original Sage version had a number of bugs that I discovered only while developing later versions.

Although I wrote it from scratch, without a doubt it reflects what I saw in Co\+CoA and Singular. No great claim to originality or even usability is implied. The intent of this software is not to compete with those, but to provide a more robust launchpad to implement the algorithm there than I had before.\hypertarget{index_Copyright}{}\section{Copyright details}\label{index_Copyright}
This file is part of Dyn\+GB.

Dyn\+GB is free software\+: you can redistribute it and/or modify it under the terms of the G\+NU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.

Foobar is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU General Public License for more details.

You should have received a copy of the G\+NU General Public License along with Dyn\+GB. If not, see \href{http://www.gnu.org/licenses/}{\tt http\+://www.\+gnu.\+org/licenses/}. 